/* soapC.cpp
   Generated by gSOAP 2.7.13 from cs8server.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.13 2009-05-05 19:42:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ns1__SessionId:
		return soap_in_ns1__SessionId(soap, NULL, NULL, "ns1:SessionId");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns6__PowerReturnCode:
		return soap_in_ns6__PowerReturnCode(soap, NULL, NULL, "ns6:PowerReturnCode");
	case SOAP_TYPE_ns6__SchedulingMode:
		return soap_in_ns6__SchedulingMode(soap, NULL, NULL, "ns6:SchedulingMode");
	case SOAP_TYPE_ns6__ReversingResult:
		return soap_in_ns6__ReversingResult(soap, NULL, NULL, "ns6:ReversingResult");
	case SOAP_TYPE_ns6__MotionReturnCode:
		return soap_in_ns6__MotionReturnCode(soap, NULL, NULL, "ns6:MotionReturnCode");
	case SOAP_TYPE_ns6__AboveBelowConfig:
		return soap_in_ns6__AboveBelowConfig(soap, NULL, NULL, "ns6:AboveBelowConfig");
	case SOAP_TYPE_ns6__PositiveNegativeConfig:
		return soap_in_ns6__PositiveNegativeConfig(soap, NULL, NULL, "ns6:PositiveNegativeConfig");
	case SOAP_TYPE_ns6__ShoulderConfig:
		return soap_in_ns6__ShoulderConfig(soap, NULL, NULL, "ns6:ShoulderConfig");
	case SOAP_TYPE_ns6__BlendType:
		return soap_in_ns6__BlendType(soap, NULL, NULL, "ns6:BlendType");
	case SOAP_TYPE_ns6__MoveType:
		return soap_in_ns6__MoveType(soap, NULL, NULL, "ns6:MoveType");
	case SOAP_TYPE_ns1__DiameterAxis3:
		return soap_in_ns1__DiameterAxis3(soap, NULL, NULL, "ns1:DiameterAxis3");
	case SOAP_TYPE_ns1__LengthAxis3:
		return soap_in_ns1__LengthAxis3(soap, NULL, NULL, "ns1:LengthAxis3");
	case SOAP_TYPE_ns1__MountType:
		return soap_in_ns1__MountType(soap, NULL, NULL, "ns1:MountType");
	case SOAP_TYPE_ns1__Kinematic:
		return soap_in_ns1__Kinematic(soap, NULL, NULL, "ns1:Kinematic");
	case SOAP_TYPE_ns1__ServerExceptionCode:
		return soap_in_ns1__ServerExceptionCode(soap, NULL, NULL, "ns1:ServerExceptionCode");
	case SOAP_TYPE_ns6__AllRobotsPos:
		return soap_in_ns6__AllRobotsPos(soap, NULL, NULL, "ns6:AllRobotsPos");
	case SOAP_TYPE_ns6__RobotPos:
		return soap_in_ns6__RobotPos(soap, NULL, NULL, "ns6:RobotPos");
	case SOAP_TYPE_ns6__MotionDesc:
		return soap_in_ns6__MotionDesc(soap, NULL, NULL, "ns6:MotionDesc");
	case SOAP_TYPE_ns6__Config:
		return soap_in_ns6__Config(soap, NULL, NULL, "ns6:Config");
	case SOAP_TYPE_ns6__VrbxConfig:
		return soap_in_ns6__VrbxConfig(soap, NULL, NULL, "ns6:VrbxConfig");
	case SOAP_TYPE_ns6__ScaraConfig:
		return soap_in_ns6__ScaraConfig(soap, NULL, NULL, "ns6:ScaraConfig");
	case SOAP_TYPE_ns6__AnthroConfig:
		return soap_in_ns6__AnthroConfig(soap, NULL, NULL, "ns6:AnthroConfig");
	case SOAP_TYPE_ns6__Frame:
		return soap_in_ns6__Frame(soap, NULL, NULL, "ns6:Frame");
	case SOAP_TYPE_ns6__Records:
		return soap_in_ns6__Records(soap, NULL, NULL, "ns6:Records");
	case SOAP_TYPE_ns6__VALApplications:
		return soap_in_ns6__VALApplications(soap, NULL, NULL, "ns6:VALApplications");
	case SOAP_TYPE_ns6__Robots:
		return soap_in_ns6__Robots(soap, NULL, NULL, "ns6:Robots");
	case SOAP_TYPE_ns6__Versions:
		return soap_in_ns6__Versions(soap, NULL, NULL, "ns6:Versions");
	case SOAP_TYPE_ns6__JointPos:
		return soap_in_ns6__JointPos(soap, NULL, NULL, "ns6:JointPos");
	case SOAP_TYPE_ns5__AllRobotsPos:
		return soap_in_ns5__AllRobotsPos(soap, NULL, NULL, "ns5:AllRobotsPos");
	case SOAP_TYPE_ns5__Records:
		return soap_in_ns5__Records(soap, NULL, NULL, "ns5:Records");
	case SOAP_TYPE_ns5__VALApplications:
		return soap_in_ns5__VALApplications(soap, NULL, NULL, "ns5:VALApplications");
	case SOAP_TYPE_ns5__Robots:
		return soap_in_ns5__Robots(soap, NULL, NULL, "ns5:Robots");
	case SOAP_TYPE_ns5__Versions:
		return soap_in_ns5__Versions(soap, NULL, NULL, "ns5:Versions");
	case SOAP_TYPE_ns5__JointPos:
		return soap_in_ns5__JointPos(soap, NULL, NULL, "ns5:JointPos");
	case SOAP_TYPE_ns4__hexBinary:
		return soap_in_ns4__hexBinary(soap, NULL, NULL, "ns4:hexBinary");
	case SOAP_TYPE_ns4__base64Binary:
		return soap_in_ns4__base64Binary(soap, NULL, NULL, "ns4:base64Binary");
	case SOAP_TYPE_ns3__Include:
		return soap_in_ns3__Include(soap, NULL, NULL, "ns3:Include");
	case SOAP_TYPE_ns2__JointRange:
		return soap_in_ns2__JointRange(soap, NULL, NULL, "ns2:JointRange");
	case SOAP_TYPE_ns2__Records:
		return soap_in_ns2__Records(soap, NULL, NULL, "ns2:Records");
	case SOAP_TYPE_ns2__Data:
		return soap_in_ns2__Data(soap, NULL, NULL, "ns2:Data");
	case SOAP_TYPE_ns2__VALApplications:
		return soap_in_ns2__VALApplications(soap, NULL, NULL, "ns2:VALApplications");
	case SOAP_TYPE_ns2__VALApplication:
		return soap_in_ns2__VALApplication(soap, NULL, NULL, "ns2:VALApplication");
	case SOAP_TYPE_ns1__Parameters:
		return soap_in_ns1__Parameters(soap, NULL, NULL, "ns1:Parameters");
	case SOAP_TYPE_ns1__Parameter:
		return soap_in_ns1__Parameter(soap, NULL, NULL, "ns1:Parameter");
	case SOAP_TYPE_ns1__Robots:
		return soap_in_ns1__Robots(soap, NULL, NULL, "ns1:Robots");
	case SOAP_TYPE_ns1__SoapServerVersion:
		return soap_in_ns1__SoapServerVersion(soap, NULL, NULL, "ns1:SoapServerVersion");
	case SOAP_TYPE_ns1__Versions:
		return soap_in_ns1__Versions(soap, NULL, NULL, "ns1:Versions");
	case SOAP_TYPE_ns1__Version:
		return soap_in_ns1__Version(soap, NULL, NULL, "ns1:Version");
	case SOAP_TYPE_ns1__Robot:
		return soap_in_ns1__Robot(soap, NULL, NULL, "ns1:Robot");
	case SOAP_TYPE_ns1__CartesianPos:
		return soap_in_ns1__CartesianPos(soap, NULL, NULL, "ns1:CartesianPos");
	case SOAP_TYPE_ns1__JointPos:
		return soap_in_ns1__JointPos(soap, NULL, NULL, "ns1:JointPos");
	case SOAP_TYPE_ns1__ServerException:
		return soap_in_ns1__ServerException(soap, NULL, NULL, "ns1:ServerException");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, NULL, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns6__setPowerResponse:
		return soap_in_PointerTo_ns6__setPowerResponse(soap, NULL, NULL, "ns6:setPowerResponse");
	case SOAP_TYPE_PointerTo_ns6__setPower:
		return soap_in_PointerTo_ns6__setPower(soap, NULL, NULL, "ns6:setPower");
	case SOAP_TYPE_PointerTo_ns6__MotionAndRobotsPos:
		return soap_in_PointerTo_ns6__MotionAndRobotsPos(soap, NULL, NULL, "ns6:MotionAndRobotsPos");
	case SOAP_TYPE_PointerTo_ns6__schedulerRefresh:
		return soap_in_PointerTo_ns6__schedulerRefresh(soap, NULL, NULL, "ns6:schedulerRefresh");
	case SOAP_TYPE_PointerTo_ns6__setSchedulingModeResponse:
		return soap_in_PointerTo_ns6__setSchedulingModeResponse(soap, NULL, NULL, "ns6:setSchedulingModeResponse");
	case SOAP_TYPE_PointerTo_ns6__setSchedulingMode:
		return soap_in_PointerTo_ns6__setSchedulingMode(soap, NULL, NULL, "ns6:setSchedulingMode");
	case SOAP_TYPE_PointerTo_ns6__restartMotion:
		return soap_in_PointerTo_ns6__restartMotion(soap, NULL, NULL, "ns6:restartMotion");
	case SOAP_TYPE_PointerTo_ns6__stopMotion:
		return soap_in_PointerTo_ns6__stopMotion(soap, NULL, NULL, "ns6:stopMotion");
	case SOAP_TYPE_PointerTo_ns6__motionResponse:
		return soap_in_PointerTo_ns6__motionResponse(soap, NULL, NULL, "ns6:motionResponse");
	case SOAP_TYPE_PointerTo_ns6__resetMotion:
		return soap_in_PointerTo_ns6__resetMotion(soap, NULL, NULL, "ns6:resetMotion");
	case SOAP_TYPE_PointerTo_ns6__moveC:
		return soap_in_PointerTo_ns6__moveC(soap, NULL, NULL, "ns6:moveC");
	case SOAP_TYPE_PointerTo_ns6__moveL:
		return soap_in_PointerTo_ns6__moveL(soap, NULL, NULL, "ns6:moveL");
	case SOAP_TYPE_PointerTo_ns6__moveJC:
		return soap_in_PointerTo_ns6__moveJC(soap, NULL, NULL, "ns6:moveJC");
	case SOAP_TYPE_PointerTo_ns6__moveResponse:
		return soap_in_PointerTo_ns6__moveResponse(soap, NULL, NULL, "ns6:moveResponse");
	case SOAP_TYPE_PointerTo_ns6__moveJJ:
		return soap_in_PointerTo_ns6__moveJJ(soap, NULL, NULL, "ns6:moveJJ");
	case SOAP_TYPE_PointerTo_ns6__reverseKinResponse:
		return soap_in_PointerTo_ns6__reverseKinResponse(soap, NULL, NULL, "ns6:reverseKinResponse");
	case SOAP_TYPE_PointerTo_ns6__reverseKin:
		return soap_in_PointerTo_ns6__reverseKin(soap, NULL, NULL, "ns6:reverseKin");
	case SOAP_TYPE_PointerTo_ns6__forwardKinResponse:
		return soap_in_PointerTo_ns6__forwardKinResponse(soap, NULL, NULL, "ns6:forwardKinResponse");
	case SOAP_TYPE_PointerTo_ns6__forwardKin:
		return soap_in_PointerTo_ns6__forwardKin(soap, NULL, NULL, "ns6:forwardKin");
	case SOAP_TYPE_PointerTo_ns2__getJointRangeResponse:
		return soap_in_PointerTo_ns2__getJointRangeResponse(soap, NULL, NULL, "ns2:getJointRangeResponse");
	case SOAP_TYPE_PointerTo_ns2__getJointRange:
		return soap_in_PointerTo_ns2__getJointRange(soap, NULL, NULL, "ns2:getJointRange");
	case SOAP_TYPE_PointerTo_ns2__getRecordResponse:
		return soap_in_PointerTo_ns2__getRecordResponse(soap, NULL, NULL, "ns2:getRecordResponse");
	case SOAP_TYPE_PointerTo_ns2__getRecord:
		return soap_in_PointerTo_ns2__getRecord(soap, NULL, NULL, "ns2:getRecord");
	case SOAP_TYPE_PointerTo_ns2__getRecordsResponse:
		return soap_in_PointerTo_ns2__getRecordsResponse(soap, NULL, NULL, "ns2:getRecordsResponse");
	case SOAP_TYPE_PointerTo_ns2__getRecords:
		return soap_in_PointerTo_ns2__getRecords(soap, NULL, NULL, "ns2:getRecords");
	case SOAP_TYPE_PointerTo_ns2__getApplicationDatasResponse:
		return soap_in_PointerTo_ns2__getApplicationDatasResponse(soap, NULL, NULL, "ns2:getApplicationDatasResponse");
	case SOAP_TYPE_PointerTo_ns2__getApplicationDatas:
		return soap_in_PointerTo_ns2__getApplicationDatas(soap, NULL, NULL, "ns2:getApplicationDatas");
	case SOAP_TYPE_PointerTo_ns2__getApplicationsResponse:
		return soap_in_PointerTo_ns2__getApplicationsResponse(soap, NULL, NULL, "ns2:getApplicationsResponse");
	case SOAP_TYPE_PointerTo_ns2__getApplications:
		return soap_in_PointerTo_ns2__getApplications(soap, NULL, NULL, "ns2:getApplications");
	case SOAP_TYPE_PointerTo_ns1__setRobotPosResponse:
		return soap_in_PointerTo_ns1__setRobotPosResponse(soap, NULL, NULL, "ns1:setRobotPosResponse");
	case SOAP_TYPE_PointerTo_ns1__setRobotJointPos:
		return soap_in_PointerTo_ns1__setRobotJointPos(soap, NULL, NULL, "ns1:setRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse:
		return soap_in_PointerTo_ns1__getRobotJntCartPosResponse(soap, NULL, NULL, "ns1:getRobotJntCartPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos:
		return soap_in_PointerTo_ns1__getRobotJntCartPos(soap, NULL, NULL, "ns1:getRobotJntCartPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse:
		return soap_in_PointerTo_ns1__getRobotJointPosResponse(soap, NULL, NULL, "ns1:getRobotJointPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPos:
		return soap_in_PointerTo_ns1__getRobotJointPos(soap, NULL, NULL, "ns1:getRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotsResponse:
		return soap_in_PointerTo_ns1__getRobotsResponse(soap, NULL, NULL, "ns1:getRobotsResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobots:
		return soap_in_PointerTo_ns1__getRobots(soap, NULL, NULL, "ns1:getRobots");
	case SOAP_TYPE_PointerTo_ns1__logoutResponse:
		return soap_in_PointerTo_ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTo_ns1__logout:
		return soap_in_PointerTo_ns1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_in_PointerTo_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__login:
		return soap_in_PointerTo_ns1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse:
		return soap_in_PointerTo_ns1__getCS8VersionsResponse(soap, NULL, NULL, "ns1:getCS8VersionsResponse");
	case SOAP_TYPE_PointerTo_ns1__getCS8Versions:
		return soap_in_PointerTo_ns1__getCS8Versions(soap, NULL, NULL, "ns1:getCS8Versions");
	case SOAP_TYPE_PointerTo_ns1__pingResponse:
		return soap_in_PointerTo_ns1__pingResponse(soap, NULL, NULL, "ns1:pingResponse");
	case SOAP_TYPE_PointerTo_ns1__ping:
		return soap_in_PointerTo_ns1__ping(soap, NULL, NULL, "ns1:ping");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse:
		return soap_in_PointerTo_ns1__getSoapServerVersionResponse(soap, NULL, NULL, "ns1:getSoapServerVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersion:
		return soap_in_PointerTo_ns1__getSoapServerVersion(soap, NULL, NULL, "ns1:getSoapServerVersion");
	case SOAP_TYPE_PointerTons1__ServerException:
		return soap_in_PointerTons1__ServerException(soap, NULL, NULL, "ns1:ServerException");
	case SOAP_TYPE_PointerTons1__SessionId:
		return soap_in_PointerTons1__SessionId(soap, NULL, NULL, "ns1:SessionId");
	case SOAP_TYPE_PointerTons6__AllRobotsPos:
		return soap_in_PointerTons6__AllRobotsPos(soap, NULL, NULL, "ns6:AllRobotsPos");
	case SOAP_TYPE_PointerTons6__MotionDesc:
		return soap_in_PointerTons6__MotionDesc(soap, NULL, NULL, "ns6:MotionDesc");
	case SOAP_TYPE_PointerTons6__Config:
		return soap_in_PointerTons6__Config(soap, NULL, NULL, "ns6:Config");
	case SOAP_TYPE_PointerTons6__Frame:
		return soap_in_PointerTons6__Frame(soap, NULL, NULL, "ns6:Frame");
	case SOAP_TYPE_PointerTons6__VrbxConfig:
		return soap_in_PointerTons6__VrbxConfig(soap, NULL, NULL, "ns6:VrbxConfig");
	case SOAP_TYPE_PointerTons6__ScaraConfig:
		return soap_in_PointerTons6__ScaraConfig(soap, NULL, NULL, "ns6:ScaraConfig");
	case SOAP_TYPE_PointerTons6__AnthroConfig:
		return soap_in_PointerTons6__AnthroConfig(soap, NULL, NULL, "ns6:AnthroConfig");
	case SOAP_TYPE_PointerTons6__RobotPos:
		return soap_in_PointerTons6__RobotPos(soap, NULL, NULL, "ns6:RobotPos");
	case SOAP_TYPE_PointerTons2__JointRange:
		return soap_in_PointerTons2__JointRange(soap, NULL, NULL, "ns2:JointRange");
	case SOAP_TYPE_PointerTons2__Records:
		return soap_in_PointerTons2__Records(soap, NULL, NULL, "ns2:Records");
	case SOAP_TYPE_PointerTons2__VALApplications:
		return soap_in_PointerTons2__VALApplications(soap, NULL, NULL, "ns2:VALApplications");
	case SOAP_TYPE_PointerTons3__Include:
		return soap_in_PointerTons3__Include(soap, NULL, NULL, "ns3:Include");
	case SOAP_TYPE_PointerTons2__VALApplication:
		return soap_in_PointerTons2__VALApplication(soap, NULL, NULL, "ns2:VALApplication");
	case SOAP_TYPE_PointerTons1__Parameters:
		return soap_in_PointerTons1__Parameters(soap, NULL, NULL, "ns1:Parameters");
	case SOAP_TYPE_PointerTons1__CartesianPos:
		return soap_in_PointerTons1__CartesianPos(soap, NULL, NULL, "ns1:CartesianPos");
	case SOAP_TYPE_PointerTons1__JointPos:
		return soap_in_PointerTons1__JointPos(soap, NULL, NULL, "ns1:JointPos");
	case SOAP_TYPE_PointerTons1__Robots:
		return soap_in_PointerTons1__Robots(soap, NULL, NULL, "ns1:Robots");
	case SOAP_TYPE_PointerTons1__Versions:
		return soap_in_PointerTons1__Versions(soap, NULL, NULL, "ns1:Versions");
	case SOAP_TYPE_PointerTons1__SoapServerVersion:
		return soap_in_PointerTons1__SoapServerVersion(soap, NULL, NULL, "ns1:SoapServerVersion");
	case SOAP_TYPE_PointerTons1__Parameter:
		return soap_in_PointerTons1__Parameter(soap, NULL, NULL, "ns1:Parameter");
	case SOAP_TYPE_PointerTons1__Robot:
		return soap_in_PointerTons1__Robot(soap, NULL, NULL, "ns1:Robot");
	case SOAP_TYPE_PointerTons1__Version:
		return soap_in_PointerTons1__Version(soap, NULL, NULL, "ns1:Version");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns6:AllRobotsPos"))
		{	*type = SOAP_TYPE_ns6__AllRobotsPos;
			return soap_in_ns6__AllRobotsPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RobotPos"))
		{	*type = SOAP_TYPE_ns6__RobotPos;
			return soap_in_ns6__RobotPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:MotionDesc"))
		{	*type = SOAP_TYPE_ns6__MotionDesc;
			return soap_in_ns6__MotionDesc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Config"))
		{	*type = SOAP_TYPE_ns6__Config;
			return soap_in_ns6__Config(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:VrbxConfig"))
		{	*type = SOAP_TYPE_ns6__VrbxConfig;
			return soap_in_ns6__VrbxConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ScaraConfig"))
		{	*type = SOAP_TYPE_ns6__ScaraConfig;
			return soap_in_ns6__ScaraConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:AnthroConfig"))
		{	*type = SOAP_TYPE_ns6__AnthroConfig;
			return soap_in_ns6__AnthroConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Frame"))
		{	*type = SOAP_TYPE_ns6__Frame;
			return soap_in_ns6__Frame(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Records"))
		{	*type = SOAP_TYPE_ns6__Records;
			return soap_in_ns6__Records(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:VALApplications"))
		{	*type = SOAP_TYPE_ns6__VALApplications;
			return soap_in_ns6__VALApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Robots"))
		{	*type = SOAP_TYPE_ns6__Robots;
			return soap_in_ns6__Robots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Versions"))
		{	*type = SOAP_TYPE_ns6__Versions;
			return soap_in_ns6__Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:JointPos"))
		{	*type = SOAP_TYPE_ns6__JointPos;
			return soap_in_ns6__JointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:AllRobotsPos"))
		{	*type = SOAP_TYPE_ns5__AllRobotsPos;
			return soap_in_ns5__AllRobotsPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Records"))
		{	*type = SOAP_TYPE_ns5__Records;
			return soap_in_ns5__Records(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:VALApplications"))
		{	*type = SOAP_TYPE_ns5__VALApplications;
			return soap_in_ns5__VALApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Robots"))
		{	*type = SOAP_TYPE_ns5__Robots;
			return soap_in_ns5__Robots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Versions"))
		{	*type = SOAP_TYPE_ns5__Versions;
			return soap_in_ns5__Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:JointPos"))
		{	*type = SOAP_TYPE_ns5__JointPos;
			return soap_in_ns5__JointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:hexBinary"))
		{	*type = SOAP_TYPE_ns4__hexBinary;
			return soap_in_ns4__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:base64Binary"))
		{	*type = SOAP_TYPE_ns4__base64Binary;
			return soap_in_ns4__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Include"))
		{	*type = SOAP_TYPE_ns3__Include;
			return soap_in_ns3__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:JointRange"))
		{	*type = SOAP_TYPE_ns2__JointRange;
			return soap_in_ns2__JointRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Records"))
		{	*type = SOAP_TYPE_ns2__Records;
			return soap_in_ns2__Records(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Data"))
		{	*type = SOAP_TYPE_ns2__Data;
			return soap_in_ns2__Data(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VALApplications"))
		{	*type = SOAP_TYPE_ns2__VALApplications;
			return soap_in_ns2__VALApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VALApplication"))
		{	*type = SOAP_TYPE_ns2__VALApplication;
			return soap_in_ns2__VALApplication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Parameters"))
		{	*type = SOAP_TYPE_ns1__Parameters;
			return soap_in_ns1__Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Parameter"))
		{	*type = SOAP_TYPE_ns1__Parameter;
			return soap_in_ns1__Parameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Robots"))
		{	*type = SOAP_TYPE_ns1__Robots;
			return soap_in_ns1__Robots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoapServerVersion"))
		{	*type = SOAP_TYPE_ns1__SoapServerVersion;
			return soap_in_ns1__SoapServerVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Versions"))
		{	*type = SOAP_TYPE_ns1__Versions;
			return soap_in_ns1__Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Version"))
		{	*type = SOAP_TYPE_ns1__Version;
			return soap_in_ns1__Version(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Robot"))
		{	*type = SOAP_TYPE_ns1__Robot;
			return soap_in_ns1__Robot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CartesianPos"))
		{	*type = SOAP_TYPE_ns1__CartesianPos;
			return soap_in_ns1__CartesianPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JointPos"))
		{	*type = SOAP_TYPE_ns1__JointPos;
			return soap_in_ns1__JointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerException"))
		{	*type = SOAP_TYPE_ns1__ServerException;
			return soap_in_ns1__ServerException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SessionId"))
		{	*type = SOAP_TYPE_ns1__SessionId;
			return soap_in_ns1__SessionId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:PowerReturnCode"))
		{	*type = SOAP_TYPE_ns6__PowerReturnCode;
			return soap_in_ns6__PowerReturnCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:SchedulingMode"))
		{	*type = SOAP_TYPE_ns6__SchedulingMode;
			return soap_in_ns6__SchedulingMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ReversingResult"))
		{	*type = SOAP_TYPE_ns6__ReversingResult;
			return soap_in_ns6__ReversingResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:MotionReturnCode"))
		{	*type = SOAP_TYPE_ns6__MotionReturnCode;
			return soap_in_ns6__MotionReturnCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:AboveBelowConfig"))
		{	*type = SOAP_TYPE_ns6__AboveBelowConfig;
			return soap_in_ns6__AboveBelowConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:PositiveNegativeConfig"))
		{	*type = SOAP_TYPE_ns6__PositiveNegativeConfig;
			return soap_in_ns6__PositiveNegativeConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ShoulderConfig"))
		{	*type = SOAP_TYPE_ns6__ShoulderConfig;
			return soap_in_ns6__ShoulderConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:BlendType"))
		{	*type = SOAP_TYPE_ns6__BlendType;
			return soap_in_ns6__BlendType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:MoveType"))
		{	*type = SOAP_TYPE_ns6__MoveType;
			return soap_in_ns6__MoveType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiameterAxis3"))
		{	*type = SOAP_TYPE_ns1__DiameterAxis3;
			return soap_in_ns1__DiameterAxis3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LengthAxis3"))
		{	*type = SOAP_TYPE_ns1__LengthAxis3;
			return soap_in_ns1__LengthAxis3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MountType"))
		{	*type = SOAP_TYPE_ns1__MountType;
			return soap_in_ns1__MountType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Kinematic"))
		{	*type = SOAP_TYPE_ns1__Kinematic;
			return soap_in_ns1__Kinematic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerExceptionCode"))
		{	*type = SOAP_TYPE_ns1__ServerExceptionCode;
			return soap_in_ns1__ServerExceptionCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns6:setPowerResponse"))
		{	*type = SOAP_TYPE__ns6__setPowerResponse;
			return soap_in__ns6__setPowerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:setPower"))
		{	*type = SOAP_TYPE__ns6__setPower;
			return soap_in__ns6__setPower(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:MotionAndRobotsPos"))
		{	*type = SOAP_TYPE__ns6__MotionAndRobotsPos;
			return soap_in__ns6__MotionAndRobotsPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:schedulerRefresh"))
		{	*type = SOAP_TYPE__ns6__schedulerRefresh;
			return soap_in__ns6__schedulerRefresh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:setSchedulingModeResponse"))
		{	*type = SOAP_TYPE__ns6__setSchedulingModeResponse;
			return soap_in__ns6__setSchedulingModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:setSchedulingMode"))
		{	*type = SOAP_TYPE__ns6__setSchedulingMode;
			return soap_in__ns6__setSchedulingMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:restartMotion"))
		{	*type = SOAP_TYPE__ns6__restartMotion;
			return soap_in__ns6__restartMotion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:stopMotion"))
		{	*type = SOAP_TYPE__ns6__stopMotion;
			return soap_in__ns6__stopMotion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:motionResponse"))
		{	*type = SOAP_TYPE__ns6__motionResponse;
			return soap_in__ns6__motionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:resetMotion"))
		{	*type = SOAP_TYPE__ns6__resetMotion;
			return soap_in__ns6__resetMotion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:moveC"))
		{	*type = SOAP_TYPE__ns6__moveC;
			return soap_in__ns6__moveC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:moveL"))
		{	*type = SOAP_TYPE__ns6__moveL;
			return soap_in__ns6__moveL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:moveJC"))
		{	*type = SOAP_TYPE__ns6__moveJC;
			return soap_in__ns6__moveJC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:moveResponse"))
		{	*type = SOAP_TYPE__ns6__moveResponse;
			return soap_in__ns6__moveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:moveJJ"))
		{	*type = SOAP_TYPE__ns6__moveJJ;
			return soap_in__ns6__moveJJ(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:reverseKinResponse"))
		{	*type = SOAP_TYPE__ns6__reverseKinResponse;
			return soap_in__ns6__reverseKinResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:reverseKin"))
		{	*type = SOAP_TYPE__ns6__reverseKin;
			return soap_in__ns6__reverseKin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:forwardKinResponse"))
		{	*type = SOAP_TYPE__ns6__forwardKinResponse;
			return soap_in__ns6__forwardKinResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:forwardKin"))
		{	*type = SOAP_TYPE__ns6__forwardKin;
			return soap_in__ns6__forwardKin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getJointRangeResponse"))
		{	*type = SOAP_TYPE__ns2__getJointRangeResponse;
			return soap_in__ns2__getJointRangeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getJointRange"))
		{	*type = SOAP_TYPE__ns2__getJointRange;
			return soap_in__ns2__getJointRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecordResponse"))
		{	*type = SOAP_TYPE__ns2__getRecordResponse;
			return soap_in__ns2__getRecordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecord"))
		{	*type = SOAP_TYPE__ns2__getRecord;
			return soap_in__ns2__getRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecordsResponse"))
		{	*type = SOAP_TYPE__ns2__getRecordsResponse;
			return soap_in__ns2__getRecordsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getRecords"))
		{	*type = SOAP_TYPE__ns2__getRecords;
			return soap_in__ns2__getRecords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplicationDatasResponse"))
		{	*type = SOAP_TYPE__ns2__getApplicationDatasResponse;
			return soap_in__ns2__getApplicationDatasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplicationDatas"))
		{	*type = SOAP_TYPE__ns2__getApplicationDatas;
			return soap_in__ns2__getApplicationDatas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplicationsResponse"))
		{	*type = SOAP_TYPE__ns2__getApplicationsResponse;
			return soap_in__ns2__getApplicationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:getApplications"))
		{	*type = SOAP_TYPE__ns2__getApplications;
			return soap_in__ns2__getApplications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8CompatibilityResponse"))
		{	*type = SOAP_TYPE__ns1__getCS8CompatibilityResponse;
			return soap_in__ns1__getCS8CompatibilityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8Compatibility"))
		{	*type = SOAP_TYPE__ns1__getCS8Compatibility;
			return soap_in__ns1__getCS8Compatibility(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getControllerParametersResponse"))
		{	*type = SOAP_TYPE__ns1__getControllerParametersResponse;
			return soap_in__ns1__getControllerParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getControllerParameters"))
		{	*type = SOAP_TYPE__ns1__getControllerParameters;
			return soap_in__ns1__getControllerParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findServerResponse"))
		{	*type = SOAP_TYPE__ns1__findServerResponse;
			return soap_in__ns1__findServerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findServer"))
		{	*type = SOAP_TYPE__ns1__findServer;
			return soap_in__ns1__findServer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRobotPosResponse"))
		{	*type = SOAP_TYPE__ns1__setRobotPosResponse;
			return soap_in__ns1__setRobotPosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setRobotJointPos"))
		{	*type = SOAP_TYPE__ns1__setRobotJointPos;
			return soap_in__ns1__setRobotJointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJntCartPosResponse"))
		{	*type = SOAP_TYPE__ns1__getRobotJntCartPosResponse;
			return soap_in__ns1__getRobotJntCartPosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJntCartPos"))
		{	*type = SOAP_TYPE__ns1__getRobotJntCartPos;
			return soap_in__ns1__getRobotJntCartPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJointPosResponse"))
		{	*type = SOAP_TYPE__ns1__getRobotJointPosResponse;
			return soap_in__ns1__getRobotJointPosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotJointPos"))
		{	*type = SOAP_TYPE__ns1__getRobotJointPos;
			return soap_in__ns1__getRobotJointPos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobotsResponse"))
		{	*type = SOAP_TYPE__ns1__getRobotsResponse;
			return soap_in__ns1__getRobotsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRobots"))
		{	*type = SOAP_TYPE__ns1__getRobots;
			return soap_in__ns1__getRobots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE__ns1__logoutResponse;
			return soap_in__ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE__ns1__logout;
			return soap_in__ns1__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE__ns1__loginResponse;
			return soap_in__ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE__ns1__login;
			return soap_in__ns1__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8VersionsResponse"))
		{	*type = SOAP_TYPE__ns1__getCS8VersionsResponse;
			return soap_in__ns1__getCS8VersionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCS8Versions"))
		{	*type = SOAP_TYPE__ns1__getCS8Versions;
			return soap_in__ns1__getCS8Versions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pingResponse"))
		{	*type = SOAP_TYPE__ns1__pingResponse;
			return soap_in__ns1__pingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ping"))
		{	*type = SOAP_TYPE__ns1__ping;
			return soap_in__ns1__ping(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSoapServerVersionResponse"))
		{	*type = SOAP_TYPE__ns1__getSoapServerVersionResponse;
			return soap_in__ns1__getSoapServerVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSoapServerVersion"))
		{	*type = SOAP_TYPE__ns1__getSoapServerVersion;
			return soap_in__ns1__getSoapServerVersion(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ns1__SessionId:
		return soap_out_ns1__SessionId(soap, tag, id, (const int *)ptr, "ns1:SessionId");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns6__PowerReturnCode:
		return soap_out_ns6__PowerReturnCode(soap, tag, id, (const enum ns6__PowerReturnCode *)ptr, "ns6:PowerReturnCode");
	case SOAP_TYPE_ns6__SchedulingMode:
		return soap_out_ns6__SchedulingMode(soap, tag, id, (const enum ns6__SchedulingMode *)ptr, "ns6:SchedulingMode");
	case SOAP_TYPE_ns6__ReversingResult:
		return soap_out_ns6__ReversingResult(soap, tag, id, (const enum ns6__ReversingResult *)ptr, "ns6:ReversingResult");
	case SOAP_TYPE_ns6__MotionReturnCode:
		return soap_out_ns6__MotionReturnCode(soap, tag, id, (const enum ns6__MotionReturnCode *)ptr, "ns6:MotionReturnCode");
	case SOAP_TYPE_ns6__AboveBelowConfig:
		return soap_out_ns6__AboveBelowConfig(soap, tag, id, (const enum ns6__AboveBelowConfig *)ptr, "ns6:AboveBelowConfig");
	case SOAP_TYPE_ns6__PositiveNegativeConfig:
		return soap_out_ns6__PositiveNegativeConfig(soap, tag, id, (const enum ns6__PositiveNegativeConfig *)ptr, "ns6:PositiveNegativeConfig");
	case SOAP_TYPE_ns6__ShoulderConfig:
		return soap_out_ns6__ShoulderConfig(soap, tag, id, (const enum ns6__ShoulderConfig *)ptr, "ns6:ShoulderConfig");
	case SOAP_TYPE_ns6__BlendType:
		return soap_out_ns6__BlendType(soap, tag, id, (const enum ns6__BlendType *)ptr, "ns6:BlendType");
	case SOAP_TYPE_ns6__MoveType:
		return soap_out_ns6__MoveType(soap, tag, id, (const enum ns6__MoveType *)ptr, "ns6:MoveType");
	case SOAP_TYPE_ns1__DiameterAxis3:
		return soap_out_ns1__DiameterAxis3(soap, tag, id, (const enum ns1__DiameterAxis3 *)ptr, "ns1:DiameterAxis3");
	case SOAP_TYPE_ns1__LengthAxis3:
		return soap_out_ns1__LengthAxis3(soap, tag, id, (const enum ns1__LengthAxis3 *)ptr, "ns1:LengthAxis3");
	case SOAP_TYPE_ns1__MountType:
		return soap_out_ns1__MountType(soap, tag, id, (const enum ns1__MountType *)ptr, "ns1:MountType");
	case SOAP_TYPE_ns1__Kinematic:
		return soap_out_ns1__Kinematic(soap, tag, id, (const enum ns1__Kinematic *)ptr, "ns1:Kinematic");
	case SOAP_TYPE_ns1__ServerExceptionCode:
		return soap_out_ns1__ServerExceptionCode(soap, tag, id, (const enum ns1__ServerExceptionCode *)ptr, "ns1:ServerExceptionCode");
	case SOAP_TYPE__ns6__setPowerResponse:
		return ((_ns6__setPowerResponse *)ptr)->soap_out(soap, "ns6:setPowerResponse", id, NULL);
	case SOAP_TYPE__ns6__setPower:
		return ((_ns6__setPower *)ptr)->soap_out(soap, "ns6:setPower", id, NULL);
	case SOAP_TYPE__ns6__MotionAndRobotsPos:
		return ((_ns6__MotionAndRobotsPos *)ptr)->soap_out(soap, "ns6:MotionAndRobotsPos", id, NULL);
	case SOAP_TYPE__ns6__schedulerRefresh:
		return ((_ns6__schedulerRefresh *)ptr)->soap_out(soap, "ns6:schedulerRefresh", id, NULL);
	case SOAP_TYPE__ns6__setSchedulingModeResponse:
		return ((_ns6__setSchedulingModeResponse *)ptr)->soap_out(soap, "ns6:setSchedulingModeResponse", id, NULL);
	case SOAP_TYPE__ns6__setSchedulingMode:
		return ((_ns6__setSchedulingMode *)ptr)->soap_out(soap, "ns6:setSchedulingMode", id, NULL);
	case SOAP_TYPE__ns6__restartMotion:
		return ((_ns6__restartMotion *)ptr)->soap_out(soap, "ns6:restartMotion", id, NULL);
	case SOAP_TYPE__ns6__stopMotion:
		return ((_ns6__stopMotion *)ptr)->soap_out(soap, "ns6:stopMotion", id, NULL);
	case SOAP_TYPE__ns6__motionResponse:
		return ((_ns6__motionResponse *)ptr)->soap_out(soap, "ns6:motionResponse", id, NULL);
	case SOAP_TYPE__ns6__resetMotion:
		return ((_ns6__resetMotion *)ptr)->soap_out(soap, "ns6:resetMotion", id, NULL);
	case SOAP_TYPE__ns6__moveC:
		return ((_ns6__moveC *)ptr)->soap_out(soap, "ns6:moveC", id, NULL);
	case SOAP_TYPE__ns6__moveL:
		return ((_ns6__moveL *)ptr)->soap_out(soap, "ns6:moveL", id, NULL);
	case SOAP_TYPE__ns6__moveJC:
		return ((_ns6__moveJC *)ptr)->soap_out(soap, "ns6:moveJC", id, NULL);
	case SOAP_TYPE__ns6__moveResponse:
		return ((_ns6__moveResponse *)ptr)->soap_out(soap, "ns6:moveResponse", id, NULL);
	case SOAP_TYPE__ns6__moveJJ:
		return ((_ns6__moveJJ *)ptr)->soap_out(soap, "ns6:moveJJ", id, NULL);
	case SOAP_TYPE__ns6__reverseKinResponse:
		return ((_ns6__reverseKinResponse *)ptr)->soap_out(soap, "ns6:reverseKinResponse", id, NULL);
	case SOAP_TYPE__ns6__reverseKin:
		return ((_ns6__reverseKin *)ptr)->soap_out(soap, "ns6:reverseKin", id, NULL);
	case SOAP_TYPE__ns6__forwardKinResponse:
		return ((_ns6__forwardKinResponse *)ptr)->soap_out(soap, "ns6:forwardKinResponse", id, NULL);
	case SOAP_TYPE__ns6__forwardKin:
		return ((_ns6__forwardKin *)ptr)->soap_out(soap, "ns6:forwardKin", id, NULL);
	case SOAP_TYPE_ns6__AllRobotsPos:
		return ((ns6__AllRobotsPos *)ptr)->soap_out(soap, tag, id, "ns6:AllRobotsPos");
	case SOAP_TYPE_ns6__RobotPos:
		return ((ns6__RobotPos *)ptr)->soap_out(soap, tag, id, "ns6:RobotPos");
	case SOAP_TYPE_ns6__MotionDesc:
		return ((ns6__MotionDesc *)ptr)->soap_out(soap, tag, id, "ns6:MotionDesc");
	case SOAP_TYPE_ns6__Config:
		return ((ns6__Config *)ptr)->soap_out(soap, tag, id, "ns6:Config");
	case SOAP_TYPE_ns6__VrbxConfig:
		return ((ns6__VrbxConfig *)ptr)->soap_out(soap, tag, id, "ns6:VrbxConfig");
	case SOAP_TYPE_ns6__ScaraConfig:
		return ((ns6__ScaraConfig *)ptr)->soap_out(soap, tag, id, "ns6:ScaraConfig");
	case SOAP_TYPE_ns6__AnthroConfig:
		return ((ns6__AnthroConfig *)ptr)->soap_out(soap, tag, id, "ns6:AnthroConfig");
	case SOAP_TYPE_ns6__Frame:
		return ((ns6__Frame *)ptr)->soap_out(soap, tag, id, "ns6:Frame");
	case SOAP_TYPE_ns6__Records:
		return ((ns6__Records *)ptr)->soap_out(soap, tag, id, "ns6:Records");
	case SOAP_TYPE_ns6__VALApplications:
		return ((ns6__VALApplications *)ptr)->soap_out(soap, tag, id, "ns6:VALApplications");
	case SOAP_TYPE_ns6__Robots:
		return ((ns6__Robots *)ptr)->soap_out(soap, tag, id, "ns6:Robots");
	case SOAP_TYPE_ns6__Versions:
		return ((ns6__Versions *)ptr)->soap_out(soap, tag, id, "ns6:Versions");
	case SOAP_TYPE_ns6__JointPos:
		return ((ns6__JointPos *)ptr)->soap_out(soap, tag, id, "ns6:JointPos");
	case SOAP_TYPE_ns5__AllRobotsPos:
		return ((ns5__AllRobotsPos *)ptr)->soap_out(soap, tag, id, "ns5:AllRobotsPos");
	case SOAP_TYPE_ns5__Records:
		return ((ns5__Records *)ptr)->soap_out(soap, tag, id, "ns5:Records");
	case SOAP_TYPE_ns5__VALApplications:
		return ((ns5__VALApplications *)ptr)->soap_out(soap, tag, id, "ns5:VALApplications");
	case SOAP_TYPE_ns5__Robots:
		return ((ns5__Robots *)ptr)->soap_out(soap, tag, id, "ns5:Robots");
	case SOAP_TYPE_ns5__Versions:
		return ((ns5__Versions *)ptr)->soap_out(soap, tag, id, "ns5:Versions");
	case SOAP_TYPE_ns5__JointPos:
		return ((ns5__JointPos *)ptr)->soap_out(soap, tag, id, "ns5:JointPos");
	case SOAP_TYPE_ns4__hexBinary:
		return ((ns4__hexBinary *)ptr)->soap_out(soap, tag, id, "ns4:hexBinary");
	case SOAP_TYPE_ns4__base64Binary:
		return ((ns4__base64Binary *)ptr)->soap_out(soap, tag, id, "ns4:base64Binary");
	case SOAP_TYPE_ns3__Include:
		return ((ns3__Include *)ptr)->soap_out(soap, tag, id, "ns3:Include");
	case SOAP_TYPE__ns2__getJointRangeResponse:
		return ((_ns2__getJointRangeResponse *)ptr)->soap_out(soap, "ns2:getJointRangeResponse", id, NULL);
	case SOAP_TYPE__ns2__getJointRange:
		return ((_ns2__getJointRange *)ptr)->soap_out(soap, "ns2:getJointRange", id, NULL);
	case SOAP_TYPE__ns2__getRecordResponse:
		return ((_ns2__getRecordResponse *)ptr)->soap_out(soap, "ns2:getRecordResponse", id, NULL);
	case SOAP_TYPE__ns2__getRecord:
		return ((_ns2__getRecord *)ptr)->soap_out(soap, "ns2:getRecord", id, NULL);
	case SOAP_TYPE__ns2__getRecordsResponse:
		return ((_ns2__getRecordsResponse *)ptr)->soap_out(soap, "ns2:getRecordsResponse", id, NULL);
	case SOAP_TYPE__ns2__getRecords:
		return ((_ns2__getRecords *)ptr)->soap_out(soap, "ns2:getRecords", id, NULL);
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		return ((_ns2__getApplicationDatasResponse *)ptr)->soap_out(soap, "ns2:getApplicationDatasResponse", id, NULL);
	case SOAP_TYPE__ns2__getApplicationDatas:
		return ((_ns2__getApplicationDatas *)ptr)->soap_out(soap, "ns2:getApplicationDatas", id, NULL);
	case SOAP_TYPE__ns2__getApplicationsResponse:
		return ((_ns2__getApplicationsResponse *)ptr)->soap_out(soap, "ns2:getApplicationsResponse", id, NULL);
	case SOAP_TYPE__ns2__getApplications:
		return ((_ns2__getApplications *)ptr)->soap_out(soap, "ns2:getApplications", id, NULL);
	case SOAP_TYPE_ns2__JointRange:
		return ((ns2__JointRange *)ptr)->soap_out(soap, tag, id, "ns2:JointRange");
	case SOAP_TYPE_ns2__Records:
		return ((ns2__Records *)ptr)->soap_out(soap, tag, id, "ns2:Records");
	case SOAP_TYPE_ns2__Data:
		return ((ns2__Data *)ptr)->soap_out(soap, tag, id, "ns2:Data");
	case SOAP_TYPE_ns2__VALApplications:
		return ((ns2__VALApplications *)ptr)->soap_out(soap, tag, id, "ns2:VALApplications");
	case SOAP_TYPE_ns2__VALApplication:
		return ((ns2__VALApplication *)ptr)->soap_out(soap, tag, id, "ns2:VALApplication");
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		return ((_ns1__getCS8CompatibilityResponse *)ptr)->soap_out(soap, "ns1:getCS8CompatibilityResponse", id, NULL);
	case SOAP_TYPE__ns1__getCS8Compatibility:
		return ((_ns1__getCS8Compatibility *)ptr)->soap_out(soap, "ns1:getCS8Compatibility", id, NULL);
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		return ((_ns1__getControllerParametersResponse *)ptr)->soap_out(soap, "ns1:getControllerParametersResponse", id, NULL);
	case SOAP_TYPE__ns1__getControllerParameters:
		return ((_ns1__getControllerParameters *)ptr)->soap_out(soap, "ns1:getControllerParameters", id, NULL);
	case SOAP_TYPE__ns1__findServerResponse:
		return ((_ns1__findServerResponse *)ptr)->soap_out(soap, "ns1:findServerResponse", id, NULL);
	case SOAP_TYPE__ns1__findServer:
		return ((_ns1__findServer *)ptr)->soap_out(soap, "ns1:findServer", id, NULL);
	case SOAP_TYPE__ns1__setRobotPosResponse:
		return ((_ns1__setRobotPosResponse *)ptr)->soap_out(soap, "ns1:setRobotPosResponse", id, NULL);
	case SOAP_TYPE__ns1__setRobotJointPos:
		return ((_ns1__setRobotJointPos *)ptr)->soap_out(soap, "ns1:setRobotJointPos", id, NULL);
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		return ((_ns1__getRobotJntCartPosResponse *)ptr)->soap_out(soap, "ns1:getRobotJntCartPosResponse", id, NULL);
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		return ((_ns1__getRobotJntCartPos *)ptr)->soap_out(soap, "ns1:getRobotJntCartPos", id, NULL);
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		return ((_ns1__getRobotJointPosResponse *)ptr)->soap_out(soap, "ns1:getRobotJointPosResponse", id, NULL);
	case SOAP_TYPE__ns1__getRobotJointPos:
		return ((_ns1__getRobotJointPos *)ptr)->soap_out(soap, "ns1:getRobotJointPos", id, NULL);
	case SOAP_TYPE__ns1__getRobotsResponse:
		return ((_ns1__getRobotsResponse *)ptr)->soap_out(soap, "ns1:getRobotsResponse", id, NULL);
	case SOAP_TYPE__ns1__getRobots:
		return ((_ns1__getRobots *)ptr)->soap_out(soap, "ns1:getRobots", id, NULL);
	case SOAP_TYPE__ns1__logoutResponse:
		return ((_ns1__logoutResponse *)ptr)->soap_out(soap, "ns1:logoutResponse", id, NULL);
	case SOAP_TYPE__ns1__logout:
		return ((_ns1__logout *)ptr)->soap_out(soap, "ns1:logout", id, NULL);
	case SOAP_TYPE__ns1__loginResponse:
		return ((_ns1__loginResponse *)ptr)->soap_out(soap, "ns1:loginResponse", id, NULL);
	case SOAP_TYPE__ns1__login:
		return ((_ns1__login *)ptr)->soap_out(soap, "ns1:login", id, NULL);
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		return ((_ns1__getCS8VersionsResponse *)ptr)->soap_out(soap, "ns1:getCS8VersionsResponse", id, NULL);
	case SOAP_TYPE__ns1__getCS8Versions:
		return ((_ns1__getCS8Versions *)ptr)->soap_out(soap, "ns1:getCS8Versions", id, NULL);
	case SOAP_TYPE__ns1__pingResponse:
		return ((_ns1__pingResponse *)ptr)->soap_out(soap, "ns1:pingResponse", id, NULL);
	case SOAP_TYPE__ns1__ping:
		return ((_ns1__ping *)ptr)->soap_out(soap, "ns1:ping", id, NULL);
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		return ((_ns1__getSoapServerVersionResponse *)ptr)->soap_out(soap, "ns1:getSoapServerVersionResponse", id, NULL);
	case SOAP_TYPE__ns1__getSoapServerVersion:
		return ((_ns1__getSoapServerVersion *)ptr)->soap_out(soap, "ns1:getSoapServerVersion", id, NULL);
	case SOAP_TYPE_ns1__Parameters:
		return ((ns1__Parameters *)ptr)->soap_out(soap, tag, id, "ns1:Parameters");
	case SOAP_TYPE_ns1__Parameter:
		return ((ns1__Parameter *)ptr)->soap_out(soap, tag, id, "ns1:Parameter");
	case SOAP_TYPE_ns1__Robots:
		return ((ns1__Robots *)ptr)->soap_out(soap, tag, id, "ns1:Robots");
	case SOAP_TYPE_ns1__SoapServerVersion:
		return ((ns1__SoapServerVersion *)ptr)->soap_out(soap, tag, id, "ns1:SoapServerVersion");
	case SOAP_TYPE_ns1__Versions:
		return ((ns1__Versions *)ptr)->soap_out(soap, tag, id, "ns1:Versions");
	case SOAP_TYPE_ns1__Version:
		return ((ns1__Version *)ptr)->soap_out(soap, tag, id, "ns1:Version");
	case SOAP_TYPE_ns1__Robot:
		return ((ns1__Robot *)ptr)->soap_out(soap, tag, id, "ns1:Robot");
	case SOAP_TYPE_ns1__CartesianPos:
		return ((ns1__CartesianPos *)ptr)->soap_out(soap, tag, id, "ns1:CartesianPos");
	case SOAP_TYPE_ns1__JointPos:
		return ((ns1__JointPos *)ptr)->soap_out(soap, tag, id, "ns1:JointPos");
	case SOAP_TYPE_ns1__ServerException:
		return ((ns1__ServerException *)ptr)->soap_out(soap, tag, id, "ns1:ServerException");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns6__setPowerResponse:
		return soap_out_PointerTo_ns6__setPowerResponse(soap, tag, id, (_ns6__setPowerResponse *const*)ptr, "ns6:setPowerResponse");
	case SOAP_TYPE_PointerTo_ns6__setPower:
		return soap_out_PointerTo_ns6__setPower(soap, tag, id, (_ns6__setPower *const*)ptr, "ns6:setPower");
	case SOAP_TYPE_PointerTo_ns6__MotionAndRobotsPos:
		return soap_out_PointerTo_ns6__MotionAndRobotsPos(soap, tag, id, (_ns6__MotionAndRobotsPos *const*)ptr, "ns6:MotionAndRobotsPos");
	case SOAP_TYPE_PointerTo_ns6__schedulerRefresh:
		return soap_out_PointerTo_ns6__schedulerRefresh(soap, tag, id, (_ns6__schedulerRefresh *const*)ptr, "ns6:schedulerRefresh");
	case SOAP_TYPE_PointerTo_ns6__setSchedulingModeResponse:
		return soap_out_PointerTo_ns6__setSchedulingModeResponse(soap, tag, id, (_ns6__setSchedulingModeResponse *const*)ptr, "ns6:setSchedulingModeResponse");
	case SOAP_TYPE_PointerTo_ns6__setSchedulingMode:
		return soap_out_PointerTo_ns6__setSchedulingMode(soap, tag, id, (_ns6__setSchedulingMode *const*)ptr, "ns6:setSchedulingMode");
	case SOAP_TYPE_PointerTo_ns6__restartMotion:
		return soap_out_PointerTo_ns6__restartMotion(soap, tag, id, (_ns6__restartMotion *const*)ptr, "ns6:restartMotion");
	case SOAP_TYPE_PointerTo_ns6__stopMotion:
		return soap_out_PointerTo_ns6__stopMotion(soap, tag, id, (_ns6__stopMotion *const*)ptr, "ns6:stopMotion");
	case SOAP_TYPE_PointerTo_ns6__motionResponse:
		return soap_out_PointerTo_ns6__motionResponse(soap, tag, id, (_ns6__motionResponse *const*)ptr, "ns6:motionResponse");
	case SOAP_TYPE_PointerTo_ns6__resetMotion:
		return soap_out_PointerTo_ns6__resetMotion(soap, tag, id, (_ns6__resetMotion *const*)ptr, "ns6:resetMotion");
	case SOAP_TYPE_PointerTo_ns6__moveC:
		return soap_out_PointerTo_ns6__moveC(soap, tag, id, (_ns6__moveC *const*)ptr, "ns6:moveC");
	case SOAP_TYPE_PointerTo_ns6__moveL:
		return soap_out_PointerTo_ns6__moveL(soap, tag, id, (_ns6__moveL *const*)ptr, "ns6:moveL");
	case SOAP_TYPE_PointerTo_ns6__moveJC:
		return soap_out_PointerTo_ns6__moveJC(soap, tag, id, (_ns6__moveJC *const*)ptr, "ns6:moveJC");
	case SOAP_TYPE_PointerTo_ns6__moveResponse:
		return soap_out_PointerTo_ns6__moveResponse(soap, tag, id, (_ns6__moveResponse *const*)ptr, "ns6:moveResponse");
	case SOAP_TYPE_PointerTo_ns6__moveJJ:
		return soap_out_PointerTo_ns6__moveJJ(soap, tag, id, (_ns6__moveJJ *const*)ptr, "ns6:moveJJ");
	case SOAP_TYPE_PointerTo_ns6__reverseKinResponse:
		return soap_out_PointerTo_ns6__reverseKinResponse(soap, tag, id, (_ns6__reverseKinResponse *const*)ptr, "ns6:reverseKinResponse");
	case SOAP_TYPE_PointerTo_ns6__reverseKin:
		return soap_out_PointerTo_ns6__reverseKin(soap, tag, id, (_ns6__reverseKin *const*)ptr, "ns6:reverseKin");
	case SOAP_TYPE_PointerTo_ns6__forwardKinResponse:
		return soap_out_PointerTo_ns6__forwardKinResponse(soap, tag, id, (_ns6__forwardKinResponse *const*)ptr, "ns6:forwardKinResponse");
	case SOAP_TYPE_PointerTo_ns6__forwardKin:
		return soap_out_PointerTo_ns6__forwardKin(soap, tag, id, (_ns6__forwardKin *const*)ptr, "ns6:forwardKin");
	case SOAP_TYPE_PointerTo_ns2__getJointRangeResponse:
		return soap_out_PointerTo_ns2__getJointRangeResponse(soap, tag, id, (_ns2__getJointRangeResponse *const*)ptr, "ns2:getJointRangeResponse");
	case SOAP_TYPE_PointerTo_ns2__getJointRange:
		return soap_out_PointerTo_ns2__getJointRange(soap, tag, id, (_ns2__getJointRange *const*)ptr, "ns2:getJointRange");
	case SOAP_TYPE_PointerTo_ns2__getRecordResponse:
		return soap_out_PointerTo_ns2__getRecordResponse(soap, tag, id, (_ns2__getRecordResponse *const*)ptr, "ns2:getRecordResponse");
	case SOAP_TYPE_PointerTo_ns2__getRecord:
		return soap_out_PointerTo_ns2__getRecord(soap, tag, id, (_ns2__getRecord *const*)ptr, "ns2:getRecord");
	case SOAP_TYPE_PointerTo_ns2__getRecordsResponse:
		return soap_out_PointerTo_ns2__getRecordsResponse(soap, tag, id, (_ns2__getRecordsResponse *const*)ptr, "ns2:getRecordsResponse");
	case SOAP_TYPE_PointerTo_ns2__getRecords:
		return soap_out_PointerTo_ns2__getRecords(soap, tag, id, (_ns2__getRecords *const*)ptr, "ns2:getRecords");
	case SOAP_TYPE_PointerTo_ns2__getApplicationDatasResponse:
		return soap_out_PointerTo_ns2__getApplicationDatasResponse(soap, tag, id, (_ns2__getApplicationDatasResponse *const*)ptr, "ns2:getApplicationDatasResponse");
	case SOAP_TYPE_PointerTo_ns2__getApplicationDatas:
		return soap_out_PointerTo_ns2__getApplicationDatas(soap, tag, id, (_ns2__getApplicationDatas *const*)ptr, "ns2:getApplicationDatas");
	case SOAP_TYPE_PointerTo_ns2__getApplicationsResponse:
		return soap_out_PointerTo_ns2__getApplicationsResponse(soap, tag, id, (_ns2__getApplicationsResponse *const*)ptr, "ns2:getApplicationsResponse");
	case SOAP_TYPE_PointerTo_ns2__getApplications:
		return soap_out_PointerTo_ns2__getApplications(soap, tag, id, (_ns2__getApplications *const*)ptr, "ns2:getApplications");
	case SOAP_TYPE_PointerTo_ns1__setRobotPosResponse:
		return soap_out_PointerTo_ns1__setRobotPosResponse(soap, tag, id, (_ns1__setRobotPosResponse *const*)ptr, "ns1:setRobotPosResponse");
	case SOAP_TYPE_PointerTo_ns1__setRobotJointPos:
		return soap_out_PointerTo_ns1__setRobotJointPos(soap, tag, id, (_ns1__setRobotJointPos *const*)ptr, "ns1:setRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse:
		return soap_out_PointerTo_ns1__getRobotJntCartPosResponse(soap, tag, id, (_ns1__getRobotJntCartPosResponse *const*)ptr, "ns1:getRobotJntCartPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos:
		return soap_out_PointerTo_ns1__getRobotJntCartPos(soap, tag, id, (_ns1__getRobotJntCartPos *const*)ptr, "ns1:getRobotJntCartPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse:
		return soap_out_PointerTo_ns1__getRobotJointPosResponse(soap, tag, id, (_ns1__getRobotJointPosResponse *const*)ptr, "ns1:getRobotJointPosResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPos:
		return soap_out_PointerTo_ns1__getRobotJointPos(soap, tag, id, (_ns1__getRobotJointPos *const*)ptr, "ns1:getRobotJointPos");
	case SOAP_TYPE_PointerTo_ns1__getRobotsResponse:
		return soap_out_PointerTo_ns1__getRobotsResponse(soap, tag, id, (_ns1__getRobotsResponse *const*)ptr, "ns1:getRobotsResponse");
	case SOAP_TYPE_PointerTo_ns1__getRobots:
		return soap_out_PointerTo_ns1__getRobots(soap, tag, id, (_ns1__getRobots *const*)ptr, "ns1:getRobots");
	case SOAP_TYPE_PointerTo_ns1__logoutResponse:
		return soap_out_PointerTo_ns1__logoutResponse(soap, tag, id, (_ns1__logoutResponse *const*)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTo_ns1__logout:
		return soap_out_PointerTo_ns1__logout(soap, tag, id, (_ns1__logout *const*)ptr, "ns1:logout");
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		return soap_out_PointerTo_ns1__loginResponse(soap, tag, id, (_ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTo_ns1__login:
		return soap_out_PointerTo_ns1__login(soap, tag, id, (_ns1__login *const*)ptr, "ns1:login");
	case SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse:
		return soap_out_PointerTo_ns1__getCS8VersionsResponse(soap, tag, id, (_ns1__getCS8VersionsResponse *const*)ptr, "ns1:getCS8VersionsResponse");
	case SOAP_TYPE_PointerTo_ns1__getCS8Versions:
		return soap_out_PointerTo_ns1__getCS8Versions(soap, tag, id, (_ns1__getCS8Versions *const*)ptr, "ns1:getCS8Versions");
	case SOAP_TYPE_PointerTo_ns1__pingResponse:
		return soap_out_PointerTo_ns1__pingResponse(soap, tag, id, (_ns1__pingResponse *const*)ptr, "ns1:pingResponse");
	case SOAP_TYPE_PointerTo_ns1__ping:
		return soap_out_PointerTo_ns1__ping(soap, tag, id, (_ns1__ping *const*)ptr, "ns1:ping");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse:
		return soap_out_PointerTo_ns1__getSoapServerVersionResponse(soap, tag, id, (_ns1__getSoapServerVersionResponse *const*)ptr, "ns1:getSoapServerVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersion:
		return soap_out_PointerTo_ns1__getSoapServerVersion(soap, tag, id, (_ns1__getSoapServerVersion *const*)ptr, "ns1:getSoapServerVersion");
	case SOAP_TYPE_PointerTons1__ServerException:
		return soap_out_PointerTons1__ServerException(soap, tag, id, (ns1__ServerException *const*)ptr, "ns1:ServerException");
	case SOAP_TYPE_PointerTons1__SessionId:
		return soap_out_PointerTons1__SessionId(soap, tag, id, (int *const*)ptr, "ns1:SessionId");
	case SOAP_TYPE_PointerTons6__AllRobotsPos:
		return soap_out_PointerTons6__AllRobotsPos(soap, tag, id, (ns6__AllRobotsPos *const*)ptr, "ns6:AllRobotsPos");
	case SOAP_TYPE_PointerTons6__MotionDesc:
		return soap_out_PointerTons6__MotionDesc(soap, tag, id, (ns6__MotionDesc *const*)ptr, "ns6:MotionDesc");
	case SOAP_TYPE_PointerTons6__Config:
		return soap_out_PointerTons6__Config(soap, tag, id, (ns6__Config *const*)ptr, "ns6:Config");
	case SOAP_TYPE_PointerTons6__Frame:
		return soap_out_PointerTons6__Frame(soap, tag, id, (ns6__Frame *const*)ptr, "ns6:Frame");
	case SOAP_TYPE_PointerTons6__VrbxConfig:
		return soap_out_PointerTons6__VrbxConfig(soap, tag, id, (ns6__VrbxConfig *const*)ptr, "ns6:VrbxConfig");
	case SOAP_TYPE_PointerTons6__ScaraConfig:
		return soap_out_PointerTons6__ScaraConfig(soap, tag, id, (ns6__ScaraConfig *const*)ptr, "ns6:ScaraConfig");
	case SOAP_TYPE_PointerTons6__AnthroConfig:
		return soap_out_PointerTons6__AnthroConfig(soap, tag, id, (ns6__AnthroConfig *const*)ptr, "ns6:AnthroConfig");
	case SOAP_TYPE_PointerTons6__RobotPos:
		return soap_out_PointerTons6__RobotPos(soap, tag, id, (ns6__RobotPos *const*)ptr, "ns6:RobotPos");
	case SOAP_TYPE_PointerTons2__JointRange:
		return soap_out_PointerTons2__JointRange(soap, tag, id, (ns2__JointRange *const*)ptr, "ns2:JointRange");
	case SOAP_TYPE_PointerTons2__Records:
		return soap_out_PointerTons2__Records(soap, tag, id, (ns2__Records *const*)ptr, "ns2:Records");
	case SOAP_TYPE_PointerTons2__VALApplications:
		return soap_out_PointerTons2__VALApplications(soap, tag, id, (ns2__VALApplications *const*)ptr, "ns2:VALApplications");
	case SOAP_TYPE_PointerTons3__Include:
		return soap_out_PointerTons3__Include(soap, tag, id, (ns3__Include *const*)ptr, "ns3:Include");
	case SOAP_TYPE_PointerTons2__VALApplication:
		return soap_out_PointerTons2__VALApplication(soap, tag, id, (ns2__VALApplication *const*)ptr, "ns2:VALApplication");
	case SOAP_TYPE_PointerTons1__Parameters:
		return soap_out_PointerTons1__Parameters(soap, tag, id, (ns1__Parameters *const*)ptr, "ns1:Parameters");
	case SOAP_TYPE_PointerTons1__CartesianPos:
		return soap_out_PointerTons1__CartesianPos(soap, tag, id, (ns1__CartesianPos *const*)ptr, "ns1:CartesianPos");
	case SOAP_TYPE_PointerTons1__JointPos:
		return soap_out_PointerTons1__JointPos(soap, tag, id, (ns1__JointPos *const*)ptr, "ns1:JointPos");
	case SOAP_TYPE_PointerTons1__Robots:
		return soap_out_PointerTons1__Robots(soap, tag, id, (ns1__Robots *const*)ptr, "ns1:Robots");
	case SOAP_TYPE_PointerTons1__Versions:
		return soap_out_PointerTons1__Versions(soap, tag, id, (ns1__Versions *const*)ptr, "ns1:Versions");
	case SOAP_TYPE_PointerTons1__SoapServerVersion:
		return soap_out_PointerTons1__SoapServerVersion(soap, tag, id, (ns1__SoapServerVersion *const*)ptr, "ns1:SoapServerVersion");
	case SOAP_TYPE_PointerTons1__Parameter:
		return soap_out_PointerTons1__Parameter(soap, tag, id, (ns1__Parameter *const*)ptr, "ns1:Parameter");
	case SOAP_TYPE_PointerTons1__Robot:
		return soap_out_PointerTons1__Robot(soap, tag, id, (ns1__Robot *const*)ptr, "ns1:Robot");
	case SOAP_TYPE_PointerTons1__Version:
		return soap_out_PointerTons1__Version(soap, tag, id, (ns1__Version *const*)ptr, "ns1:Version");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns6__setPowerResponse:
		((_ns6__setPowerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__setPower:
		((_ns6__setPower *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__MotionAndRobotsPos:
		((_ns6__MotionAndRobotsPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__schedulerRefresh:
		((_ns6__schedulerRefresh *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__setSchedulingModeResponse:
		((_ns6__setSchedulingModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__setSchedulingMode:
		((_ns6__setSchedulingMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__restartMotion:
		((_ns6__restartMotion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__stopMotion:
		((_ns6__stopMotion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__motionResponse:
		((_ns6__motionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__resetMotion:
		((_ns6__resetMotion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__moveC:
		((_ns6__moveC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__moveL:
		((_ns6__moveL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__moveJC:
		((_ns6__moveJC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__moveResponse:
		((_ns6__moveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__moveJJ:
		((_ns6__moveJJ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__reverseKinResponse:
		((_ns6__reverseKinResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__reverseKin:
		((_ns6__reverseKin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__forwardKinResponse:
		((_ns6__forwardKinResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns6__forwardKin:
		((_ns6__forwardKin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__AllRobotsPos:
		((ns6__AllRobotsPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__RobotPos:
		((ns6__RobotPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__MotionDesc:
		((ns6__MotionDesc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Config:
		((ns6__Config *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__VrbxConfig:
		((ns6__VrbxConfig *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ScaraConfig:
		((ns6__ScaraConfig *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__AnthroConfig:
		((ns6__AnthroConfig *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Frame:
		((ns6__Frame *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Records:
		((ns6__Records *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__VALApplications:
		((ns6__VALApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Robots:
		((ns6__Robots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Versions:
		((ns6__Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__JointPos:
		((ns6__JointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__AllRobotsPos:
		((ns5__AllRobotsPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Records:
		((ns5__Records *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__VALApplications:
		((ns5__VALApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Robots:
		((ns5__Robots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Versions:
		((ns5__Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__JointPos:
		((ns5__JointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__hexBinary:
		((ns4__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__base64Binary:
		((ns4__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__Include:
		((ns3__Include *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getJointRangeResponse:
		((_ns2__getJointRangeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getJointRange:
		((_ns2__getJointRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecordResponse:
		((_ns2__getRecordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecord:
		((_ns2__getRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecordsResponse:
		((_ns2__getRecordsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getRecords:
		((_ns2__getRecords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		((_ns2__getApplicationDatasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplicationDatas:
		((_ns2__getApplicationDatas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplicationsResponse:
		((_ns2__getApplicationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__getApplications:
		((_ns2__getApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__JointRange:
		((ns2__JointRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Records:
		((ns2__Records *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Data:
		((ns2__Data *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VALApplications:
		((ns2__VALApplications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VALApplication:
		((ns2__VALApplication *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		((_ns1__getCS8CompatibilityResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8Compatibility:
		((_ns1__getCS8Compatibility *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		((_ns1__getControllerParametersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getControllerParameters:
		((_ns1__getControllerParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findServerResponse:
		((_ns1__findServerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__findServer:
		((_ns1__findServer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__setRobotPosResponse:
		((_ns1__setRobotPosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__setRobotJointPos:
		((_ns1__setRobotJointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		((_ns1__getRobotJntCartPosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		((_ns1__getRobotJntCartPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		((_ns1__getRobotJointPosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotJointPos:
		((_ns1__getRobotJointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobotsResponse:
		((_ns1__getRobotsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getRobots:
		((_ns1__getRobots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__logoutResponse:
		((_ns1__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__logout:
		((_ns1__logout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__loginResponse:
		((_ns1__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__login:
		((_ns1__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		((_ns1__getCS8VersionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getCS8Versions:
		((_ns1__getCS8Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__pingResponse:
		((_ns1__pingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ping:
		((_ns1__ping *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		((_ns1__getSoapServerVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getSoapServerVersion:
		((_ns1__getSoapServerVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Parameters:
		((ns1__Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Parameter:
		((ns1__Parameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Robots:
		((ns1__Robots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoapServerVersion:
		((ns1__SoapServerVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Versions:
		((ns1__Versions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Version:
		((ns1__Version *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Robot:
		((ns1__Robot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CartesianPos:
		((ns1__CartesianPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__JointPos:
		((ns1__JointPos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ServerException:
		((ns1__ServerException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns6__setPower:
		soap_serialize___ns6__setPower(soap, (const struct __ns6__setPower *)ptr);
		break;
	case SOAP_TYPE___ns6__schedulerRefresh:
		soap_serialize___ns6__schedulerRefresh(soap, (const struct __ns6__schedulerRefresh *)ptr);
		break;
	case SOAP_TYPE___ns6__setSchedulingMode:
		soap_serialize___ns6__setSchedulingMode(soap, (const struct __ns6__setSchedulingMode *)ptr);
		break;
	case SOAP_TYPE___ns6__restartMotion:
		soap_serialize___ns6__restartMotion(soap, (const struct __ns6__restartMotion *)ptr);
		break;
	case SOAP_TYPE___ns6__stopMotion:
		soap_serialize___ns6__stopMotion(soap, (const struct __ns6__stopMotion *)ptr);
		break;
	case SOAP_TYPE___ns6__resetMotion:
		soap_serialize___ns6__resetMotion(soap, (const struct __ns6__resetMotion *)ptr);
		break;
	case SOAP_TYPE___ns6__moveC:
		soap_serialize___ns6__moveC(soap, (const struct __ns6__moveC *)ptr);
		break;
	case SOAP_TYPE___ns6__moveL:
		soap_serialize___ns6__moveL(soap, (const struct __ns6__moveL *)ptr);
		break;
	case SOAP_TYPE___ns6__moveJC:
		soap_serialize___ns6__moveJC(soap, (const struct __ns6__moveJC *)ptr);
		break;
	case SOAP_TYPE___ns6__moveJJ:
		soap_serialize___ns6__moveJJ(soap, (const struct __ns6__moveJJ *)ptr);
		break;
	case SOAP_TYPE___ns6__reverseKin:
		soap_serialize___ns6__reverseKin(soap, (const struct __ns6__reverseKin *)ptr);
		break;
	case SOAP_TYPE___ns6__forwardKin:
		soap_serialize___ns6__forwardKin(soap, (const struct __ns6__forwardKin *)ptr);
		break;
	case SOAP_TYPE___ns2__getJointRange:
		soap_serialize___ns2__getJointRange(soap, (const struct __ns2__getJointRange *)ptr);
		break;
	case SOAP_TYPE___ns2__getRecord:
		soap_serialize___ns2__getRecord(soap, (const struct __ns2__getRecord *)ptr);
		break;
	case SOAP_TYPE___ns2__getRecords:
		soap_serialize___ns2__getRecords(soap, (const struct __ns2__getRecords *)ptr);
		break;
	case SOAP_TYPE___ns2__getApplicationDatas:
		soap_serialize___ns2__getApplicationDatas(soap, (const struct __ns2__getApplicationDatas *)ptr);
		break;
	case SOAP_TYPE___ns2__getApplications:
		soap_serialize___ns2__getApplications(soap, (const struct __ns2__getApplications *)ptr);
		break;
	case SOAP_TYPE___ns1__setRobotJointPos:
		soap_serialize___ns1__setRobotJointPos(soap, (const struct __ns1__setRobotJointPos *)ptr);
		break;
	case SOAP_TYPE___ns1__getRobotJntCartPos:
		soap_serialize___ns1__getRobotJntCartPos(soap, (const struct __ns1__getRobotJntCartPos *)ptr);
		break;
	case SOAP_TYPE___ns1__getRobotJointPos:
		soap_serialize___ns1__getRobotJointPos(soap, (const struct __ns1__getRobotJointPos *)ptr);
		break;
	case SOAP_TYPE___ns1__getRobots:
		soap_serialize___ns1__getRobots(soap, (const struct __ns1__getRobots *)ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		soap_serialize___ns1__logout(soap, (const struct __ns1__logout *)ptr);
		break;
	case SOAP_TYPE___ns1__login:
		soap_serialize___ns1__login(soap, (const struct __ns1__login *)ptr);
		break;
	case SOAP_TYPE___ns1__getCS8Versions:
		soap_serialize___ns1__getCS8Versions(soap, (const struct __ns1__getCS8Versions *)ptr);
		break;
	case SOAP_TYPE___ns1__ping:
		soap_serialize___ns1__ping(soap, (const struct __ns1__ping *)ptr);
		break;
	case SOAP_TYPE___ns1__getSoapServerVersion:
		soap_serialize___ns1__getSoapServerVersion(soap, (const struct __ns1__getSoapServerVersion *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__setPowerResponse:
		soap_serialize_PointerTo_ns6__setPowerResponse(soap, (_ns6__setPowerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__setPower:
		soap_serialize_PointerTo_ns6__setPower(soap, (_ns6__setPower *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__MotionAndRobotsPos:
		soap_serialize_PointerTo_ns6__MotionAndRobotsPos(soap, (_ns6__MotionAndRobotsPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__schedulerRefresh:
		soap_serialize_PointerTo_ns6__schedulerRefresh(soap, (_ns6__schedulerRefresh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__setSchedulingModeResponse:
		soap_serialize_PointerTo_ns6__setSchedulingModeResponse(soap, (_ns6__setSchedulingModeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__setSchedulingMode:
		soap_serialize_PointerTo_ns6__setSchedulingMode(soap, (_ns6__setSchedulingMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__restartMotion:
		soap_serialize_PointerTo_ns6__restartMotion(soap, (_ns6__restartMotion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__stopMotion:
		soap_serialize_PointerTo_ns6__stopMotion(soap, (_ns6__stopMotion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__motionResponse:
		soap_serialize_PointerTo_ns6__motionResponse(soap, (_ns6__motionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__resetMotion:
		soap_serialize_PointerTo_ns6__resetMotion(soap, (_ns6__resetMotion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__moveC:
		soap_serialize_PointerTo_ns6__moveC(soap, (_ns6__moveC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__moveL:
		soap_serialize_PointerTo_ns6__moveL(soap, (_ns6__moveL *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__moveJC:
		soap_serialize_PointerTo_ns6__moveJC(soap, (_ns6__moveJC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__moveResponse:
		soap_serialize_PointerTo_ns6__moveResponse(soap, (_ns6__moveResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__moveJJ:
		soap_serialize_PointerTo_ns6__moveJJ(soap, (_ns6__moveJJ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__reverseKinResponse:
		soap_serialize_PointerTo_ns6__reverseKinResponse(soap, (_ns6__reverseKinResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__reverseKin:
		soap_serialize_PointerTo_ns6__reverseKin(soap, (_ns6__reverseKin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__forwardKinResponse:
		soap_serialize_PointerTo_ns6__forwardKinResponse(soap, (_ns6__forwardKinResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns6__forwardKin:
		soap_serialize_PointerTo_ns6__forwardKin(soap, (_ns6__forwardKin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getJointRangeResponse:
		soap_serialize_PointerTo_ns2__getJointRangeResponse(soap, (_ns2__getJointRangeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getJointRange:
		soap_serialize_PointerTo_ns2__getJointRange(soap, (_ns2__getJointRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getRecordResponse:
		soap_serialize_PointerTo_ns2__getRecordResponse(soap, (_ns2__getRecordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getRecord:
		soap_serialize_PointerTo_ns2__getRecord(soap, (_ns2__getRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getRecordsResponse:
		soap_serialize_PointerTo_ns2__getRecordsResponse(soap, (_ns2__getRecordsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getRecords:
		soap_serialize_PointerTo_ns2__getRecords(soap, (_ns2__getRecords *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getApplicationDatasResponse:
		soap_serialize_PointerTo_ns2__getApplicationDatasResponse(soap, (_ns2__getApplicationDatasResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getApplicationDatas:
		soap_serialize_PointerTo_ns2__getApplicationDatas(soap, (_ns2__getApplicationDatas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getApplicationsResponse:
		soap_serialize_PointerTo_ns2__getApplicationsResponse(soap, (_ns2__getApplicationsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__getApplications:
		soap_serialize_PointerTo_ns2__getApplications(soap, (_ns2__getApplications *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRobotPosResponse:
		soap_serialize_PointerTo_ns1__setRobotPosResponse(soap, (_ns1__setRobotPosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__setRobotJointPos:
		soap_serialize_PointerTo_ns1__setRobotJointPos(soap, (_ns1__setRobotJointPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse:
		soap_serialize_PointerTo_ns1__getRobotJntCartPosResponse(soap, (_ns1__getRobotJntCartPosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos:
		soap_serialize_PointerTo_ns1__getRobotJntCartPos(soap, (_ns1__getRobotJntCartPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse:
		soap_serialize_PointerTo_ns1__getRobotJointPosResponse(soap, (_ns1__getRobotJointPosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotJointPos:
		soap_serialize_PointerTo_ns1__getRobotJointPos(soap, (_ns1__getRobotJointPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobotsResponse:
		soap_serialize_PointerTo_ns1__getRobotsResponse(soap, (_ns1__getRobotsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getRobots:
		soap_serialize_PointerTo_ns1__getRobots(soap, (_ns1__getRobots *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__logoutResponse:
		soap_serialize_PointerTo_ns1__logoutResponse(soap, (_ns1__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__logout:
		soap_serialize_PointerTo_ns1__logout(soap, (_ns1__logout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__loginResponse:
		soap_serialize_PointerTo_ns1__loginResponse(soap, (_ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__login:
		soap_serialize_PointerTo_ns1__login(soap, (_ns1__login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse:
		soap_serialize_PointerTo_ns1__getCS8VersionsResponse(soap, (_ns1__getCS8VersionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getCS8Versions:
		soap_serialize_PointerTo_ns1__getCS8Versions(soap, (_ns1__getCS8Versions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__pingResponse:
		soap_serialize_PointerTo_ns1__pingResponse(soap, (_ns1__pingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ping:
		soap_serialize_PointerTo_ns1__ping(soap, (_ns1__ping *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse:
		soap_serialize_PointerTo_ns1__getSoapServerVersionResponse(soap, (_ns1__getSoapServerVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getSoapServerVersion:
		soap_serialize_PointerTo_ns1__getSoapServerVersion(soap, (_ns1__getSoapServerVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ServerException:
		soap_serialize_PointerTons1__ServerException(soap, (ns1__ServerException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SessionId:
		soap_serialize_PointerTons1__SessionId(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__AllRobotsPos:
		soap_serialize_PointerTons6__AllRobotsPos(soap, (ns6__AllRobotsPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__MotionDesc:
		soap_serialize_PointerTons6__MotionDesc(soap, (ns6__MotionDesc *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__Config:
		soap_serialize_PointerTons6__Config(soap, (ns6__Config *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__Frame:
		soap_serialize_PointerTons6__Frame(soap, (ns6__Frame *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__VrbxConfig:
		soap_serialize_PointerTons6__VrbxConfig(soap, (ns6__VrbxConfig *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ScaraConfig:
		soap_serialize_PointerTons6__ScaraConfig(soap, (ns6__ScaraConfig *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__AnthroConfig:
		soap_serialize_PointerTons6__AnthroConfig(soap, (ns6__AnthroConfig *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__RobotPos:
		soap_serialize_PointerTons6__RobotPos(soap, (ns6__RobotPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__JointRange:
		soap_serialize_PointerTons2__JointRange(soap, (ns2__JointRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Records:
		soap_serialize_PointerTons2__Records(soap, (ns2__Records *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VALApplications:
		soap_serialize_PointerTons2__VALApplications(soap, (ns2__VALApplications *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__Include:
		soap_serialize_PointerTons3__Include(soap, (ns3__Include *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VALApplication:
		soap_serialize_PointerTons2__VALApplication(soap, (ns2__VALApplication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Parameters:
		soap_serialize_PointerTons1__Parameters(soap, (ns1__Parameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CartesianPos:
		soap_serialize_PointerTons1__CartesianPos(soap, (ns1__CartesianPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__JointPos:
		soap_serialize_PointerTons1__JointPos(soap, (ns1__JointPos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Robots:
		soap_serialize_PointerTons1__Robots(soap, (ns1__Robots *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Versions:
		soap_serialize_PointerTons1__Versions(soap, (ns1__Versions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoapServerVersion:
		soap_serialize_PointerTons1__SoapServerVersion(soap, (ns1__SoapServerVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Parameter:
		soap_serialize_PointerTons1__Parameter(soap, (ns1__Parameter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Robot:
		soap_serialize_PointerTons1__Robot(soap, (ns1__Robot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Version:
		soap_serialize_PointerTons1__Version(soap, (ns1__Version *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ServerException:
		return (void*)soap_instantiate_ns1__ServerException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__JointPos:
		return (void*)soap_instantiate_ns1__JointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CartesianPos:
		return (void*)soap_instantiate_ns1__CartesianPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Robot:
		return (void*)soap_instantiate_ns1__Robot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Version:
		return (void*)soap_instantiate_ns1__Version(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Versions:
		return (void*)soap_instantiate_ns1__Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoapServerVersion:
		return (void*)soap_instantiate_ns1__SoapServerVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Robots:
		return (void*)soap_instantiate_ns1__Robots(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Parameter:
		return (void*)soap_instantiate_ns1__Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Parameters:
		return (void*)soap_instantiate_ns1__Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSoapServerVersion:
		return (void*)soap_instantiate__ns1__getSoapServerVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		return (void*)soap_instantiate__ns1__getSoapServerVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ping:
		return (void*)soap_instantiate__ns1__ping(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__pingResponse:
		return (void*)soap_instantiate__ns1__pingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8Versions:
		return (void*)soap_instantiate__ns1__getCS8Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		return (void*)soap_instantiate__ns1__getCS8VersionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__login:
		return (void*)soap_instantiate__ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__loginResponse:
		return (void*)soap_instantiate__ns1__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__logout:
		return (void*)soap_instantiate__ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__logoutResponse:
		return (void*)soap_instantiate__ns1__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobots:
		return (void*)soap_instantiate__ns1__getRobots(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotsResponse:
		return (void*)soap_instantiate__ns1__getRobotsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJointPos:
		return (void*)soap_instantiate__ns1__getRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		return (void*)soap_instantiate__ns1__getRobotJointPosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		return (void*)soap_instantiate__ns1__getRobotJntCartPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		return (void*)soap_instantiate__ns1__getRobotJntCartPosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__setRobotJointPos:
		return (void*)soap_instantiate__ns1__setRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__setRobotPosResponse:
		return (void*)soap_instantiate__ns1__setRobotPosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findServer:
		return (void*)soap_instantiate__ns1__findServer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__findServerResponse:
		return (void*)soap_instantiate__ns1__findServerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getControllerParameters:
		return (void*)soap_instantiate__ns1__getControllerParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		return (void*)soap_instantiate__ns1__getControllerParametersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8Compatibility:
		return (void*)soap_instantiate__ns1__getCS8Compatibility(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		return (void*)soap_instantiate__ns1__getCS8CompatibilityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VALApplication:
		return (void*)soap_instantiate_ns2__VALApplication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VALApplications:
		return (void*)soap_instantiate_ns2__VALApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Data:
		return (void*)soap_instantiate_ns2__Data(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Records:
		return (void*)soap_instantiate_ns2__Records(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__JointRange:
		return (void*)soap_instantiate_ns2__JointRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplications:
		return (void*)soap_instantiate__ns2__getApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplicationsResponse:
		return (void*)soap_instantiate__ns2__getApplicationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplicationDatas:
		return (void*)soap_instantiate__ns2__getApplicationDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		return (void*)soap_instantiate__ns2__getApplicationDatasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecords:
		return (void*)soap_instantiate__ns2__getRecords(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecordsResponse:
		return (void*)soap_instantiate__ns2__getRecordsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecord:
		return (void*)soap_instantiate__ns2__getRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getRecordResponse:
		return (void*)soap_instantiate__ns2__getRecordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getJointRange:
		return (void*)soap_instantiate__ns2__getJointRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__getJointRangeResponse:
		return (void*)soap_instantiate__ns2__getJointRangeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__Include:
		return (void*)soap_instantiate_ns3__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__JointPos:
		return (void*)soap_instantiate_ns5__JointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Versions:
		return (void*)soap_instantiate_ns5__Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Robots:
		return (void*)soap_instantiate_ns5__Robots(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__VALApplications:
		return (void*)soap_instantiate_ns5__VALApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Records:
		return (void*)soap_instantiate_ns5__Records(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__AllRobotsPos:
		return (void*)soap_instantiate_ns5__AllRobotsPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__JointPos:
		return (void*)soap_instantiate_ns6__JointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Versions:
		return (void*)soap_instantiate_ns6__Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Robots:
		return (void*)soap_instantiate_ns6__Robots(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__VALApplications:
		return (void*)soap_instantiate_ns6__VALApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Records:
		return (void*)soap_instantiate_ns6__Records(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Frame:
		return (void*)soap_instantiate_ns6__Frame(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AnthroConfig:
		return (void*)soap_instantiate_ns6__AnthroConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ScaraConfig:
		return (void*)soap_instantiate_ns6__ScaraConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__VrbxConfig:
		return (void*)soap_instantiate_ns6__VrbxConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Config:
		return (void*)soap_instantiate_ns6__Config(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__MotionDesc:
		return (void*)soap_instantiate_ns6__MotionDesc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RobotPos:
		return (void*)soap_instantiate_ns6__RobotPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AllRobotsPos:
		return (void*)soap_instantiate_ns6__AllRobotsPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__forwardKin:
		return (void*)soap_instantiate__ns6__forwardKin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__forwardKinResponse:
		return (void*)soap_instantiate__ns6__forwardKinResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__reverseKin:
		return (void*)soap_instantiate__ns6__reverseKin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__reverseKinResponse:
		return (void*)soap_instantiate__ns6__reverseKinResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__moveJJ:
		return (void*)soap_instantiate__ns6__moveJJ(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__moveResponse:
		return (void*)soap_instantiate__ns6__moveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__moveJC:
		return (void*)soap_instantiate__ns6__moveJC(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__moveL:
		return (void*)soap_instantiate__ns6__moveL(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__moveC:
		return (void*)soap_instantiate__ns6__moveC(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__resetMotion:
		return (void*)soap_instantiate__ns6__resetMotion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__motionResponse:
		return (void*)soap_instantiate__ns6__motionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__stopMotion:
		return (void*)soap_instantiate__ns6__stopMotion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__restartMotion:
		return (void*)soap_instantiate__ns6__restartMotion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__setSchedulingMode:
		return (void*)soap_instantiate__ns6__setSchedulingMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__setSchedulingModeResponse:
		return (void*)soap_instantiate__ns6__setSchedulingModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__schedulerRefresh:
		return (void*)soap_instantiate__ns6__schedulerRefresh(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__MotionAndRobotsPos:
		return (void*)soap_instantiate__ns6__MotionAndRobotsPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__setPower:
		return (void*)soap_instantiate__ns6__setPower(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__setPowerResponse:
		return (void*)soap_instantiate__ns6__setPowerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__base64Binary:
		return (void*)soap_instantiate_ns4__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__hexBinary:
		return (void*)soap_instantiate_ns4__hexBinary(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getSoapServerVersion:
		return (void*)soap_instantiate___ns1__getSoapServerVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ping:
		return (void*)soap_instantiate___ns1__ping(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCS8Versions:
		return (void*)soap_instantiate___ns1__getCS8Versions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__login:
		return (void*)soap_instantiate___ns1__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logout:
		return (void*)soap_instantiate___ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRobots:
		return (void*)soap_instantiate___ns1__getRobots(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRobotJointPos:
		return (void*)soap_instantiate___ns1__getRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRobotJntCartPos:
		return (void*)soap_instantiate___ns1__getRobotJntCartPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setRobotJointPos:
		return (void*)soap_instantiate___ns1__setRobotJointPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__getApplications:
		return (void*)soap_instantiate___ns2__getApplications(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__getApplicationDatas:
		return (void*)soap_instantiate___ns2__getApplicationDatas(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__getRecords:
		return (void*)soap_instantiate___ns2__getRecords(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__getRecord:
		return (void*)soap_instantiate___ns2__getRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__getJointRange:
		return (void*)soap_instantiate___ns2__getJointRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__forwardKin:
		return (void*)soap_instantiate___ns6__forwardKin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__reverseKin:
		return (void*)soap_instantiate___ns6__reverseKin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__moveJJ:
		return (void*)soap_instantiate___ns6__moveJJ(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__moveJC:
		return (void*)soap_instantiate___ns6__moveJC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__moveL:
		return (void*)soap_instantiate___ns6__moveL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__moveC:
		return (void*)soap_instantiate___ns6__moveC(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__resetMotion:
		return (void*)soap_instantiate___ns6__resetMotion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__stopMotion:
		return (void*)soap_instantiate___ns6__stopMotion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__restartMotion:
		return (void*)soap_instantiate___ns6__restartMotion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__setSchedulingMode:
		return (void*)soap_instantiate___ns6__setSchedulingMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__schedulerRefresh:
		return (void*)soap_instantiate___ns6__schedulerRefresh(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns6__setPower:
		return (void*)soap_instantiate___ns6__setPower(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__RobotPos:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons6__RobotPos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__VALApplication(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Robot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Version(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		return (void*)soap_instantiate_std__vectorTemplateOfdouble(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			delete (xsd__base64Binary*)p->ptr;
		else
			delete[] (xsd__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			delete (xsd__hexBinary*)p->ptr;
		else
			delete[] (xsd__hexBinary*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ServerException:
		if (p->size < 0)
			delete (ns1__ServerException*)p->ptr;
		else
			delete[] (ns1__ServerException*)p->ptr;
		break;
	case SOAP_TYPE_ns1__JointPos:
		if (p->size < 0)
			delete (ns1__JointPos*)p->ptr;
		else
			delete[] (ns1__JointPos*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CartesianPos:
		if (p->size < 0)
			delete (ns1__CartesianPos*)p->ptr;
		else
			delete[] (ns1__CartesianPos*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Robot:
		if (p->size < 0)
			delete (ns1__Robot*)p->ptr;
		else
			delete[] (ns1__Robot*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Version:
		if (p->size < 0)
			delete (ns1__Version*)p->ptr;
		else
			delete[] (ns1__Version*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Versions:
		if (p->size < 0)
			delete (ns1__Versions*)p->ptr;
		else
			delete[] (ns1__Versions*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SoapServerVersion:
		if (p->size < 0)
			delete (ns1__SoapServerVersion*)p->ptr;
		else
			delete[] (ns1__SoapServerVersion*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Robots:
		if (p->size < 0)
			delete (ns1__Robots*)p->ptr;
		else
			delete[] (ns1__Robots*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Parameter:
		if (p->size < 0)
			delete (ns1__Parameter*)p->ptr;
		else
			delete[] (ns1__Parameter*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Parameters:
		if (p->size < 0)
			delete (ns1__Parameters*)p->ptr;
		else
			delete[] (ns1__Parameters*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getSoapServerVersion:
		if (p->size < 0)
			delete (_ns1__getSoapServerVersion*)p->ptr;
		else
			delete[] (_ns1__getSoapServerVersion*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getSoapServerVersionResponse:
		if (p->size < 0)
			delete (_ns1__getSoapServerVersionResponse*)p->ptr;
		else
			delete[] (_ns1__getSoapServerVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ping:
		if (p->size < 0)
			delete (_ns1__ping*)p->ptr;
		else
			delete[] (_ns1__ping*)p->ptr;
		break;
	case SOAP_TYPE__ns1__pingResponse:
		if (p->size < 0)
			delete (_ns1__pingResponse*)p->ptr;
		else
			delete[] (_ns1__pingResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getCS8Versions:
		if (p->size < 0)
			delete (_ns1__getCS8Versions*)p->ptr;
		else
			delete[] (_ns1__getCS8Versions*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getCS8VersionsResponse:
		if (p->size < 0)
			delete (_ns1__getCS8VersionsResponse*)p->ptr;
		else
			delete[] (_ns1__getCS8VersionsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__login:
		if (p->size < 0)
			delete (_ns1__login*)p->ptr;
		else
			delete[] (_ns1__login*)p->ptr;
		break;
	case SOAP_TYPE__ns1__loginResponse:
		if (p->size < 0)
			delete (_ns1__loginResponse*)p->ptr;
		else
			delete[] (_ns1__loginResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__logout:
		if (p->size < 0)
			delete (_ns1__logout*)p->ptr;
		else
			delete[] (_ns1__logout*)p->ptr;
		break;
	case SOAP_TYPE__ns1__logoutResponse:
		if (p->size < 0)
			delete (_ns1__logoutResponse*)p->ptr;
		else
			delete[] (_ns1__logoutResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getRobots:
		if (p->size < 0)
			delete (_ns1__getRobots*)p->ptr;
		else
			delete[] (_ns1__getRobots*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getRobotsResponse:
		if (p->size < 0)
			delete (_ns1__getRobotsResponse*)p->ptr;
		else
			delete[] (_ns1__getRobotsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getRobotJointPos:
		if (p->size < 0)
			delete (_ns1__getRobotJointPos*)p->ptr;
		else
			delete[] (_ns1__getRobotJointPos*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getRobotJointPosResponse:
		if (p->size < 0)
			delete (_ns1__getRobotJointPosResponse*)p->ptr;
		else
			delete[] (_ns1__getRobotJointPosResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPos:
		if (p->size < 0)
			delete (_ns1__getRobotJntCartPos*)p->ptr;
		else
			delete[] (_ns1__getRobotJntCartPos*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getRobotJntCartPosResponse:
		if (p->size < 0)
			delete (_ns1__getRobotJntCartPosResponse*)p->ptr;
		else
			delete[] (_ns1__getRobotJntCartPosResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__setRobotJointPos:
		if (p->size < 0)
			delete (_ns1__setRobotJointPos*)p->ptr;
		else
			delete[] (_ns1__setRobotJointPos*)p->ptr;
		break;
	case SOAP_TYPE__ns1__setRobotPosResponse:
		if (p->size < 0)
			delete (_ns1__setRobotPosResponse*)p->ptr;
		else
			delete[] (_ns1__setRobotPosResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findServer:
		if (p->size < 0)
			delete (_ns1__findServer*)p->ptr;
		else
			delete[] (_ns1__findServer*)p->ptr;
		break;
	case SOAP_TYPE__ns1__findServerResponse:
		if (p->size < 0)
			delete (_ns1__findServerResponse*)p->ptr;
		else
			delete[] (_ns1__findServerResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getControllerParameters:
		if (p->size < 0)
			delete (_ns1__getControllerParameters*)p->ptr;
		else
			delete[] (_ns1__getControllerParameters*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getControllerParametersResponse:
		if (p->size < 0)
			delete (_ns1__getControllerParametersResponse*)p->ptr;
		else
			delete[] (_ns1__getControllerParametersResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getCS8Compatibility:
		if (p->size < 0)
			delete (_ns1__getCS8Compatibility*)p->ptr;
		else
			delete[] (_ns1__getCS8Compatibility*)p->ptr;
		break;
	case SOAP_TYPE__ns1__getCS8CompatibilityResponse:
		if (p->size < 0)
			delete (_ns1__getCS8CompatibilityResponse*)p->ptr;
		else
			delete[] (_ns1__getCS8CompatibilityResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns2__VALApplication:
		if (p->size < 0)
			delete (ns2__VALApplication*)p->ptr;
		else
			delete[] (ns2__VALApplication*)p->ptr;
		break;
	case SOAP_TYPE_ns2__VALApplications:
		if (p->size < 0)
			delete (ns2__VALApplications*)p->ptr;
		else
			delete[] (ns2__VALApplications*)p->ptr;
		break;
	case SOAP_TYPE_ns2__Data:
		if (p->size < 0)
			delete (ns2__Data*)p->ptr;
		else
			delete[] (ns2__Data*)p->ptr;
		break;
	case SOAP_TYPE_ns2__Records:
		if (p->size < 0)
			delete (ns2__Records*)p->ptr;
		else
			delete[] (ns2__Records*)p->ptr;
		break;
	case SOAP_TYPE_ns2__JointRange:
		if (p->size < 0)
			delete (ns2__JointRange*)p->ptr;
		else
			delete[] (ns2__JointRange*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getApplications:
		if (p->size < 0)
			delete (_ns2__getApplications*)p->ptr;
		else
			delete[] (_ns2__getApplications*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getApplicationsResponse:
		if (p->size < 0)
			delete (_ns2__getApplicationsResponse*)p->ptr;
		else
			delete[] (_ns2__getApplicationsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getApplicationDatas:
		if (p->size < 0)
			delete (_ns2__getApplicationDatas*)p->ptr;
		else
			delete[] (_ns2__getApplicationDatas*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getApplicationDatasResponse:
		if (p->size < 0)
			delete (_ns2__getApplicationDatasResponse*)p->ptr;
		else
			delete[] (_ns2__getApplicationDatasResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getRecords:
		if (p->size < 0)
			delete (_ns2__getRecords*)p->ptr;
		else
			delete[] (_ns2__getRecords*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getRecordsResponse:
		if (p->size < 0)
			delete (_ns2__getRecordsResponse*)p->ptr;
		else
			delete[] (_ns2__getRecordsResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getRecord:
		if (p->size < 0)
			delete (_ns2__getRecord*)p->ptr;
		else
			delete[] (_ns2__getRecord*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getRecordResponse:
		if (p->size < 0)
			delete (_ns2__getRecordResponse*)p->ptr;
		else
			delete[] (_ns2__getRecordResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getJointRange:
		if (p->size < 0)
			delete (_ns2__getJointRange*)p->ptr;
		else
			delete[] (_ns2__getJointRange*)p->ptr;
		break;
	case SOAP_TYPE__ns2__getJointRangeResponse:
		if (p->size < 0)
			delete (_ns2__getJointRangeResponse*)p->ptr;
		else
			delete[] (_ns2__getJointRangeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns3__Include:
		if (p->size < 0)
			delete (ns3__Include*)p->ptr;
		else
			delete[] (ns3__Include*)p->ptr;
		break;
	case SOAP_TYPE_ns5__JointPos:
		if (p->size < 0)
			delete (ns5__JointPos*)p->ptr;
		else
			delete[] (ns5__JointPos*)p->ptr;
		break;
	case SOAP_TYPE_ns5__Versions:
		if (p->size < 0)
			delete (ns5__Versions*)p->ptr;
		else
			delete[] (ns5__Versions*)p->ptr;
		break;
	case SOAP_TYPE_ns5__Robots:
		if (p->size < 0)
			delete (ns5__Robots*)p->ptr;
		else
			delete[] (ns5__Robots*)p->ptr;
		break;
	case SOAP_TYPE_ns5__VALApplications:
		if (p->size < 0)
			delete (ns5__VALApplications*)p->ptr;
		else
			delete[] (ns5__VALApplications*)p->ptr;
		break;
	case SOAP_TYPE_ns5__Records:
		if (p->size < 0)
			delete (ns5__Records*)p->ptr;
		else
			delete[] (ns5__Records*)p->ptr;
		break;
	case SOAP_TYPE_ns5__AllRobotsPos:
		if (p->size < 0)
			delete (ns5__AllRobotsPos*)p->ptr;
		else
			delete[] (ns5__AllRobotsPos*)p->ptr;
		break;
	case SOAP_TYPE_ns6__JointPos:
		if (p->size < 0)
			delete (ns6__JointPos*)p->ptr;
		else
			delete[] (ns6__JointPos*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Versions:
		if (p->size < 0)
			delete (ns6__Versions*)p->ptr;
		else
			delete[] (ns6__Versions*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Robots:
		if (p->size < 0)
			delete (ns6__Robots*)p->ptr;
		else
			delete[] (ns6__Robots*)p->ptr;
		break;
	case SOAP_TYPE_ns6__VALApplications:
		if (p->size < 0)
			delete (ns6__VALApplications*)p->ptr;
		else
			delete[] (ns6__VALApplications*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Records:
		if (p->size < 0)
			delete (ns6__Records*)p->ptr;
		else
			delete[] (ns6__Records*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Frame:
		if (p->size < 0)
			delete (ns6__Frame*)p->ptr;
		else
			delete[] (ns6__Frame*)p->ptr;
		break;
	case SOAP_TYPE_ns6__AnthroConfig:
		if (p->size < 0)
			delete (ns6__AnthroConfig*)p->ptr;
		else
			delete[] (ns6__AnthroConfig*)p->ptr;
		break;
	case SOAP_TYPE_ns6__ScaraConfig:
		if (p->size < 0)
			delete (ns6__ScaraConfig*)p->ptr;
		else
			delete[] (ns6__ScaraConfig*)p->ptr;
		break;
	case SOAP_TYPE_ns6__VrbxConfig:
		if (p->size < 0)
			delete (ns6__VrbxConfig*)p->ptr;
		else
			delete[] (ns6__VrbxConfig*)p->ptr;
		break;
	case SOAP_TYPE_ns6__Config:
		if (p->size < 0)
			delete (ns6__Config*)p->ptr;
		else
			delete[] (ns6__Config*)p->ptr;
		break;
	case SOAP_TYPE_ns6__MotionDesc:
		if (p->size < 0)
			delete (ns6__MotionDesc*)p->ptr;
		else
			delete[] (ns6__MotionDesc*)p->ptr;
		break;
	case SOAP_TYPE_ns6__RobotPos:
		if (p->size < 0)
			delete (ns6__RobotPos*)p->ptr;
		else
			delete[] (ns6__RobotPos*)p->ptr;
		break;
	case SOAP_TYPE_ns6__AllRobotsPos:
		if (p->size < 0)
			delete (ns6__AllRobotsPos*)p->ptr;
		else
			delete[] (ns6__AllRobotsPos*)p->ptr;
		break;
	case SOAP_TYPE__ns6__forwardKin:
		if (p->size < 0)
			delete (_ns6__forwardKin*)p->ptr;
		else
			delete[] (_ns6__forwardKin*)p->ptr;
		break;
	case SOAP_TYPE__ns6__forwardKinResponse:
		if (p->size < 0)
			delete (_ns6__forwardKinResponse*)p->ptr;
		else
			delete[] (_ns6__forwardKinResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns6__reverseKin:
		if (p->size < 0)
			delete (_ns6__reverseKin*)p->ptr;
		else
			delete[] (_ns6__reverseKin*)p->ptr;
		break;
	case SOAP_TYPE__ns6__reverseKinResponse:
		if (p->size < 0)
			delete (_ns6__reverseKinResponse*)p->ptr;
		else
			delete[] (_ns6__reverseKinResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns6__moveJJ:
		if (p->size < 0)
			delete (_ns6__moveJJ*)p->ptr;
		else
			delete[] (_ns6__moveJJ*)p->ptr;
		break;
	case SOAP_TYPE__ns6__moveResponse:
		if (p->size < 0)
			delete (_ns6__moveResponse*)p->ptr;
		else
			delete[] (_ns6__moveResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns6__moveJC:
		if (p->size < 0)
			delete (_ns6__moveJC*)p->ptr;
		else
			delete[] (_ns6__moveJC*)p->ptr;
		break;
	case SOAP_TYPE__ns6__moveL:
		if (p->size < 0)
			delete (_ns6__moveL*)p->ptr;
		else
			delete[] (_ns6__moveL*)p->ptr;
		break;
	case SOAP_TYPE__ns6__moveC:
		if (p->size < 0)
			delete (_ns6__moveC*)p->ptr;
		else
			delete[] (_ns6__moveC*)p->ptr;
		break;
	case SOAP_TYPE__ns6__resetMotion:
		if (p->size < 0)
			delete (_ns6__resetMotion*)p->ptr;
		else
			delete[] (_ns6__resetMotion*)p->ptr;
		break;
	case SOAP_TYPE__ns6__motionResponse:
		if (p->size < 0)
			delete (_ns6__motionResponse*)p->ptr;
		else
			delete[] (_ns6__motionResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns6__stopMotion:
		if (p->size < 0)
			delete (_ns6__stopMotion*)p->ptr;
		else
			delete[] (_ns6__stopMotion*)p->ptr;
		break;
	case SOAP_TYPE__ns6__restartMotion:
		if (p->size < 0)
			delete (_ns6__restartMotion*)p->ptr;
		else
			delete[] (_ns6__restartMotion*)p->ptr;
		break;
	case SOAP_TYPE__ns6__setSchedulingMode:
		if (p->size < 0)
			delete (_ns6__setSchedulingMode*)p->ptr;
		else
			delete[] (_ns6__setSchedulingMode*)p->ptr;
		break;
	case SOAP_TYPE__ns6__setSchedulingModeResponse:
		if (p->size < 0)
			delete (_ns6__setSchedulingModeResponse*)p->ptr;
		else
			delete[] (_ns6__setSchedulingModeResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns6__schedulerRefresh:
		if (p->size < 0)
			delete (_ns6__schedulerRefresh*)p->ptr;
		else
			delete[] (_ns6__schedulerRefresh*)p->ptr;
		break;
	case SOAP_TYPE__ns6__MotionAndRobotsPos:
		if (p->size < 0)
			delete (_ns6__MotionAndRobotsPos*)p->ptr;
		else
			delete[] (_ns6__MotionAndRobotsPos*)p->ptr;
		break;
	case SOAP_TYPE__ns6__setPower:
		if (p->size < 0)
			delete (_ns6__setPower*)p->ptr;
		else
			delete[] (_ns6__setPower*)p->ptr;
		break;
	case SOAP_TYPE__ns6__setPowerResponse:
		if (p->size < 0)
			delete (_ns6__setPowerResponse*)p->ptr;
		else
			delete[] (_ns6__setPowerResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns4__base64Binary:
		if (p->size < 0)
			delete (ns4__base64Binary*)p->ptr;
		else
			delete[] (ns4__base64Binary*)p->ptr;
		break;
	case SOAP_TYPE_ns4__hexBinary:
		if (p->size < 0)
			delete (ns4__hexBinary*)p->ptr;
		else
			delete[] (ns4__hexBinary*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getSoapServerVersion:
		if (p->size < 0)
			delete (struct __ns1__getSoapServerVersion*)p->ptr;
		else
			delete[] (struct __ns1__getSoapServerVersion*)p->ptr;
		break;
	case SOAP_TYPE___ns1__ping:
		if (p->size < 0)
			delete (struct __ns1__ping*)p->ptr;
		else
			delete[] (struct __ns1__ping*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getCS8Versions:
		if (p->size < 0)
			delete (struct __ns1__getCS8Versions*)p->ptr;
		else
			delete[] (struct __ns1__getCS8Versions*)p->ptr;
		break;
	case SOAP_TYPE___ns1__login:
		if (p->size < 0)
			delete (struct __ns1__login*)p->ptr;
		else
			delete[] (struct __ns1__login*)p->ptr;
		break;
	case SOAP_TYPE___ns1__logout:
		if (p->size < 0)
			delete (struct __ns1__logout*)p->ptr;
		else
			delete[] (struct __ns1__logout*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getRobots:
		if (p->size < 0)
			delete (struct __ns1__getRobots*)p->ptr;
		else
			delete[] (struct __ns1__getRobots*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getRobotJointPos:
		if (p->size < 0)
			delete (struct __ns1__getRobotJointPos*)p->ptr;
		else
			delete[] (struct __ns1__getRobotJointPos*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getRobotJntCartPos:
		if (p->size < 0)
			delete (struct __ns1__getRobotJntCartPos*)p->ptr;
		else
			delete[] (struct __ns1__getRobotJntCartPos*)p->ptr;
		break;
	case SOAP_TYPE___ns1__setRobotJointPos:
		if (p->size < 0)
			delete (struct __ns1__setRobotJointPos*)p->ptr;
		else
			delete[] (struct __ns1__setRobotJointPos*)p->ptr;
		break;
	case SOAP_TYPE___ns2__getApplications:
		if (p->size < 0)
			delete (struct __ns2__getApplications*)p->ptr;
		else
			delete[] (struct __ns2__getApplications*)p->ptr;
		break;
	case SOAP_TYPE___ns2__getApplicationDatas:
		if (p->size < 0)
			delete (struct __ns2__getApplicationDatas*)p->ptr;
		else
			delete[] (struct __ns2__getApplicationDatas*)p->ptr;
		break;
	case SOAP_TYPE___ns2__getRecords:
		if (p->size < 0)
			delete (struct __ns2__getRecords*)p->ptr;
		else
			delete[] (struct __ns2__getRecords*)p->ptr;
		break;
	case SOAP_TYPE___ns2__getRecord:
		if (p->size < 0)
			delete (struct __ns2__getRecord*)p->ptr;
		else
			delete[] (struct __ns2__getRecord*)p->ptr;
		break;
	case SOAP_TYPE___ns2__getJointRange:
		if (p->size < 0)
			delete (struct __ns2__getJointRange*)p->ptr;
		else
			delete[] (struct __ns2__getJointRange*)p->ptr;
		break;
	case SOAP_TYPE___ns6__forwardKin:
		if (p->size < 0)
			delete (struct __ns6__forwardKin*)p->ptr;
		else
			delete[] (struct __ns6__forwardKin*)p->ptr;
		break;
	case SOAP_TYPE___ns6__reverseKin:
		if (p->size < 0)
			delete (struct __ns6__reverseKin*)p->ptr;
		else
			delete[] (struct __ns6__reverseKin*)p->ptr;
		break;
	case SOAP_TYPE___ns6__moveJJ:
		if (p->size < 0)
			delete (struct __ns6__moveJJ*)p->ptr;
		else
			delete[] (struct __ns6__moveJJ*)p->ptr;
		break;
	case SOAP_TYPE___ns6__moveJC:
		if (p->size < 0)
			delete (struct __ns6__moveJC*)p->ptr;
		else
			delete[] (struct __ns6__moveJC*)p->ptr;
		break;
	case SOAP_TYPE___ns6__moveL:
		if (p->size < 0)
			delete (struct __ns6__moveL*)p->ptr;
		else
			delete[] (struct __ns6__moveL*)p->ptr;
		break;
	case SOAP_TYPE___ns6__moveC:
		if (p->size < 0)
			delete (struct __ns6__moveC*)p->ptr;
		else
			delete[] (struct __ns6__moveC*)p->ptr;
		break;
	case SOAP_TYPE___ns6__resetMotion:
		if (p->size < 0)
			delete (struct __ns6__resetMotion*)p->ptr;
		else
			delete[] (struct __ns6__resetMotion*)p->ptr;
		break;
	case SOAP_TYPE___ns6__stopMotion:
		if (p->size < 0)
			delete (struct __ns6__stopMotion*)p->ptr;
		else
			delete[] (struct __ns6__stopMotion*)p->ptr;
		break;
	case SOAP_TYPE___ns6__restartMotion:
		if (p->size < 0)
			delete (struct __ns6__restartMotion*)p->ptr;
		else
			delete[] (struct __ns6__restartMotion*)p->ptr;
		break;
	case SOAP_TYPE___ns6__setSchedulingMode:
		if (p->size < 0)
			delete (struct __ns6__setSchedulingMode*)p->ptr;
		else
			delete[] (struct __ns6__setSchedulingMode*)p->ptr;
		break;
	case SOAP_TYPE___ns6__schedulerRefresh:
		if (p->size < 0)
			delete (struct __ns6__schedulerRefresh*)p->ptr;
		else
			delete[] (struct __ns6__schedulerRefresh*)p->ptr;
		break;
	case SOAP_TYPE___ns6__setPower:
		if (p->size < 0)
			delete (struct __ns6__setPower*)p->ptr;
		else
			delete[] (struct __ns6__setPower*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__RobotPos:
		if (p->size < 0)
			delete (std::vector<ns6__RobotPos * >*)p->ptr;
		else
			delete[] (std::vector<ns6__RobotPos * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication:
		if (p->size < 0)
			delete (std::vector<ns2__VALApplication * >*)p->ptr;
		else
			delete[] (std::vector<ns2__VALApplication * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter:
		if (p->size < 0)
			delete (std::vector<ns1__Parameter * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Parameter * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot:
		if (p->size < 0)
			delete (std::vector<ns1__Robot * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Robot * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version:
		if (p->size < 0)
			delete (std::vector<ns1__Version * >*)p->ptr;
		else
			delete[] (std::vector<ns1__Version * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		if (p->size < 0)
			delete (std::vector<double >*)p->ptr;
		else
			delete[] (std::vector<double >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__RobotPos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns6__RobotPos * >*)p)[len] = *(ns6__RobotPos **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__VALApplication * >*)p)[len] = *(ns2__VALApplication **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Parameter * >*)p)[len] = *(ns1__Parameter **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Robot * >*)p)[len] = *(ns1__Robot **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Version * >*)p)[len] = *(ns1__Version **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<double >*)p)[len] = *(double *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SessionId(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SessionId);
	if (soap_out_ns1__SessionId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SessionId(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns1__SessionId);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns1__SessionId(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SessionId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns1__SessionId(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns1__SessionId);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__PowerReturnCode(struct soap *soap, enum ns6__PowerReturnCode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__PowerReturnCode
	*a = SOAP_DEFAULT_ns6__PowerReturnCode;
#else
	*a = (enum ns6__PowerReturnCode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__PowerReturnCode(struct soap *soap, const enum ns6__PowerReturnCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__PowerReturnCode);
	if (soap_out_ns6__PowerReturnCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__PowerReturnCode[] =
{	{ (long)ns6__PowerReturnCode__POWER_NO_ERR, "POWER-NO-ERR" },
	{ (long)ns6__PowerReturnCode__POWER_CHANGE_WHILE_ROBOT_NOT_STOPPED, "POWER-CHANGE-WHILE-ROBOT-NOT-STOPPED" },
	{ (long)ns6__PowerReturnCode__POWER_ENABLE_TIMEOUT, "POWER-ENABLE-TIMEOUT" },
	{ (long)ns6__PowerReturnCode__POWER_DISABLE_TIMEOUT, "POWER-DISABLE-TIMEOUT" },
	{ (long)ns6__PowerReturnCode__POWER_CHANGE_ONLY_IN_REMOTE_MODE, "POWER-CHANGE-ONLY-IN-REMOTE-MODE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__PowerReturnCode2s(struct soap *soap, enum ns6__PowerReturnCode n)
{	const char *s = soap_code_str(soap_codes_ns6__PowerReturnCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__PowerReturnCode(struct soap *soap, const char *tag, int id, const enum ns6__PowerReturnCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PowerReturnCode), type) || soap_send(soap, soap_ns6__PowerReturnCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__PowerReturnCode * SOAP_FMAC4 soap_get_ns6__PowerReturnCode(struct soap *soap, enum ns6__PowerReturnCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__PowerReturnCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__PowerReturnCode(struct soap *soap, const char *s, enum ns6__PowerReturnCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__PowerReturnCode, s);
	if (map)
		*a = (enum ns6__PowerReturnCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__PowerReturnCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__PowerReturnCode * SOAP_FMAC4 soap_in_ns6__PowerReturnCode(struct soap *soap, const char *tag, enum ns6__PowerReturnCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__PowerReturnCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PowerReturnCode, sizeof(enum ns6__PowerReturnCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__PowerReturnCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__PowerReturnCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PowerReturnCode, 0, sizeof(enum ns6__PowerReturnCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__SchedulingMode(struct soap *soap, enum ns6__SchedulingMode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__SchedulingMode
	*a = SOAP_DEFAULT_ns6__SchedulingMode;
#else
	*a = (enum ns6__SchedulingMode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__SchedulingMode(struct soap *soap, const enum ns6__SchedulingMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__SchedulingMode);
	if (soap_out_ns6__SchedulingMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__SchedulingMode[] =
{	{ (long)ns6__SchedulingMode__SCHEDULING_INTERNAL, "SCHEDULING-INTERNAL" },
	{ (long)ns6__SchedulingMode__SCHEDULING_EXTERNAL, "SCHEDULING-EXTERNAL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__SchedulingMode2s(struct soap *soap, enum ns6__SchedulingMode n)
{	const char *s = soap_code_str(soap_codes_ns6__SchedulingMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__SchedulingMode(struct soap *soap, const char *tag, int id, const enum ns6__SchedulingMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__SchedulingMode), type) || soap_send(soap, soap_ns6__SchedulingMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__SchedulingMode * SOAP_FMAC4 soap_get_ns6__SchedulingMode(struct soap *soap, enum ns6__SchedulingMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__SchedulingMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__SchedulingMode(struct soap *soap, const char *s, enum ns6__SchedulingMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__SchedulingMode, s);
	if (map)
		*a = (enum ns6__SchedulingMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__SchedulingMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__SchedulingMode * SOAP_FMAC4 soap_in_ns6__SchedulingMode(struct soap *soap, const char *tag, enum ns6__SchedulingMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__SchedulingMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__SchedulingMode, sizeof(enum ns6__SchedulingMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__SchedulingMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__SchedulingMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__SchedulingMode, 0, sizeof(enum ns6__SchedulingMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ReversingResult(struct soap *soap, enum ns6__ReversingResult *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ReversingResult
	*a = SOAP_DEFAULT_ns6__ReversingResult;
#else
	*a = (enum ns6__ReversingResult)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ReversingResult(struct soap *soap, const enum ns6__ReversingResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ReversingResult);
	if (soap_out_ns6__ReversingResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__ReversingResult[] =
{	{ (long)ns6__ReversingResult__REVERSE_OK, "REVERSE-OK" },
	{ (long)ns6__ReversingResult__NO_CONVERGENCE, "NO-CONVERGENCE" },
	{ (long)ns6__ReversingResult__OUT_OF_JNT_RANGE, "OUT-OF-JNT-RANGE" },
	{ (long)ns6__ReversingResult__OUT_OF_WORKSPACE, "OUT-OF-WORKSPACE" },
	{ (long)ns6__ReversingResult__INVALID_CONFIG, "INVALID-CONFIG" },
	{ (long)ns6__ReversingResult__INVALID_ORIENTATION, "INVALID-ORIENTATION" },
	{ (long)ns6__ReversingResult__UNSUPPORTED_KINEMATICS, "UNSUPPORTED-KINEMATICS" },
	{ (long)ns6__ReversingResult__UNCONSTRAINT_FRAME, "UNCONSTRAINT-FRAME" },
	{ (long)ns6__ReversingResult__INVALID_ERROR_CODE, "INVALID-ERROR-CODE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ReversingResult2s(struct soap *soap, enum ns6__ReversingResult n)
{	const char *s = soap_code_str(soap_codes_ns6__ReversingResult, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ReversingResult(struct soap *soap, const char *tag, int id, const enum ns6__ReversingResult *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ReversingResult), type) || soap_send(soap, soap_ns6__ReversingResult2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__ReversingResult * SOAP_FMAC4 soap_get_ns6__ReversingResult(struct soap *soap, enum ns6__ReversingResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ReversingResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ReversingResult(struct soap *soap, const char *s, enum ns6__ReversingResult *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__ReversingResult, s);
	if (map)
		*a = (enum ns6__ReversingResult)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ReversingResult)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ReversingResult * SOAP_FMAC4 soap_in_ns6__ReversingResult(struct soap *soap, const char *tag, enum ns6__ReversingResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ReversingResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ReversingResult, sizeof(enum ns6__ReversingResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__ReversingResult(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__ReversingResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ReversingResult, 0, sizeof(enum ns6__ReversingResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__MotionReturnCode(struct soap *soap, enum ns6__MotionReturnCode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__MotionReturnCode
	*a = SOAP_DEFAULT_ns6__MotionReturnCode;
#else
	*a = (enum ns6__MotionReturnCode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__MotionReturnCode(struct soap *soap, const enum ns6__MotionReturnCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__MotionReturnCode);
	if (soap_out_ns6__MotionReturnCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__MotionReturnCode[] =
{	{ (long)ns6__MotionReturnCode__SCSV3_MOT_NO_ERR, "SCSV3-MOT-NO-ERR" },
	{ (long)ns6__MotionReturnCode__SCSV3_MOT_NOT_READY, "SCSV3-MOT-NOT-READY" },
	{ (long)ns6__MotionReturnCode__SCSV3_MOT_ERR_PARAM, "SCSV3-MOT-ERR-PARAM" },
	{ (long)ns6__MotionReturnCode__SCSV3_MOT_ERR_MISUSE, "SCSV3-MOT-ERR-MISUSE" },
	{ (long)ns6__MotionReturnCode__SCSV3_MOT_ERR_UNEXPECTED, "SCSV3-MOT-ERR-UNEXPECTED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__MotionReturnCode2s(struct soap *soap, enum ns6__MotionReturnCode n)
{	const char *s = soap_code_str(soap_codes_ns6__MotionReturnCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__MotionReturnCode(struct soap *soap, const char *tag, int id, const enum ns6__MotionReturnCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__MotionReturnCode), type) || soap_send(soap, soap_ns6__MotionReturnCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__MotionReturnCode * SOAP_FMAC4 soap_get_ns6__MotionReturnCode(struct soap *soap, enum ns6__MotionReturnCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__MotionReturnCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__MotionReturnCode(struct soap *soap, const char *s, enum ns6__MotionReturnCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__MotionReturnCode, s);
	if (map)
		*a = (enum ns6__MotionReturnCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__MotionReturnCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__MotionReturnCode * SOAP_FMAC4 soap_in_ns6__MotionReturnCode(struct soap *soap, const char *tag, enum ns6__MotionReturnCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__MotionReturnCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__MotionReturnCode, sizeof(enum ns6__MotionReturnCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__MotionReturnCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__MotionReturnCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__MotionReturnCode, 0, sizeof(enum ns6__MotionReturnCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__AboveBelowConfig(struct soap *soap, enum ns6__AboveBelowConfig *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__AboveBelowConfig
	*a = SOAP_DEFAULT_ns6__AboveBelowConfig;
#else
	*a = (enum ns6__AboveBelowConfig)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__AboveBelowConfig(struct soap *soap, const enum ns6__AboveBelowConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__AboveBelowConfig);
	if (soap_out_ns6__AboveBelowConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__AboveBelowConfig[] =
{	{ (long)ns6__AboveBelowConfig__ABSAME, "ABSAME" },
	{ (long)ns6__AboveBelowConfig__ABOVE, "ABOVE" },
	{ (long)ns6__AboveBelowConfig__BELOW, "BELOW" },
	{ (long)ns6__AboveBelowConfig__ABFREE, "ABFREE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__AboveBelowConfig2s(struct soap *soap, enum ns6__AboveBelowConfig n)
{	const char *s = soap_code_str(soap_codes_ns6__AboveBelowConfig, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AboveBelowConfig(struct soap *soap, const char *tag, int id, const enum ns6__AboveBelowConfig *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AboveBelowConfig), type) || soap_send(soap, soap_ns6__AboveBelowConfig2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__AboveBelowConfig * SOAP_FMAC4 soap_get_ns6__AboveBelowConfig(struct soap *soap, enum ns6__AboveBelowConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AboveBelowConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__AboveBelowConfig(struct soap *soap, const char *s, enum ns6__AboveBelowConfig *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__AboveBelowConfig, s);
	if (map)
		*a = (enum ns6__AboveBelowConfig)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__AboveBelowConfig)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__AboveBelowConfig * SOAP_FMAC4 soap_in_ns6__AboveBelowConfig(struct soap *soap, const char *tag, enum ns6__AboveBelowConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__AboveBelowConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AboveBelowConfig, sizeof(enum ns6__AboveBelowConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__AboveBelowConfig(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__AboveBelowConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AboveBelowConfig, 0, sizeof(enum ns6__AboveBelowConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__PositiveNegativeConfig(struct soap *soap, enum ns6__PositiveNegativeConfig *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__PositiveNegativeConfig
	*a = SOAP_DEFAULT_ns6__PositiveNegativeConfig;
#else
	*a = (enum ns6__PositiveNegativeConfig)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__PositiveNegativeConfig(struct soap *soap, const enum ns6__PositiveNegativeConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__PositiveNegativeConfig);
	if (soap_out_ns6__PositiveNegativeConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__PositiveNegativeConfig[] =
{	{ (long)ns6__PositiveNegativeConfig__PNSAME, "PNSAME" },
	{ (long)ns6__PositiveNegativeConfig__POSITIVE, "POSITIVE" },
	{ (long)ns6__PositiveNegativeConfig__NEGATIVE, "NEGATIVE" },
	{ (long)ns6__PositiveNegativeConfig__PNFREE, "PNFREE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__PositiveNegativeConfig2s(struct soap *soap, enum ns6__PositiveNegativeConfig n)
{	const char *s = soap_code_str(soap_codes_ns6__PositiveNegativeConfig, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__PositiveNegativeConfig(struct soap *soap, const char *tag, int id, const enum ns6__PositiveNegativeConfig *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__PositiveNegativeConfig), type) || soap_send(soap, soap_ns6__PositiveNegativeConfig2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__PositiveNegativeConfig * SOAP_FMAC4 soap_get_ns6__PositiveNegativeConfig(struct soap *soap, enum ns6__PositiveNegativeConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__PositiveNegativeConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__PositiveNegativeConfig(struct soap *soap, const char *s, enum ns6__PositiveNegativeConfig *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__PositiveNegativeConfig, s);
	if (map)
		*a = (enum ns6__PositiveNegativeConfig)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__PositiveNegativeConfig)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__PositiveNegativeConfig * SOAP_FMAC4 soap_in_ns6__PositiveNegativeConfig(struct soap *soap, const char *tag, enum ns6__PositiveNegativeConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__PositiveNegativeConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__PositiveNegativeConfig, sizeof(enum ns6__PositiveNegativeConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__PositiveNegativeConfig(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__PositiveNegativeConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__PositiveNegativeConfig, 0, sizeof(enum ns6__PositiveNegativeConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ShoulderConfig(struct soap *soap, enum ns6__ShoulderConfig *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ShoulderConfig
	*a = SOAP_DEFAULT_ns6__ShoulderConfig;
#else
	*a = (enum ns6__ShoulderConfig)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ShoulderConfig(struct soap *soap, const enum ns6__ShoulderConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ShoulderConfig);
	if (soap_out_ns6__ShoulderConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__ShoulderConfig[] =
{	{ (long)ns6__ShoulderConfig__SSAME, "SSAME" },
	{ (long)ns6__ShoulderConfig__LEFTY, "LEFTY" },
	{ (long)ns6__ShoulderConfig__RIGHTY, "RIGHTY" },
	{ (long)ns6__ShoulderConfig__SFREE, "SFREE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ShoulderConfig2s(struct soap *soap, enum ns6__ShoulderConfig n)
{	const char *s = soap_code_str(soap_codes_ns6__ShoulderConfig, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ShoulderConfig(struct soap *soap, const char *tag, int id, const enum ns6__ShoulderConfig *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ShoulderConfig), type) || soap_send(soap, soap_ns6__ShoulderConfig2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__ShoulderConfig * SOAP_FMAC4 soap_get_ns6__ShoulderConfig(struct soap *soap, enum ns6__ShoulderConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ShoulderConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ShoulderConfig(struct soap *soap, const char *s, enum ns6__ShoulderConfig *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__ShoulderConfig, s);
	if (map)
		*a = (enum ns6__ShoulderConfig)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ShoulderConfig)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ShoulderConfig * SOAP_FMAC4 soap_in_ns6__ShoulderConfig(struct soap *soap, const char *tag, enum ns6__ShoulderConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ShoulderConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ShoulderConfig, sizeof(enum ns6__ShoulderConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__ShoulderConfig(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__ShoulderConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ShoulderConfig, 0, sizeof(enum ns6__ShoulderConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__BlendType(struct soap *soap, enum ns6__BlendType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__BlendType
	*a = SOAP_DEFAULT_ns6__BlendType;
#else
	*a = (enum ns6__BlendType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__BlendType(struct soap *soap, const enum ns6__BlendType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__BlendType);
	if (soap_out_ns6__BlendType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__BlendType[] =
{	{ (long)ns6__BlendType__BLEND_OFF, "BLEND-OFF" },
	{ (long)ns6__BlendType__BLEND_JOINT, "BLEND-JOINT" },
	{ (long)ns6__BlendType__BLEND_CART, "BLEND-CART" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__BlendType2s(struct soap *soap, enum ns6__BlendType n)
{	const char *s = soap_code_str(soap_codes_ns6__BlendType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__BlendType(struct soap *soap, const char *tag, int id, const enum ns6__BlendType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__BlendType), type) || soap_send(soap, soap_ns6__BlendType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__BlendType * SOAP_FMAC4 soap_get_ns6__BlendType(struct soap *soap, enum ns6__BlendType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__BlendType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__BlendType(struct soap *soap, const char *s, enum ns6__BlendType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__BlendType, s);
	if (map)
		*a = (enum ns6__BlendType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__BlendType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__BlendType * SOAP_FMAC4 soap_in_ns6__BlendType(struct soap *soap, const char *tag, enum ns6__BlendType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__BlendType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__BlendType, sizeof(enum ns6__BlendType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__BlendType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__BlendType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__BlendType, 0, sizeof(enum ns6__BlendType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__MoveType(struct soap *soap, enum ns6__MoveType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__MoveType
	*a = SOAP_DEFAULT_ns6__MoveType;
#else
	*a = (enum ns6__MoveType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__MoveType(struct soap *soap, const enum ns6__MoveType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__MoveType);
	if (soap_out_ns6__MoveType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns6__MoveType[] =
{	{ (long)ns6__MoveType__ABSOLUTE_MOVE, "ABSOLUTE-MOVE" },
	{ (long)ns6__MoveType__RELATIVE_MOVE, "RELATIVE-MOVE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__MoveType2s(struct soap *soap, enum ns6__MoveType n)
{	const char *s = soap_code_str(soap_codes_ns6__MoveType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__MoveType(struct soap *soap, const char *tag, int id, const enum ns6__MoveType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__MoveType), type) || soap_send(soap, soap_ns6__MoveType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns6__MoveType * SOAP_FMAC4 soap_get_ns6__MoveType(struct soap *soap, enum ns6__MoveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__MoveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__MoveType(struct soap *soap, const char *s, enum ns6__MoveType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns6__MoveType, s);
	if (map)
		*a = (enum ns6__MoveType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__MoveType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__MoveType * SOAP_FMAC4 soap_in_ns6__MoveType(struct soap *soap, const char *tag, enum ns6__MoveType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__MoveType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__MoveType, sizeof(enum ns6__MoveType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__MoveType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__MoveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__MoveType, 0, sizeof(enum ns6__MoveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DiameterAxis3(struct soap *soap, enum ns1__DiameterAxis3 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__DiameterAxis3
	*a = SOAP_DEFAULT_ns1__DiameterAxis3;
#else
	*a = (enum ns1__DiameterAxis3)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DiameterAxis3(struct soap *soap, const enum ns1__DiameterAxis3 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DiameterAxis3);
	if (soap_out_ns1__DiameterAxis3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__DiameterAxis3[] =
{	{ (long)ns1__DiameterAxis3__DIAMETERAXIS3_INVALID, "DIAMETERAXIS3-INVALID" },
	{ (long)ns1__DiameterAxis3__DIAMETERAXIS3_D20, "DIAMETERAXIS3-D20" },
	{ (long)ns1__DiameterAxis3__DIAMETERAXIS3_D25, "DIAMETERAXIS3-D25" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__DiameterAxis32s(struct soap *soap, enum ns1__DiameterAxis3 n)
{	const char *s = soap_code_str(soap_codes_ns1__DiameterAxis3, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DiameterAxis3(struct soap *soap, const char *tag, int id, const enum ns1__DiameterAxis3 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DiameterAxis3), type) || soap_send(soap, soap_ns1__DiameterAxis32s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__DiameterAxis3 * SOAP_FMAC4 soap_get_ns1__DiameterAxis3(struct soap *soap, enum ns1__DiameterAxis3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DiameterAxis3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__DiameterAxis3(struct soap *soap, const char *s, enum ns1__DiameterAxis3 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__DiameterAxis3, s);
	if (map)
		*a = (enum ns1__DiameterAxis3)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__DiameterAxis3)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__DiameterAxis3 * SOAP_FMAC4 soap_in_ns1__DiameterAxis3(struct soap *soap, const char *tag, enum ns1__DiameterAxis3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__DiameterAxis3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DiameterAxis3, sizeof(enum ns1__DiameterAxis3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__DiameterAxis3(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__DiameterAxis3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DiameterAxis3, 0, sizeof(enum ns1__DiameterAxis3), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__LengthAxis3(struct soap *soap, enum ns1__LengthAxis3 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__LengthAxis3
	*a = SOAP_DEFAULT_ns1__LengthAxis3;
#else
	*a = (enum ns1__LengthAxis3)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LengthAxis3(struct soap *soap, const enum ns1__LengthAxis3 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__LengthAxis3);
	if (soap_out_ns1__LengthAxis3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__LengthAxis3[] =
{	{ (long)ns1__LengthAxis3__LENGTHAXIS3_INVALID, "LENGTHAXIS3-INVALID" },
	{ (long)ns1__LengthAxis3__LENGTHAXIS3_L100, "LENGTHAXIS3-L100" },
	{ (long)ns1__LengthAxis3__LENGTHAXIS3_L200, "LENGTHAXIS3-L200" },
	{ (long)ns1__LengthAxis3__LENGTHAXIS3_L400, "LENGTHAXIS3-L400" },
	{ (long)ns1__LengthAxis3__LENGTHAXIS3_L600, "LENGTHAXIS3-L600" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__LengthAxis32s(struct soap *soap, enum ns1__LengthAxis3 n)
{	const char *s = soap_code_str(soap_codes_ns1__LengthAxis3, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LengthAxis3(struct soap *soap, const char *tag, int id, const enum ns1__LengthAxis3 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LengthAxis3), type) || soap_send(soap, soap_ns1__LengthAxis32s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__LengthAxis3 * SOAP_FMAC4 soap_get_ns1__LengthAxis3(struct soap *soap, enum ns1__LengthAxis3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LengthAxis3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__LengthAxis3(struct soap *soap, const char *s, enum ns1__LengthAxis3 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__LengthAxis3, s);
	if (map)
		*a = (enum ns1__LengthAxis3)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__LengthAxis3)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__LengthAxis3 * SOAP_FMAC4 soap_in_ns1__LengthAxis3(struct soap *soap, const char *tag, enum ns1__LengthAxis3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__LengthAxis3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LengthAxis3, sizeof(enum ns1__LengthAxis3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__LengthAxis3(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__LengthAxis3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LengthAxis3, 0, sizeof(enum ns1__LengthAxis3), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MountType(struct soap *soap, enum ns1__MountType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MountType
	*a = SOAP_DEFAULT_ns1__MountType;
#else
	*a = (enum ns1__MountType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MountType(struct soap *soap, const enum ns1__MountType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MountType);
	if (soap_out_ns1__MountType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__MountType[] =
{	{ (long)ns1__MountType__MOUNTTYPE_INVALID, "MOUNTTYPE-INVALID" },
	{ (long)ns1__MountType__MOUNTTYPE_FLOOR, "MOUNTTYPE-FLOOR" },
	{ (long)ns1__MountType__MOUNTTYPE_CEILING, "MOUNTTYPE-CEILING" },
	{ (long)ns1__MountType__MOUNTTYPE_WALL, "MOUNTTYPE-WALL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MountType2s(struct soap *soap, enum ns1__MountType n)
{	const char *s = soap_code_str(soap_codes_ns1__MountType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MountType(struct soap *soap, const char *tag, int id, const enum ns1__MountType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MountType), type) || soap_send(soap, soap_ns1__MountType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__MountType * SOAP_FMAC4 soap_get_ns1__MountType(struct soap *soap, enum ns1__MountType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MountType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MountType(struct soap *soap, const char *s, enum ns1__MountType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__MountType, s);
	if (map)
		*a = (enum ns1__MountType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MountType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MountType * SOAP_FMAC4 soap_in_ns1__MountType(struct soap *soap, const char *tag, enum ns1__MountType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MountType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MountType, sizeof(enum ns1__MountType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MountType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MountType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MountType, 0, sizeof(enum ns1__MountType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Kinematic(struct soap *soap, enum ns1__Kinematic *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Kinematic
	*a = SOAP_DEFAULT_ns1__Kinematic;
#else
	*a = (enum ns1__Kinematic)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Kinematic(struct soap *soap, const enum ns1__Kinematic *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Kinematic);
	if (soap_out_ns1__Kinematic(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__Kinematic[] =
{	{ (long)ns1__Kinematic__KINEMATIC_INVALID, "KINEMATIC-INVALID" },
	{ (long)ns1__Kinematic__KINEMATIC_ANTHROPOMORPH6, "KINEMATIC-ANTHROPOMORPH6" },
	{ (long)ns1__Kinematic__KINEMATIC_ANTHROPOMORPH5, "KINEMATIC-ANTHROPOMORPH5" },
	{ (long)ns1__Kinematic__KINEMATIC_SCARA, "KINEMATIC-SCARA" },
	{ (long)ns1__Kinematic__KINEMATIC_EISENMANN, "KINEMATIC-EISENMANN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Kinematic2s(struct soap *soap, enum ns1__Kinematic n)
{	const char *s = soap_code_str(soap_codes_ns1__Kinematic, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Kinematic(struct soap *soap, const char *tag, int id, const enum ns1__Kinematic *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Kinematic), type) || soap_send(soap, soap_ns1__Kinematic2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__Kinematic * SOAP_FMAC4 soap_get_ns1__Kinematic(struct soap *soap, enum ns1__Kinematic *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Kinematic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Kinematic(struct soap *soap, const char *s, enum ns1__Kinematic *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__Kinematic, s);
	if (map)
		*a = (enum ns1__Kinematic)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Kinematic)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Kinematic * SOAP_FMAC4 soap_in_ns1__Kinematic(struct soap *soap, const char *tag, enum ns1__Kinematic *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Kinematic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Kinematic, sizeof(enum ns1__Kinematic), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__Kinematic(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Kinematic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Kinematic, 0, sizeof(enum ns1__Kinematic), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ServerExceptionCode(struct soap *soap, enum ns1__ServerExceptionCode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ServerExceptionCode
	*a = SOAP_DEFAULT_ns1__ServerExceptionCode;
#else
	*a = (enum ns1__ServerExceptionCode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ServerExceptionCode(struct soap *soap, const enum ns1__ServerExceptionCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ServerExceptionCode);
	if (soap_out_ns1__ServerExceptionCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ServerExceptionCode[] =
{	{ (long)ns1__ServerExceptionCode__UNKNOWN_CODE, "UNKNOWN-CODE" },
	{ (long)ns1__ServerExceptionCode__INVALID_SESSION_ID_CODE, "INVALID-SESSION-ID-CODE" },
	{ (long)ns1__ServerExceptionCode__INVALID_ROBOT_ID_CODE, "INVALID-ROBOT-ID-CODE" },
	{ (long)ns1__ServerExceptionCode__READ_ACCESS_ERROR_CODE, "READ-ACCESS-ERROR-CODE" },
	{ (long)ns1__ServerExceptionCode__WRITE_ACCESS_ERROR_CODE, "WRITE-ACCESS-ERROR-CODE" },
	{ (long)ns1__ServerExceptionCode__SET_POS_NOT_SIMUL_CODE, "SET-POS-NOT-SIMUL-CODE" },
	{ (long)ns1__ServerExceptionCode__SET_POS_POWER_ON_CODE, "SET-POS-POWER-ON-CODE" },
	{ (long)ns1__ServerExceptionCode__FILE_NOT_FOUND_CODE, "FILE-NOT-FOUND-CODE" },
	{ (long)ns1__ServerExceptionCode__INVALID_CONFIG_CODE, "INVALID-CONFIG-CODE" },
	{ (long)ns1__ServerExceptionCode__INVALID_NUMBER_OF_AXIS_CODE, "INVALID-NUMBER-OF-AXIS-CODE" },
	{ (long)ns1__ServerExceptionCode__INVALID_MOT_DESC_CODE, "INVALID-MOT-DESC-CODE" },
	{ (long)ns1__ServerExceptionCode__CLIENT_ALREADY_CONNECTED, "CLIENT-ALREADY-CONNECTED" },
	{ (long)ns1__ServerExceptionCode__CLIENT_COMMUNICATION_ERROR, "CLIENT-COMMUNICATION-ERROR" },
	{ (long)ns1__ServerExceptionCode__APPLICATION_NOT_FOUND, "APPLICATION-NOT-FOUND" },
	{ (long)ns1__ServerExceptionCode__PROGRAM_NOT_FOUND, "PROGRAM-NOT-FOUND" },
	{ (long)ns1__ServerExceptionCode__TASK_NOT_FOUND, "TASK-NOT-FOUND" },
	{ (long)ns1__ServerExceptionCode__STACK_FRAME_NOT_FOUND, "STACK-FRAME-NOT-FOUND" },
	{ (long)ns1__ServerExceptionCode__TASK_ALREADY_LOCKED, "TASK-ALREADY-LOCKED" },
	{ (long)ns1__ServerExceptionCode__INVALID_SOAP_HANDLER, "INVALID-SOAP-HANDLER" },
	{ (long)ns1__ServerExceptionCode__INVALID_SOAP_HEADER, "INVALID-SOAP-HEADER" },
	{ (long)ns1__ServerExceptionCode__PROGRAM_LINE_NOT_FOUND, "PROGRAM-LINE-NOT-FOUND" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ServerExceptionCode2s(struct soap *soap, enum ns1__ServerExceptionCode n)
{	const char *s = soap_code_str(soap_codes_ns1__ServerExceptionCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServerExceptionCode(struct soap *soap, const char *tag, int id, const enum ns1__ServerExceptionCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServerExceptionCode), type) || soap_send(soap, soap_ns1__ServerExceptionCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ServerExceptionCode * SOAP_FMAC4 soap_get_ns1__ServerExceptionCode(struct soap *soap, enum ns1__ServerExceptionCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServerExceptionCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ServerExceptionCode(struct soap *soap, const char *s, enum ns1__ServerExceptionCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ServerExceptionCode, s);
	if (map)
		*a = (enum ns1__ServerExceptionCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 20)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ServerExceptionCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ServerExceptionCode * SOAP_FMAC4 soap_in_ns1__ServerExceptionCode(struct soap *soap, const char *tag, enum ns1__ServerExceptionCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ServerExceptionCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServerExceptionCode, sizeof(enum ns1__ServerExceptionCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ServerExceptionCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ServerExceptionCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServerExceptionCode, 0, sizeof(enum ns1__ServerExceptionCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns6__setPowerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__PowerReturnCode(soap, &this->_ns6__setPowerResponse::code);
	/* transient soap skipped */
}

void _ns6__setPowerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__setPowerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__setPowerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__setPowerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__setPowerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__setPowerResponse(struct soap *soap, const char *tag, int id, const _ns6__setPowerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__setPowerResponse), type))
		return soap->error;
	if (soap_out_ns6__PowerReturnCode(soap, "code", -1, &(a->_ns6__setPowerResponse::code), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__setPowerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__setPowerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__setPowerResponse * SOAP_FMAC4 soap_get__ns6__setPowerResponse(struct soap *soap, _ns6__setPowerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__setPowerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__setPowerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__setPowerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__setPowerResponse * SOAP_FMAC4 soap_in__ns6__setPowerResponse(struct soap *soap, const char *tag, _ns6__setPowerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__setPowerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__setPowerResponse, sizeof(_ns6__setPowerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__setPowerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__setPowerResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__PowerReturnCode(soap, "code", &(a->_ns6__setPowerResponse::code), "ns6:PowerReturnCode"))
				{	soap_flag_code1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__setPowerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__setPowerResponse, 0, sizeof(_ns6__setPowerResponse), 0, soap_copy__ns6__setPowerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__setPowerResponse * SOAP_FMAC4 soap_instantiate__ns6__setPowerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__setPowerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__setPowerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__setPowerResponse;
		if (size)
			*size = sizeof(_ns6__setPowerResponse);
		((_ns6__setPowerResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__setPowerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__setPowerResponse);
		for (int i = 0; i < n; i++)
			((_ns6__setPowerResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__setPowerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__setPowerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__setPowerResponse %p -> %p\n", q, p));
	*(_ns6__setPowerResponse*)p = *(_ns6__setPowerResponse*)q;
}

void _ns6__setPower::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns6__setPower::power);
	/* transient soap skipped */
}

void _ns6__setPower::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__setPower::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__setPower);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__setPower::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__setPower(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__setPower(struct soap *soap, const char *tag, int id, const _ns6__setPower *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__setPower), type))
		return soap->error;
	if (soap_out_bool(soap, "power", -1, &(a->_ns6__setPower::power), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__setPower::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__setPower(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__setPower * SOAP_FMAC4 soap_get__ns6__setPower(struct soap *soap, _ns6__setPower *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__setPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__setPower::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__setPower(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__setPower * SOAP_FMAC4 soap_in__ns6__setPower(struct soap *soap, const char *tag, _ns6__setPower *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__setPower *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__setPower, sizeof(_ns6__setPower), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__setPower)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__setPower *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_power1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_power1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "power", &(a->_ns6__setPower::power), "xsd:boolean"))
				{	soap_flag_power1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__setPower *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__setPower, 0, sizeof(_ns6__setPower), 0, soap_copy__ns6__setPower);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_power1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__setPower * SOAP_FMAC4 soap_instantiate__ns6__setPower(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__setPower(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__setPower, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__setPower;
		if (size)
			*size = sizeof(_ns6__setPower);
		((_ns6__setPower*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__setPower[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__setPower);
		for (int i = 0; i < n; i++)
			((_ns6__setPower*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__setPower*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__setPower(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__setPower %p -> %p\n", q, p));
	*(_ns6__setPower*)p = *(_ns6__setPower*)q;
}

void _ns6__MotionAndRobotsPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__SchedulingMode(soap, &this->_ns6__MotionAndRobotsPos::schedulingMode);
	soap_default_bool(soap, &this->_ns6__MotionAndRobotsPos::motionEmpty);
	this->_ns6__MotionAndRobotsPos::allRobotsPos = NULL;
	/* transient soap skipped */
}

void _ns6__MotionAndRobotsPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__AllRobotsPos(soap, &this->_ns6__MotionAndRobotsPos::allRobotsPos);
	/* transient soap skipped */
}

int _ns6__MotionAndRobotsPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__MotionAndRobotsPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__MotionAndRobotsPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__MotionAndRobotsPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__MotionAndRobotsPos(struct soap *soap, const char *tag, int id, const _ns6__MotionAndRobotsPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__MotionAndRobotsPos), type))
		return soap->error;
	if (soap_out_ns6__SchedulingMode(soap, "schedulingMode", -1, &(a->_ns6__MotionAndRobotsPos::schedulingMode), ""))
		return soap->error;
	if (soap_out_bool(soap, "motionEmpty", -1, &(a->_ns6__MotionAndRobotsPos::motionEmpty), ""))
		return soap->error;
	if (soap_out_PointerTons6__AllRobotsPos(soap, "allRobotsPos", -1, &(a->_ns6__MotionAndRobotsPos::allRobotsPos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__MotionAndRobotsPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__MotionAndRobotsPos(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__MotionAndRobotsPos * SOAP_FMAC4 soap_get__ns6__MotionAndRobotsPos(struct soap *soap, _ns6__MotionAndRobotsPos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__MotionAndRobotsPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__MotionAndRobotsPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__MotionAndRobotsPos(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__MotionAndRobotsPos * SOAP_FMAC4 soap_in__ns6__MotionAndRobotsPos(struct soap *soap, const char *tag, _ns6__MotionAndRobotsPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__MotionAndRobotsPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__MotionAndRobotsPos, sizeof(_ns6__MotionAndRobotsPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__MotionAndRobotsPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__MotionAndRobotsPos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_schedulingMode1 = 1;
	size_t soap_flag_motionEmpty1 = 1;
	size_t soap_flag_allRobotsPos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_schedulingMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__SchedulingMode(soap, "schedulingMode", &(a->_ns6__MotionAndRobotsPos::schedulingMode), "ns6:SchedulingMode"))
				{	soap_flag_schedulingMode1--;
					continue;
				}
			if (soap_flag_motionEmpty1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "motionEmpty", &(a->_ns6__MotionAndRobotsPos::motionEmpty), "xsd:boolean"))
				{	soap_flag_motionEmpty1--;
					continue;
				}
			if (soap_flag_allRobotsPos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__AllRobotsPos(soap, "allRobotsPos", &(a->_ns6__MotionAndRobotsPos::allRobotsPos), "ns6:AllRobotsPos"))
				{	soap_flag_allRobotsPos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__MotionAndRobotsPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__MotionAndRobotsPos, 0, sizeof(_ns6__MotionAndRobotsPos), 0, soap_copy__ns6__MotionAndRobotsPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_schedulingMode1 > 0 || soap_flag_motionEmpty1 > 0 || soap_flag_allRobotsPos1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__MotionAndRobotsPos * SOAP_FMAC4 soap_instantiate__ns6__MotionAndRobotsPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__MotionAndRobotsPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__MotionAndRobotsPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__MotionAndRobotsPos;
		if (size)
			*size = sizeof(_ns6__MotionAndRobotsPos);
		((_ns6__MotionAndRobotsPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__MotionAndRobotsPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__MotionAndRobotsPos);
		for (int i = 0; i < n; i++)
			((_ns6__MotionAndRobotsPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__MotionAndRobotsPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__MotionAndRobotsPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__MotionAndRobotsPos %p -> %p\n", q, p));
	*(_ns6__MotionAndRobotsPos*)p = *(_ns6__MotionAndRobotsPos*)q;
}

void _ns6__schedulerRefresh::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns6__schedulerRefresh::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__schedulerRefresh::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__schedulerRefresh);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__schedulerRefresh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__schedulerRefresh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__schedulerRefresh(struct soap *soap, const char *tag, int id, const _ns6__schedulerRefresh *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__schedulerRefresh), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__schedulerRefresh::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__schedulerRefresh(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__schedulerRefresh * SOAP_FMAC4 soap_get__ns6__schedulerRefresh(struct soap *soap, _ns6__schedulerRefresh *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__schedulerRefresh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__schedulerRefresh::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__schedulerRefresh(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__schedulerRefresh * SOAP_FMAC4 soap_in__ns6__schedulerRefresh(struct soap *soap, const char *tag, _ns6__schedulerRefresh *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__schedulerRefresh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__schedulerRefresh, sizeof(_ns6__schedulerRefresh), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__schedulerRefresh)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__schedulerRefresh *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__schedulerRefresh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__schedulerRefresh, 0, sizeof(_ns6__schedulerRefresh), 0, soap_copy__ns6__schedulerRefresh);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__schedulerRefresh * SOAP_FMAC4 soap_instantiate__ns6__schedulerRefresh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__schedulerRefresh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__schedulerRefresh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__schedulerRefresh;
		if (size)
			*size = sizeof(_ns6__schedulerRefresh);
		((_ns6__schedulerRefresh*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__schedulerRefresh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__schedulerRefresh);
		for (int i = 0; i < n; i++)
			((_ns6__schedulerRefresh*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__schedulerRefresh*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__schedulerRefresh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__schedulerRefresh %p -> %p\n", q, p));
	*(_ns6__schedulerRefresh*)p = *(_ns6__schedulerRefresh*)q;
}

void _ns6__setSchedulingModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns6__setSchedulingModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__setSchedulingModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__setSchedulingModeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__setSchedulingModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__setSchedulingModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__setSchedulingModeResponse(struct soap *soap, const char *tag, int id, const _ns6__setSchedulingModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__setSchedulingModeResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__setSchedulingModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__setSchedulingModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__setSchedulingModeResponse * SOAP_FMAC4 soap_get__ns6__setSchedulingModeResponse(struct soap *soap, _ns6__setSchedulingModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__setSchedulingModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__setSchedulingModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__setSchedulingModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__setSchedulingModeResponse * SOAP_FMAC4 soap_in__ns6__setSchedulingModeResponse(struct soap *soap, const char *tag, _ns6__setSchedulingModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__setSchedulingModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__setSchedulingModeResponse, sizeof(_ns6__setSchedulingModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__setSchedulingModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__setSchedulingModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__setSchedulingModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__setSchedulingModeResponse, 0, sizeof(_ns6__setSchedulingModeResponse), 0, soap_copy__ns6__setSchedulingModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__setSchedulingModeResponse * SOAP_FMAC4 soap_instantiate__ns6__setSchedulingModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__setSchedulingModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__setSchedulingModeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__setSchedulingModeResponse;
		if (size)
			*size = sizeof(_ns6__setSchedulingModeResponse);
		((_ns6__setSchedulingModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__setSchedulingModeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__setSchedulingModeResponse);
		for (int i = 0; i < n; i++)
			((_ns6__setSchedulingModeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__setSchedulingModeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__setSchedulingModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__setSchedulingModeResponse %p -> %p\n", q, p));
	*(_ns6__setSchedulingModeResponse*)p = *(_ns6__setSchedulingModeResponse*)q;
}

void _ns6__setSchedulingMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__SchedulingMode(soap, &this->_ns6__setSchedulingMode::schedulingMode);
	/* transient soap skipped */
}

void _ns6__setSchedulingMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__setSchedulingMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__setSchedulingMode);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__setSchedulingMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__setSchedulingMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__setSchedulingMode(struct soap *soap, const char *tag, int id, const _ns6__setSchedulingMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__setSchedulingMode), type))
		return soap->error;
	if (soap_out_ns6__SchedulingMode(soap, "schedulingMode", -1, &(a->_ns6__setSchedulingMode::schedulingMode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__setSchedulingMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__setSchedulingMode(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__setSchedulingMode * SOAP_FMAC4 soap_get__ns6__setSchedulingMode(struct soap *soap, _ns6__setSchedulingMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__setSchedulingMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__setSchedulingMode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__setSchedulingMode(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__setSchedulingMode * SOAP_FMAC4 soap_in__ns6__setSchedulingMode(struct soap *soap, const char *tag, _ns6__setSchedulingMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__setSchedulingMode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__setSchedulingMode, sizeof(_ns6__setSchedulingMode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__setSchedulingMode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__setSchedulingMode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_schedulingMode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_schedulingMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__SchedulingMode(soap, "schedulingMode", &(a->_ns6__setSchedulingMode::schedulingMode), "ns6:SchedulingMode"))
				{	soap_flag_schedulingMode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__setSchedulingMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__setSchedulingMode, 0, sizeof(_ns6__setSchedulingMode), 0, soap_copy__ns6__setSchedulingMode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_schedulingMode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__setSchedulingMode * SOAP_FMAC4 soap_instantiate__ns6__setSchedulingMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__setSchedulingMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__setSchedulingMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__setSchedulingMode;
		if (size)
			*size = sizeof(_ns6__setSchedulingMode);
		((_ns6__setSchedulingMode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__setSchedulingMode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__setSchedulingMode);
		for (int i = 0; i < n; i++)
			((_ns6__setSchedulingMode*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__setSchedulingMode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__setSchedulingMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__setSchedulingMode %p -> %p\n", q, p));
	*(_ns6__setSchedulingMode*)p = *(_ns6__setSchedulingMode*)q;
}

void _ns6__restartMotion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns6__restartMotion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__restartMotion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__restartMotion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__restartMotion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__restartMotion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__restartMotion(struct soap *soap, const char *tag, int id, const _ns6__restartMotion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__restartMotion), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__restartMotion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__restartMotion(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__restartMotion * SOAP_FMAC4 soap_get__ns6__restartMotion(struct soap *soap, _ns6__restartMotion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__restartMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__restartMotion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__restartMotion(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__restartMotion * SOAP_FMAC4 soap_in__ns6__restartMotion(struct soap *soap, const char *tag, _ns6__restartMotion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__restartMotion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__restartMotion, sizeof(_ns6__restartMotion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__restartMotion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__restartMotion *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__restartMotion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__restartMotion, 0, sizeof(_ns6__restartMotion), 0, soap_copy__ns6__restartMotion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__restartMotion * SOAP_FMAC4 soap_instantiate__ns6__restartMotion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__restartMotion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__restartMotion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__restartMotion;
		if (size)
			*size = sizeof(_ns6__restartMotion);
		((_ns6__restartMotion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__restartMotion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__restartMotion);
		for (int i = 0; i < n; i++)
			((_ns6__restartMotion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__restartMotion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__restartMotion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__restartMotion %p -> %p\n", q, p));
	*(_ns6__restartMotion*)p = *(_ns6__restartMotion*)q;
}

void _ns6__stopMotion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns6__stopMotion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__stopMotion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__stopMotion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__stopMotion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__stopMotion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__stopMotion(struct soap *soap, const char *tag, int id, const _ns6__stopMotion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__stopMotion), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__stopMotion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__stopMotion(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__stopMotion * SOAP_FMAC4 soap_get__ns6__stopMotion(struct soap *soap, _ns6__stopMotion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__stopMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__stopMotion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__stopMotion(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__stopMotion * SOAP_FMAC4 soap_in__ns6__stopMotion(struct soap *soap, const char *tag, _ns6__stopMotion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__stopMotion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__stopMotion, sizeof(_ns6__stopMotion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__stopMotion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__stopMotion *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__stopMotion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__stopMotion, 0, sizeof(_ns6__stopMotion), 0, soap_copy__ns6__stopMotion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__stopMotion * SOAP_FMAC4 soap_instantiate__ns6__stopMotion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__stopMotion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__stopMotion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__stopMotion;
		if (size)
			*size = sizeof(_ns6__stopMotion);
		((_ns6__stopMotion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__stopMotion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__stopMotion);
		for (int i = 0; i < n; i++)
			((_ns6__stopMotion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__stopMotion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__stopMotion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__stopMotion %p -> %p\n", q, p));
	*(_ns6__stopMotion*)p = *(_ns6__stopMotion*)q;
}

void _ns6__motionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__MotionReturnCode(soap, &this->_ns6__motionResponse::motRet);
	/* transient soap skipped */
}

void _ns6__motionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__motionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__motionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__motionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__motionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__motionResponse(struct soap *soap, const char *tag, int id, const _ns6__motionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__motionResponse), type))
		return soap->error;
	if (soap_out_ns6__MotionReturnCode(soap, "motRet", -1, &(a->_ns6__motionResponse::motRet), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__motionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__motionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__motionResponse * SOAP_FMAC4 soap_get__ns6__motionResponse(struct soap *soap, _ns6__motionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__motionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__motionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__motionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__motionResponse * SOAP_FMAC4 soap_in__ns6__motionResponse(struct soap *soap, const char *tag, _ns6__motionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__motionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__motionResponse, sizeof(_ns6__motionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__motionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__motionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_motRet1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_motRet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__MotionReturnCode(soap, "motRet", &(a->_ns6__motionResponse::motRet), "ns6:MotionReturnCode"))
				{	soap_flag_motRet1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__motionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__motionResponse, 0, sizeof(_ns6__motionResponse), 0, soap_copy__ns6__motionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_motRet1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__motionResponse * SOAP_FMAC4 soap_instantiate__ns6__motionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__motionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__motionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__motionResponse;
		if (size)
			*size = sizeof(_ns6__motionResponse);
		((_ns6__motionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__motionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__motionResponse);
		for (int i = 0; i < n; i++)
			((_ns6__motionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__motionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__motionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__motionResponse %p -> %p\n", q, p));
	*(_ns6__motionResponse*)p = *(_ns6__motionResponse*)q;
}

void _ns6__resetMotion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns6__resetMotion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__resetMotion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__resetMotion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__resetMotion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__resetMotion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__resetMotion(struct soap *soap, const char *tag, int id, const _ns6__resetMotion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__resetMotion), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__resetMotion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__resetMotion(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__resetMotion * SOAP_FMAC4 soap_get__ns6__resetMotion(struct soap *soap, _ns6__resetMotion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__resetMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__resetMotion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__resetMotion(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__resetMotion * SOAP_FMAC4 soap_in__ns6__resetMotion(struct soap *soap, const char *tag, _ns6__resetMotion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__resetMotion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__resetMotion, sizeof(_ns6__resetMotion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__resetMotion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__resetMotion *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__resetMotion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__resetMotion, 0, sizeof(_ns6__resetMotion), 0, soap_copy__ns6__resetMotion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__resetMotion * SOAP_FMAC4 soap_instantiate__ns6__resetMotion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__resetMotion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__resetMotion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__resetMotion;
		if (size)
			*size = sizeof(_ns6__resetMotion);
		((_ns6__resetMotion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__resetMotion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__resetMotion);
		for (int i = 0; i < n; i++)
			((_ns6__resetMotion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__resetMotion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__resetMotion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__resetMotion %p -> %p\n", q, p));
	*(_ns6__resetMotion*)p = *(_ns6__resetMotion*)q;
}

void _ns6__moveC::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns6__moveC::robot);
	this->_ns6__moveC::frameB = NULL;
	this->_ns6__moveC::frameC = NULL;
	this->_ns6__moveC::mdesc = NULL;
	/* transient soap skipped */
}

void _ns6__moveC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__Frame(soap, &this->_ns6__moveC::frameB);
	soap_serialize_PointerTons6__Frame(soap, &this->_ns6__moveC::frameC);
	soap_serialize_PointerTons6__MotionDesc(soap, &this->_ns6__moveC::mdesc);
	/* transient soap skipped */
}

int _ns6__moveC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__moveC);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__moveC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__moveC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__moveC(struct soap *soap, const char *tag, int id, const _ns6__moveC *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__moveC), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns6__moveC::robot), ""))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "frameB", -1, &(a->_ns6__moveC::frameB), ""))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "frameC", -1, &(a->_ns6__moveC::frameC), ""))
		return soap->error;
	if (soap_out_PointerTons6__MotionDesc(soap, "mdesc", -1, &(a->_ns6__moveC::mdesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__moveC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__moveC(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__moveC * SOAP_FMAC4 soap_get__ns6__moveC(struct soap *soap, _ns6__moveC *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__moveC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__moveC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__moveC(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__moveC * SOAP_FMAC4 soap_in__ns6__moveC(struct soap *soap, const char *tag, _ns6__moveC *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__moveC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__moveC, sizeof(_ns6__moveC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__moveC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__moveC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_frameB1 = 1;
	size_t soap_flag_frameC1 = 1;
	size_t soap_flag_mdesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns6__moveC::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_frameB1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "frameB", &(a->_ns6__moveC::frameB), "ns6:Frame"))
				{	soap_flag_frameB1--;
					continue;
				}
			if (soap_flag_frameC1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "frameC", &(a->_ns6__moveC::frameC), "ns6:Frame"))
				{	soap_flag_frameC1--;
					continue;
				}
			if (soap_flag_mdesc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__MotionDesc(soap, "mdesc", &(a->_ns6__moveC::mdesc), "ns6:MotionDesc"))
				{	soap_flag_mdesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__moveC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__moveC, 0, sizeof(_ns6__moveC), 0, soap_copy__ns6__moveC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_frameB1 > 0 || soap_flag_frameC1 > 0 || soap_flag_mdesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__moveC * SOAP_FMAC4 soap_instantiate__ns6__moveC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__moveC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__moveC, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__moveC;
		if (size)
			*size = sizeof(_ns6__moveC);
		((_ns6__moveC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__moveC[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__moveC);
		for (int i = 0; i < n; i++)
			((_ns6__moveC*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__moveC*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__moveC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__moveC %p -> %p\n", q, p));
	*(_ns6__moveC*)p = *(_ns6__moveC*)q;
}

void _ns6__moveL::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns6__moveL::robot);
	this->_ns6__moveL::frame = NULL;
	this->_ns6__moveL::mdesc = NULL;
	/* transient soap skipped */
}

void _ns6__moveL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__Frame(soap, &this->_ns6__moveL::frame);
	soap_serialize_PointerTons6__MotionDesc(soap, &this->_ns6__moveL::mdesc);
	/* transient soap skipped */
}

int _ns6__moveL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__moveL);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__moveL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__moveL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__moveL(struct soap *soap, const char *tag, int id, const _ns6__moveL *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__moveL), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns6__moveL::robot), ""))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "frame", -1, &(a->_ns6__moveL::frame), ""))
		return soap->error;
	if (soap_out_PointerTons6__MotionDesc(soap, "mdesc", -1, &(a->_ns6__moveL::mdesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__moveL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__moveL(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__moveL * SOAP_FMAC4 soap_get__ns6__moveL(struct soap *soap, _ns6__moveL *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__moveL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__moveL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__moveL(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__moveL * SOAP_FMAC4 soap_in__ns6__moveL(struct soap *soap, const char *tag, _ns6__moveL *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__moveL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__moveL, sizeof(_ns6__moveL), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__moveL)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__moveL *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_frame1 = 1;
	size_t soap_flag_mdesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns6__moveL::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_frame1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "frame", &(a->_ns6__moveL::frame), "ns6:Frame"))
				{	soap_flag_frame1--;
					continue;
				}
			if (soap_flag_mdesc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__MotionDesc(soap, "mdesc", &(a->_ns6__moveL::mdesc), "ns6:MotionDesc"))
				{	soap_flag_mdesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__moveL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__moveL, 0, sizeof(_ns6__moveL), 0, soap_copy__ns6__moveL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_frame1 > 0 || soap_flag_mdesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__moveL * SOAP_FMAC4 soap_instantiate__ns6__moveL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__moveL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__moveL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__moveL;
		if (size)
			*size = sizeof(_ns6__moveL);
		((_ns6__moveL*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__moveL[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__moveL);
		for (int i = 0; i < n; i++)
			((_ns6__moveL*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__moveL*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__moveL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__moveL %p -> %p\n", q, p));
	*(_ns6__moveL*)p = *(_ns6__moveL*)q;
}

void _ns6__moveJC::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns6__moveJC::robot);
	this->_ns6__moveJC::frame = NULL;
	this->_ns6__moveJC::mdesc = NULL;
	/* transient soap skipped */
}

void _ns6__moveJC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__Frame(soap, &this->_ns6__moveJC::frame);
	soap_serialize_PointerTons6__MotionDesc(soap, &this->_ns6__moveJC::mdesc);
	/* transient soap skipped */
}

int _ns6__moveJC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__moveJC);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__moveJC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__moveJC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__moveJC(struct soap *soap, const char *tag, int id, const _ns6__moveJC *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__moveJC), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns6__moveJC::robot), ""))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "frame", -1, &(a->_ns6__moveJC::frame), ""))
		return soap->error;
	if (soap_out_PointerTons6__MotionDesc(soap, "mdesc", -1, &(a->_ns6__moveJC::mdesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__moveJC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__moveJC(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__moveJC * SOAP_FMAC4 soap_get__ns6__moveJC(struct soap *soap, _ns6__moveJC *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__moveJC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__moveJC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__moveJC(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__moveJC * SOAP_FMAC4 soap_in__ns6__moveJC(struct soap *soap, const char *tag, _ns6__moveJC *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__moveJC *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__moveJC, sizeof(_ns6__moveJC), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__moveJC)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__moveJC *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_frame1 = 1;
	size_t soap_flag_mdesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns6__moveJC::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_frame1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "frame", &(a->_ns6__moveJC::frame), "ns6:Frame"))
				{	soap_flag_frame1--;
					continue;
				}
			if (soap_flag_mdesc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__MotionDesc(soap, "mdesc", &(a->_ns6__moveJC::mdesc), "ns6:MotionDesc"))
				{	soap_flag_mdesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__moveJC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__moveJC, 0, sizeof(_ns6__moveJC), 0, soap_copy__ns6__moveJC);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_frame1 > 0 || soap_flag_mdesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__moveJC * SOAP_FMAC4 soap_instantiate__ns6__moveJC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__moveJC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__moveJC, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__moveJC;
		if (size)
			*size = sizeof(_ns6__moveJC);
		((_ns6__moveJC*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__moveJC[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__moveJC);
		for (int i = 0; i < n; i++)
			((_ns6__moveJC*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__moveJC*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__moveJC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__moveJC %p -> %p\n", q, p));
	*(_ns6__moveJC*)p = *(_ns6__moveJC*)q;
}

void _ns6__moveResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns6__moveResponse::id);
	soap_default_ns6__MotionReturnCode(soap, &this->_ns6__moveResponse::motRet);
	/* transient soap skipped */
}

void _ns6__moveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns6__moveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__moveResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__moveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__moveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__moveResponse(struct soap *soap, const char *tag, int id, const _ns6__moveResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__moveResponse), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->_ns6__moveResponse::id), ""))
		return soap->error;
	if (soap_out_ns6__MotionReturnCode(soap, "motRet", -1, &(a->_ns6__moveResponse::motRet), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__moveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__moveResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__moveResponse * SOAP_FMAC4 soap_get__ns6__moveResponse(struct soap *soap, _ns6__moveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__moveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__moveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__moveResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__moveResponse * SOAP_FMAC4 soap_in__ns6__moveResponse(struct soap *soap, const char *tag, _ns6__moveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__moveResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__moveResponse, sizeof(_ns6__moveResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__moveResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__moveResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_motRet1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->_ns6__moveResponse::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_motRet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__MotionReturnCode(soap, "motRet", &(a->_ns6__moveResponse::motRet), "ns6:MotionReturnCode"))
				{	soap_flag_motRet1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__moveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__moveResponse, 0, sizeof(_ns6__moveResponse), 0, soap_copy__ns6__moveResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_motRet1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__moveResponse * SOAP_FMAC4 soap_instantiate__ns6__moveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__moveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__moveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__moveResponse;
		if (size)
			*size = sizeof(_ns6__moveResponse);
		((_ns6__moveResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__moveResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__moveResponse);
		for (int i = 0; i < n; i++)
			((_ns6__moveResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__moveResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__moveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__moveResponse %p -> %p\n", q, p));
	*(_ns6__moveResponse*)p = *(_ns6__moveResponse*)q;
}

void _ns6__moveJJ::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns6__moveJJ::robot);
	this->_ns6__moveJJ::joint = NULL;
	this->_ns6__moveJJ::mdesc = NULL;
	/* transient soap skipped */
}

void _ns6__moveJJ::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns6__moveJJ::joint);
	soap_serialize_PointerTons6__MotionDesc(soap, &this->_ns6__moveJJ::mdesc);
	/* transient soap skipped */
}

int _ns6__moveJJ::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__moveJJ);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__moveJJ::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__moveJJ(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__moveJJ(struct soap *soap, const char *tag, int id, const _ns6__moveJJ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__moveJJ), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns6__moveJJ::robot), ""))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "joint", -1, &(a->_ns6__moveJJ::joint), ""))
		return soap->error;
	if (soap_out_PointerTons6__MotionDesc(soap, "mdesc", -1, &(a->_ns6__moveJJ::mdesc), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__moveJJ::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__moveJJ(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__moveJJ * SOAP_FMAC4 soap_get__ns6__moveJJ(struct soap *soap, _ns6__moveJJ *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__moveJJ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__moveJJ::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__moveJJ(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__moveJJ * SOAP_FMAC4 soap_in__ns6__moveJJ(struct soap *soap, const char *tag, _ns6__moveJJ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__moveJJ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__moveJJ, sizeof(_ns6__moveJJ), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__moveJJ)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__moveJJ *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_joint1 = 1;
	size_t soap_flag_mdesc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns6__moveJJ::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_joint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "joint", &(a->_ns6__moveJJ::joint), "ns1:JointPos"))
				{	soap_flag_joint1--;
					continue;
				}
			if (soap_flag_mdesc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__MotionDesc(soap, "mdesc", &(a->_ns6__moveJJ::mdesc), "ns6:MotionDesc"))
				{	soap_flag_mdesc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__moveJJ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__moveJJ, 0, sizeof(_ns6__moveJJ), 0, soap_copy__ns6__moveJJ);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_joint1 > 0 || soap_flag_mdesc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__moveJJ * SOAP_FMAC4 soap_instantiate__ns6__moveJJ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__moveJJ(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__moveJJ, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__moveJJ;
		if (size)
			*size = sizeof(_ns6__moveJJ);
		((_ns6__moveJJ*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__moveJJ[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__moveJJ);
		for (int i = 0; i < n; i++)
			((_ns6__moveJJ*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__moveJJ*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__moveJJ(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__moveJJ %p -> %p\n", q, p));
	*(_ns6__moveJJ*)p = *(_ns6__moveJJ*)q;
}

void _ns6__reverseKinResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns6__reverseKinResponse::jointOut = NULL;
	soap_default_ns6__ReversingResult(soap, &this->_ns6__reverseKinResponse::reversingResult);
	/* transient soap skipped */
}

void _ns6__reverseKinResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns6__reverseKinResponse::jointOut);
	/* transient soap skipped */
}

int _ns6__reverseKinResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__reverseKinResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__reverseKinResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__reverseKinResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__reverseKinResponse(struct soap *soap, const char *tag, int id, const _ns6__reverseKinResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__reverseKinResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "jointOut", -1, &(a->_ns6__reverseKinResponse::jointOut), ""))
		return soap->error;
	if (soap_out_ns6__ReversingResult(soap, "reversingResult", -1, &(a->_ns6__reverseKinResponse::reversingResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__reverseKinResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__reverseKinResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__reverseKinResponse * SOAP_FMAC4 soap_get__ns6__reverseKinResponse(struct soap *soap, _ns6__reverseKinResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__reverseKinResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__reverseKinResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__reverseKinResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__reverseKinResponse * SOAP_FMAC4 soap_in__ns6__reverseKinResponse(struct soap *soap, const char *tag, _ns6__reverseKinResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__reverseKinResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__reverseKinResponse, sizeof(_ns6__reverseKinResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__reverseKinResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__reverseKinResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jointOut1 = 1;
	size_t soap_flag_reversingResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jointOut1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "jointOut", &(a->_ns6__reverseKinResponse::jointOut), "ns1:JointPos"))
				{	soap_flag_jointOut1--;
					continue;
				}
			if (soap_flag_reversingResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__ReversingResult(soap, "reversingResult", &(a->_ns6__reverseKinResponse::reversingResult), "ns6:ReversingResult"))
				{	soap_flag_reversingResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__reverseKinResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__reverseKinResponse, 0, sizeof(_ns6__reverseKinResponse), 0, soap_copy__ns6__reverseKinResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jointOut1 > 0 || soap_flag_reversingResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__reverseKinResponse * SOAP_FMAC4 soap_instantiate__ns6__reverseKinResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__reverseKinResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__reverseKinResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__reverseKinResponse;
		if (size)
			*size = sizeof(_ns6__reverseKinResponse);
		((_ns6__reverseKinResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__reverseKinResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__reverseKinResponse);
		for (int i = 0; i < n; i++)
			((_ns6__reverseKinResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__reverseKinResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__reverseKinResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__reverseKinResponse %p -> %p\n", q, p));
	*(_ns6__reverseKinResponse*)p = *(_ns6__reverseKinResponse*)q;
}

void _ns6__reverseKin::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns6__reverseKin::robot);
	this->_ns6__reverseKin::jointIn = NULL;
	this->_ns6__reverseKin::target = NULL;
	this->_ns6__reverseKin::config = NULL;
	this->_ns6__reverseKin::jointRange = NULL;
	/* transient soap skipped */
}

void _ns6__reverseKin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns6__reverseKin::jointIn);
	soap_serialize_PointerTons6__Frame(soap, &this->_ns6__reverseKin::target);
	soap_serialize_PointerTons6__Config(soap, &this->_ns6__reverseKin::config);
	soap_serialize_PointerTons2__JointRange(soap, &this->_ns6__reverseKin::jointRange);
	/* transient soap skipped */
}

int _ns6__reverseKin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__reverseKin);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__reverseKin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__reverseKin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__reverseKin(struct soap *soap, const char *tag, int id, const _ns6__reverseKin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__reverseKin), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns6__reverseKin::robot), ""))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "jointIn", -1, &(a->_ns6__reverseKin::jointIn), ""))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "target", -1, &(a->_ns6__reverseKin::target), ""))
		return soap->error;
	if (soap_out_PointerTons6__Config(soap, "config", -1, &(a->_ns6__reverseKin::config), ""))
		return soap->error;
	if (soap_out_PointerTons2__JointRange(soap, "jointRange", -1, &(a->_ns6__reverseKin::jointRange), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__reverseKin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__reverseKin(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__reverseKin * SOAP_FMAC4 soap_get__ns6__reverseKin(struct soap *soap, _ns6__reverseKin *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__reverseKin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__reverseKin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__reverseKin(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__reverseKin * SOAP_FMAC4 soap_in__ns6__reverseKin(struct soap *soap, const char *tag, _ns6__reverseKin *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__reverseKin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__reverseKin, sizeof(_ns6__reverseKin), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__reverseKin)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__reverseKin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_jointIn1 = 1;
	size_t soap_flag_target1 = 1;
	size_t soap_flag_config1 = 1;
	size_t soap_flag_jointRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns6__reverseKin::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_jointIn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "jointIn", &(a->_ns6__reverseKin::jointIn), "ns1:JointPos"))
				{	soap_flag_jointIn1--;
					continue;
				}
			if (soap_flag_target1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "target", &(a->_ns6__reverseKin::target), "ns6:Frame"))
				{	soap_flag_target1--;
					continue;
				}
			if (soap_flag_config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Config(soap, "config", &(a->_ns6__reverseKin::config), "ns6:Config"))
				{	soap_flag_config1--;
					continue;
				}
			if (soap_flag_jointRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__JointRange(soap, "jointRange", &(a->_ns6__reverseKin::jointRange), "ns2:JointRange"))
				{	soap_flag_jointRange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__reverseKin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__reverseKin, 0, sizeof(_ns6__reverseKin), 0, soap_copy__ns6__reverseKin);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_jointIn1 > 0 || soap_flag_target1 > 0 || soap_flag_config1 > 0 || soap_flag_jointRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__reverseKin * SOAP_FMAC4 soap_instantiate__ns6__reverseKin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__reverseKin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__reverseKin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__reverseKin;
		if (size)
			*size = sizeof(_ns6__reverseKin);
		((_ns6__reverseKin*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__reverseKin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__reverseKin);
		for (int i = 0; i < n; i++)
			((_ns6__reverseKin*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__reverseKin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__reverseKin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__reverseKin %p -> %p\n", q, p));
	*(_ns6__reverseKin*)p = *(_ns6__reverseKin*)q;
}

void _ns6__forwardKinResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns6__forwardKinResponse::position = NULL;
	this->_ns6__forwardKinResponse::config = NULL;
	/* transient soap skipped */
}

void _ns6__forwardKinResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__Frame(soap, &this->_ns6__forwardKinResponse::position);
	soap_serialize_PointerTons6__Config(soap, &this->_ns6__forwardKinResponse::config);
	/* transient soap skipped */
}

int _ns6__forwardKinResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__forwardKinResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__forwardKinResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__forwardKinResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__forwardKinResponse(struct soap *soap, const char *tag, int id, const _ns6__forwardKinResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__forwardKinResponse), type))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "position", -1, &(a->_ns6__forwardKinResponse::position), ""))
		return soap->error;
	if (soap_out_PointerTons6__Config(soap, "config", -1, &(a->_ns6__forwardKinResponse::config), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__forwardKinResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__forwardKinResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__forwardKinResponse * SOAP_FMAC4 soap_get__ns6__forwardKinResponse(struct soap *soap, _ns6__forwardKinResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__forwardKinResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__forwardKinResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__forwardKinResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__forwardKinResponse * SOAP_FMAC4 soap_in__ns6__forwardKinResponse(struct soap *soap, const char *tag, _ns6__forwardKinResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__forwardKinResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__forwardKinResponse, sizeof(_ns6__forwardKinResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__forwardKinResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__forwardKinResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_position1 = 1;
	size_t soap_flag_config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "position", &(a->_ns6__forwardKinResponse::position), "ns6:Frame"))
				{	soap_flag_position1--;
					continue;
				}
			if (soap_flag_config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Config(soap, "config", &(a->_ns6__forwardKinResponse::config), "ns6:Config"))
				{	soap_flag_config1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__forwardKinResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__forwardKinResponse, 0, sizeof(_ns6__forwardKinResponse), 0, soap_copy__ns6__forwardKinResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_position1 > 0 || soap_flag_config1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__forwardKinResponse * SOAP_FMAC4 soap_instantiate__ns6__forwardKinResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__forwardKinResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__forwardKinResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__forwardKinResponse;
		if (size)
			*size = sizeof(_ns6__forwardKinResponse);
		((_ns6__forwardKinResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__forwardKinResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__forwardKinResponse);
		for (int i = 0; i < n; i++)
			((_ns6__forwardKinResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__forwardKinResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__forwardKinResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__forwardKinResponse %p -> %p\n", q, p));
	*(_ns6__forwardKinResponse*)p = *(_ns6__forwardKinResponse*)q;
}

void _ns6__forwardKin::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns6__forwardKin::robot);
	this->_ns6__forwardKin::joint = NULL;
	/* transient soap skipped */
}

void _ns6__forwardKin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns6__forwardKin::joint);
	/* transient soap skipped */
}

int _ns6__forwardKin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns6__forwardKin);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns6__forwardKin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns6__forwardKin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__forwardKin(struct soap *soap, const char *tag, int id, const _ns6__forwardKin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns6__forwardKin), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns6__forwardKin::robot), ""))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "joint", -1, &(a->_ns6__forwardKin::joint), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns6__forwardKin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns6__forwardKin(soap, this, tag, type);
}

SOAP_FMAC3 _ns6__forwardKin * SOAP_FMAC4 soap_get__ns6__forwardKin(struct soap *soap, _ns6__forwardKin *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns6__forwardKin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns6__forwardKin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns6__forwardKin(soap, tag, this, type);
}

SOAP_FMAC3 _ns6__forwardKin * SOAP_FMAC4 soap_in__ns6__forwardKin(struct soap *soap, const char *tag, _ns6__forwardKin *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns6__forwardKin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns6__forwardKin, sizeof(_ns6__forwardKin), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns6__forwardKin)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns6__forwardKin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_joint1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns6__forwardKin::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_joint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "joint", &(a->_ns6__forwardKin::joint), "ns1:JointPos"))
				{	soap_flag_joint1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns6__forwardKin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns6__forwardKin, 0, sizeof(_ns6__forwardKin), 0, soap_copy__ns6__forwardKin);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_joint1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns6__forwardKin * SOAP_FMAC4 soap_instantiate__ns6__forwardKin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns6__forwardKin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns6__forwardKin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns6__forwardKin;
		if (size)
			*size = sizeof(_ns6__forwardKin);
		((_ns6__forwardKin*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns6__forwardKin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns6__forwardKin);
		for (int i = 0; i < n; i++)
			((_ns6__forwardKin*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns6__forwardKin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns6__forwardKin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns6__forwardKin %p -> %p\n", q, p));
	*(_ns6__forwardKin*)p = *(_ns6__forwardKin*)q;
}

void ns6__AllRobotsPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__RobotPos(soap, &this->ns6__AllRobotsPos::RobotsPos);
	/* transient soap skipped */
}

void ns6__AllRobotsPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__RobotPos(soap, &this->ns6__AllRobotsPos::RobotsPos);
	/* transient soap skipped */
}

int ns6__AllRobotsPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__AllRobotsPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__AllRobotsPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AllRobotsPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AllRobotsPos(struct soap *soap, const char *tag, int id, const ns6__AllRobotsPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AllRobotsPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__RobotPos(soap, "RobotsPos", -1, &(a->ns6__AllRobotsPos::RobotsPos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__AllRobotsPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AllRobotsPos(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AllRobotsPos * SOAP_FMAC4 soap_get_ns6__AllRobotsPos(struct soap *soap, ns6__AllRobotsPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AllRobotsPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__AllRobotsPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__AllRobotsPos(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AllRobotsPos * SOAP_FMAC4 soap_in_ns6__AllRobotsPos(struct soap *soap, const char *tag, ns6__AllRobotsPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__AllRobotsPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AllRobotsPos, sizeof(ns6__AllRobotsPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__AllRobotsPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__AllRobotsPos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__RobotPos(soap, "RobotsPos", &(a->ns6__AllRobotsPos::RobotsPos), "ns6:RobotPos"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__AllRobotsPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AllRobotsPos, 0, sizeof(ns6__AllRobotsPos), 0, soap_copy_ns6__AllRobotsPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__AllRobotsPos * SOAP_FMAC4 soap_instantiate_ns6__AllRobotsPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AllRobotsPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__AllRobotsPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__AllRobotsPos;
		if (size)
			*size = sizeof(ns6__AllRobotsPos);
		((ns6__AllRobotsPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__AllRobotsPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__AllRobotsPos);
		for (int i = 0; i < n; i++)
			((ns6__AllRobotsPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__AllRobotsPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__AllRobotsPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__AllRobotsPos %p -> %p\n", q, p));
	*(ns6__AllRobotsPos*)p = *(ns6__AllRobotsPos*)q;
}

void ns6__RobotPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns6__RobotPos::settled);
	this->ns6__RobotPos::joint = NULL;
	this->ns6__RobotPos::position = NULL;
	this->ns6__RobotPos::config = NULL;
	/* transient soap skipped */
}

void ns6__RobotPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->ns6__RobotPos::joint);
	soap_serialize_PointerTons6__Frame(soap, &this->ns6__RobotPos::position);
	soap_serialize_PointerTons6__Config(soap, &this->ns6__RobotPos::config);
	/* transient soap skipped */
}

int ns6__RobotPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RobotPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__RobotPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RobotPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RobotPos(struct soap *soap, const char *tag, int id, const ns6__RobotPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RobotPos), type))
		return soap->error;
	if (soap_out_bool(soap, "settled", -1, &(a->ns6__RobotPos::settled), ""))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "joint", -1, &(a->ns6__RobotPos::joint), ""))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "position", -1, &(a->ns6__RobotPos::position), ""))
		return soap->error;
	if (soap_out_PointerTons6__Config(soap, "config", -1, &(a->ns6__RobotPos::config), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__RobotPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RobotPos(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RobotPos * SOAP_FMAC4 soap_get_ns6__RobotPos(struct soap *soap, ns6__RobotPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RobotPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__RobotPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__RobotPos(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RobotPos * SOAP_FMAC4 soap_in_ns6__RobotPos(struct soap *soap, const char *tag, ns6__RobotPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RobotPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RobotPos, sizeof(ns6__RobotPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__RobotPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RobotPos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_settled1 = 1;
	size_t soap_flag_joint1 = 1;
	size_t soap_flag_position1 = 1;
	size_t soap_flag_config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_settled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "settled", &(a->ns6__RobotPos::settled), "xsd:boolean"))
				{	soap_flag_settled1--;
					continue;
				}
			if (soap_flag_joint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "joint", &(a->ns6__RobotPos::joint), "ns1:JointPos"))
				{	soap_flag_joint1--;
					continue;
				}
			if (soap_flag_position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "position", &(a->ns6__RobotPos::position), "ns6:Frame"))
				{	soap_flag_position1--;
					continue;
				}
			if (soap_flag_config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Config(soap, "config", &(a->ns6__RobotPos::config), "ns6:Config"))
				{	soap_flag_config1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__RobotPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__RobotPos, 0, sizeof(ns6__RobotPos), 0, soap_copy_ns6__RobotPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_settled1 > 0 || soap_flag_joint1 > 0 || soap_flag_position1 > 0 || soap_flag_config1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__RobotPos * SOAP_FMAC4 soap_instantiate_ns6__RobotPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RobotPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RobotPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__RobotPos;
		if (size)
			*size = sizeof(ns6__RobotPos);
		((ns6__RobotPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__RobotPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__RobotPos);
		for (int i = 0; i < n; i++)
			((ns6__RobotPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RobotPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RobotPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RobotPos %p -> %p\n", q, p));
	*(ns6__RobotPos*)p = *(ns6__RobotPos*)q;
}

void ns6__MotionDesc::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__MotionDesc::tool = NULL;
	this->ns6__MotionDesc::frame = NULL;
	soap_default_ns6__MoveType(soap, &this->ns6__MotionDesc::absRel);
	this->ns6__MotionDesc::config = NULL;
	soap_default_ns6__BlendType(soap, &this->ns6__MotionDesc::blendType);
	soap_default_double(soap, &this->ns6__MotionDesc::distBlendPrev);
	soap_default_double(soap, &this->ns6__MotionDesc::distBlendNext);
	soap_default_double(soap, &this->ns6__MotionDesc::vel);
	soap_default_double(soap, &this->ns6__MotionDesc::acc);
	soap_default_double(soap, &this->ns6__MotionDesc::dec);
	soap_default_double(soap, &this->ns6__MotionDesc::transVel);
	soap_default_double(soap, &this->ns6__MotionDesc::rotVel);
	soap_default_double(soap, &this->ns6__MotionDesc::freq);
	/* transient soap skipped */
}

void ns6__MotionDesc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__Frame(soap, &this->ns6__MotionDesc::tool);
	soap_serialize_PointerTons6__Frame(soap, &this->ns6__MotionDesc::frame);
	soap_serialize_PointerTons6__Config(soap, &this->ns6__MotionDesc::config);
	/* transient soap skipped */
}

int ns6__MotionDesc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__MotionDesc);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__MotionDesc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__MotionDesc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__MotionDesc(struct soap *soap, const char *tag, int id, const ns6__MotionDesc *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__MotionDesc), type))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "tool", -1, &(a->ns6__MotionDesc::tool), ""))
		return soap->error;
	if (soap_out_PointerTons6__Frame(soap, "frame", -1, &(a->ns6__MotionDesc::frame), ""))
		return soap->error;
	if (soap_out_ns6__MoveType(soap, "absRel", -1, &(a->ns6__MotionDesc::absRel), ""))
		return soap->error;
	if (soap_out_PointerTons6__Config(soap, "config", -1, &(a->ns6__MotionDesc::config), ""))
		return soap->error;
	if (soap_out_ns6__BlendType(soap, "blendType", -1, &(a->ns6__MotionDesc::blendType), ""))
		return soap->error;
	if (soap_out_double(soap, "distBlendPrev", -1, &(a->ns6__MotionDesc::distBlendPrev), ""))
		return soap->error;
	if (soap_out_double(soap, "distBlendNext", -1, &(a->ns6__MotionDesc::distBlendNext), ""))
		return soap->error;
	if (soap_out_double(soap, "vel", -1, &(a->ns6__MotionDesc::vel), ""))
		return soap->error;
	if (soap_out_double(soap, "acc", -1, &(a->ns6__MotionDesc::acc), ""))
		return soap->error;
	if (soap_out_double(soap, "dec", -1, &(a->ns6__MotionDesc::dec), ""))
		return soap->error;
	if (soap_out_double(soap, "transVel", -1, &(a->ns6__MotionDesc::transVel), ""))
		return soap->error;
	if (soap_out_double(soap, "rotVel", -1, &(a->ns6__MotionDesc::rotVel), ""))
		return soap->error;
	if (soap_out_double(soap, "freq", -1, &(a->ns6__MotionDesc::freq), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__MotionDesc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__MotionDesc(soap, this, tag, type);
}

SOAP_FMAC3 ns6__MotionDesc * SOAP_FMAC4 soap_get_ns6__MotionDesc(struct soap *soap, ns6__MotionDesc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__MotionDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__MotionDesc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__MotionDesc(soap, tag, this, type);
}

SOAP_FMAC3 ns6__MotionDesc * SOAP_FMAC4 soap_in_ns6__MotionDesc(struct soap *soap, const char *tag, ns6__MotionDesc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__MotionDesc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__MotionDesc, sizeof(ns6__MotionDesc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__MotionDesc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__MotionDesc *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tool1 = 1;
	size_t soap_flag_frame1 = 1;
	size_t soap_flag_absRel1 = 1;
	size_t soap_flag_config1 = 1;
	size_t soap_flag_blendType1 = 1;
	size_t soap_flag_distBlendPrev1 = 1;
	size_t soap_flag_distBlendNext1 = 1;
	size_t soap_flag_vel1 = 1;
	size_t soap_flag_acc1 = 1;
	size_t soap_flag_dec1 = 1;
	size_t soap_flag_transVel1 = 1;
	size_t soap_flag_rotVel1 = 1;
	size_t soap_flag_freq1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tool1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "tool", &(a->ns6__MotionDesc::tool), "ns6:Frame"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_frame1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Frame(soap, "frame", &(a->ns6__MotionDesc::frame), "ns6:Frame"))
				{	soap_flag_frame1--;
					continue;
				}
			if (soap_flag_absRel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__MoveType(soap, "absRel", &(a->ns6__MotionDesc::absRel), "ns6:MoveType"))
				{	soap_flag_absRel1--;
					continue;
				}
			if (soap_flag_config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__Config(soap, "config", &(a->ns6__MotionDesc::config), "ns6:Config"))
				{	soap_flag_config1--;
					continue;
				}
			if (soap_flag_blendType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__BlendType(soap, "blendType", &(a->ns6__MotionDesc::blendType), "ns6:BlendType"))
				{	soap_flag_blendType1--;
					continue;
				}
			if (soap_flag_distBlendPrev1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "distBlendPrev", &(a->ns6__MotionDesc::distBlendPrev), "xsd:double"))
				{	soap_flag_distBlendPrev1--;
					continue;
				}
			if (soap_flag_distBlendNext1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "distBlendNext", &(a->ns6__MotionDesc::distBlendNext), "xsd:double"))
				{	soap_flag_distBlendNext1--;
					continue;
				}
			if (soap_flag_vel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "vel", &(a->ns6__MotionDesc::vel), "xsd:double"))
				{	soap_flag_vel1--;
					continue;
				}
			if (soap_flag_acc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "acc", &(a->ns6__MotionDesc::acc), "xsd:double"))
				{	soap_flag_acc1--;
					continue;
				}
			if (soap_flag_dec1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "dec", &(a->ns6__MotionDesc::dec), "xsd:double"))
				{	soap_flag_dec1--;
					continue;
				}
			if (soap_flag_transVel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "transVel", &(a->ns6__MotionDesc::transVel), "xsd:double"))
				{	soap_flag_transVel1--;
					continue;
				}
			if (soap_flag_rotVel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "rotVel", &(a->ns6__MotionDesc::rotVel), "xsd:double"))
				{	soap_flag_rotVel1--;
					continue;
				}
			if (soap_flag_freq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "freq", &(a->ns6__MotionDesc::freq), "xsd:double"))
				{	soap_flag_freq1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__MotionDesc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__MotionDesc, 0, sizeof(ns6__MotionDesc), 0, soap_copy_ns6__MotionDesc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tool1 > 0 || soap_flag_frame1 > 0 || soap_flag_absRel1 > 0 || soap_flag_config1 > 0 || soap_flag_blendType1 > 0 || soap_flag_distBlendPrev1 > 0 || soap_flag_distBlendNext1 > 0 || soap_flag_vel1 > 0 || soap_flag_acc1 > 0 || soap_flag_dec1 > 0 || soap_flag_transVel1 > 0 || soap_flag_rotVel1 > 0 || soap_flag_freq1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__MotionDesc * SOAP_FMAC4 soap_instantiate_ns6__MotionDesc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__MotionDesc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__MotionDesc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__MotionDesc;
		if (size)
			*size = sizeof(ns6__MotionDesc);
		((ns6__MotionDesc*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__MotionDesc[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__MotionDesc);
		for (int i = 0; i < n; i++)
			((ns6__MotionDesc*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__MotionDesc*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__MotionDesc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__MotionDesc %p -> %p\n", q, p));
	*(ns6__MotionDesc*)p = *(ns6__MotionDesc*)q;
}

void ns6__Config::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__Config::__union_Config = 0;
	/* transient soap skipped */
}

void ns6__Config::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns6__union_Config(soap, this->ns6__Config::__union_Config, &this->ns6__Config::union_Config);
	/* transient soap skipped */
}

int ns6__Config::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Config);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Config::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Config(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Config(struct soap *soap, const char *tag, int id, const ns6__Config *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Config), type))
		return soap->error;
	if (soap_out__ns6__union_Config(soap, a->ns6__Config::__union_Config, &a->ns6__Config::union_Config))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Config::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Config(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Config * SOAP_FMAC4 soap_get_ns6__Config(struct soap *soap, ns6__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Config::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Config(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Config * SOAP_FMAC4 soap_in_ns6__Config(struct soap *soap, const char *tag, ns6__Config *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Config *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Config, sizeof(ns6__Config), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Config)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Config *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_union_Config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_Config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns6__union_Config(soap, &a->ns6__Config::__union_Config, &a->ns6__Config::union_Config))
				{	soap_flag_union_Config1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Config, 0, sizeof(ns6__Config), 0, soap_copy_ns6__Config);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_Config1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Config * SOAP_FMAC4 soap_instantiate_ns6__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Config(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Config, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Config;
		if (size)
			*size = sizeof(ns6__Config);
		((ns6__Config*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Config[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Config);
		for (int i = 0; i < n; i++)
			((ns6__Config*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Config*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Config(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Config %p -> %p\n", q, p));
	*(ns6__Config*)p = *(ns6__Config*)q;
}

void ns6__VrbxConfig::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__AboveBelowConfig(soap, &this->ns6__VrbxConfig::jnt1);
	soap_default_ns6__PositiveNegativeConfig(soap, &this->ns6__VrbxConfig::jnt3);
	soap_default_ns6__PositiveNegativeConfig(soap, &this->ns6__VrbxConfig::jnt5);
	/* transient soap skipped */
}

void ns6__VrbxConfig::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns6__VrbxConfig::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__VrbxConfig);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__VrbxConfig::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__VrbxConfig(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__VrbxConfig(struct soap *soap, const char *tag, int id, const ns6__VrbxConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__VrbxConfig), type))
		return soap->error;
	if (soap_out_ns6__AboveBelowConfig(soap, "jnt1", -1, &(a->ns6__VrbxConfig::jnt1), ""))
		return soap->error;
	if (soap_out_ns6__PositiveNegativeConfig(soap, "jnt3", -1, &(a->ns6__VrbxConfig::jnt3), ""))
		return soap->error;
	if (soap_out_ns6__PositiveNegativeConfig(soap, "jnt5", -1, &(a->ns6__VrbxConfig::jnt5), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__VrbxConfig::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__VrbxConfig(soap, this, tag, type);
}

SOAP_FMAC3 ns6__VrbxConfig * SOAP_FMAC4 soap_get_ns6__VrbxConfig(struct soap *soap, ns6__VrbxConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__VrbxConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__VrbxConfig::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__VrbxConfig(soap, tag, this, type);
}

SOAP_FMAC3 ns6__VrbxConfig * SOAP_FMAC4 soap_in_ns6__VrbxConfig(struct soap *soap, const char *tag, ns6__VrbxConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__VrbxConfig *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__VrbxConfig, sizeof(ns6__VrbxConfig), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__VrbxConfig)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__VrbxConfig *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jnt11 = 1;
	size_t soap_flag_jnt31 = 1;
	size_t soap_flag_jnt51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jnt11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__AboveBelowConfig(soap, "jnt1", &(a->ns6__VrbxConfig::jnt1), "ns6:AboveBelowConfig"))
				{	soap_flag_jnt11--;
					continue;
				}
			if (soap_flag_jnt31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__PositiveNegativeConfig(soap, "jnt3", &(a->ns6__VrbxConfig::jnt3), "ns6:PositiveNegativeConfig"))
				{	soap_flag_jnt31--;
					continue;
				}
			if (soap_flag_jnt51 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__PositiveNegativeConfig(soap, "jnt5", &(a->ns6__VrbxConfig::jnt5), "ns6:PositiveNegativeConfig"))
				{	soap_flag_jnt51--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__VrbxConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__VrbxConfig, 0, sizeof(ns6__VrbxConfig), 0, soap_copy_ns6__VrbxConfig);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jnt11 > 0 || soap_flag_jnt31 > 0 || soap_flag_jnt51 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__VrbxConfig * SOAP_FMAC4 soap_instantiate_ns6__VrbxConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__VrbxConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__VrbxConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__VrbxConfig;
		if (size)
			*size = sizeof(ns6__VrbxConfig);
		((ns6__VrbxConfig*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__VrbxConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__VrbxConfig);
		for (int i = 0; i < n; i++)
			((ns6__VrbxConfig*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__VrbxConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__VrbxConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__VrbxConfig %p -> %p\n", q, p));
	*(ns6__VrbxConfig*)p = *(ns6__VrbxConfig*)q;
}

void ns6__ScaraConfig::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__ShoulderConfig(soap, &this->ns6__ScaraConfig::shoulder);
	/* transient soap skipped */
}

void ns6__ScaraConfig::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns6__ScaraConfig::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ScaraConfig);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__ScaraConfig::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ScaraConfig(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ScaraConfig(struct soap *soap, const char *tag, int id, const ns6__ScaraConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ScaraConfig), type))
		return soap->error;
	if (soap_out_ns6__ShoulderConfig(soap, "shoulder", -1, &(a->ns6__ScaraConfig::shoulder), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__ScaraConfig::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ScaraConfig(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ScaraConfig * SOAP_FMAC4 soap_get_ns6__ScaraConfig(struct soap *soap, ns6__ScaraConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ScaraConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__ScaraConfig::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ScaraConfig(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ScaraConfig * SOAP_FMAC4 soap_in_ns6__ScaraConfig(struct soap *soap, const char *tag, ns6__ScaraConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ScaraConfig *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ScaraConfig, sizeof(ns6__ScaraConfig), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ScaraConfig)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ScaraConfig *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_shoulder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_shoulder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__ShoulderConfig(soap, "shoulder", &(a->ns6__ScaraConfig::shoulder), "ns6:ShoulderConfig"))
				{	soap_flag_shoulder1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ScaraConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ScaraConfig, 0, sizeof(ns6__ScaraConfig), 0, soap_copy_ns6__ScaraConfig);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_shoulder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__ScaraConfig * SOAP_FMAC4 soap_instantiate_ns6__ScaraConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ScaraConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ScaraConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__ScaraConfig;
		if (size)
			*size = sizeof(ns6__ScaraConfig);
		((ns6__ScaraConfig*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__ScaraConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ScaraConfig);
		for (int i = 0; i < n; i++)
			((ns6__ScaraConfig*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ScaraConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ScaraConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ScaraConfig %p -> %p\n", q, p));
	*(ns6__ScaraConfig*)p = *(ns6__ScaraConfig*)q;
}

void ns6__AnthroConfig::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns6__ShoulderConfig(soap, &this->ns6__AnthroConfig::shoulder);
	soap_default_ns6__PositiveNegativeConfig(soap, &this->ns6__AnthroConfig::elbow);
	soap_default_ns6__PositiveNegativeConfig(soap, &this->ns6__AnthroConfig::wrist);
	/* transient soap skipped */
}

void ns6__AnthroConfig::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns6__AnthroConfig::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__AnthroConfig);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__AnthroConfig::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AnthroConfig(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AnthroConfig(struct soap *soap, const char *tag, int id, const ns6__AnthroConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AnthroConfig), type))
		return soap->error;
	if (soap_out_ns6__ShoulderConfig(soap, "shoulder", -1, &(a->ns6__AnthroConfig::shoulder), ""))
		return soap->error;
	if (soap_out_ns6__PositiveNegativeConfig(soap, "elbow", -1, &(a->ns6__AnthroConfig::elbow), ""))
		return soap->error;
	if (soap_out_ns6__PositiveNegativeConfig(soap, "wrist", -1, &(a->ns6__AnthroConfig::wrist), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__AnthroConfig::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AnthroConfig(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AnthroConfig * SOAP_FMAC4 soap_get_ns6__AnthroConfig(struct soap *soap, ns6__AnthroConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AnthroConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__AnthroConfig::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__AnthroConfig(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AnthroConfig * SOAP_FMAC4 soap_in_ns6__AnthroConfig(struct soap *soap, const char *tag, ns6__AnthroConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__AnthroConfig *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AnthroConfig, sizeof(ns6__AnthroConfig), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__AnthroConfig)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__AnthroConfig *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_shoulder1 = 1;
	size_t soap_flag_elbow1 = 1;
	size_t soap_flag_wrist1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_shoulder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__ShoulderConfig(soap, "shoulder", &(a->ns6__AnthroConfig::shoulder), "ns6:ShoulderConfig"))
				{	soap_flag_shoulder1--;
					continue;
				}
			if (soap_flag_elbow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__PositiveNegativeConfig(soap, "elbow", &(a->ns6__AnthroConfig::elbow), "ns6:PositiveNegativeConfig"))
				{	soap_flag_elbow1--;
					continue;
				}
			if (soap_flag_wrist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__PositiveNegativeConfig(soap, "wrist", &(a->ns6__AnthroConfig::wrist), "ns6:PositiveNegativeConfig"))
				{	soap_flag_wrist1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__AnthroConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AnthroConfig, 0, sizeof(ns6__AnthroConfig), 0, soap_copy_ns6__AnthroConfig);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_shoulder1 > 0 || soap_flag_elbow1 > 0 || soap_flag_wrist1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__AnthroConfig * SOAP_FMAC4 soap_instantiate_ns6__AnthroConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AnthroConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__AnthroConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__AnthroConfig;
		if (size)
			*size = sizeof(ns6__AnthroConfig);
		((ns6__AnthroConfig*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__AnthroConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__AnthroConfig);
		for (int i = 0; i < n; i++)
			((ns6__AnthroConfig*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__AnthroConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__AnthroConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__AnthroConfig %p -> %p\n", q, p));
	*(ns6__AnthroConfig*)p = *(ns6__AnthroConfig*)q;
}

void ns6__Frame::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns6__Frame::nx);
	soap_default_double(soap, &this->ns6__Frame::ny);
	soap_default_double(soap, &this->ns6__Frame::nz);
	soap_default_double(soap, &this->ns6__Frame::ox);
	soap_default_double(soap, &this->ns6__Frame::oy);
	soap_default_double(soap, &this->ns6__Frame::oz);
	soap_default_double(soap, &this->ns6__Frame::ax);
	soap_default_double(soap, &this->ns6__Frame::ay);
	soap_default_double(soap, &this->ns6__Frame::az);
	soap_default_double(soap, &this->ns6__Frame::px);
	soap_default_double(soap, &this->ns6__Frame::py);
	soap_default_double(soap, &this->ns6__Frame::pz);
	/* transient soap skipped */
}

void ns6__Frame::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns6__Frame::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Frame);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Frame::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Frame(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Frame(struct soap *soap, const char *tag, int id, const ns6__Frame *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Frame), type))
		return soap->error;
	if (soap_out_double(soap, "nx", -1, &(a->ns6__Frame::nx), ""))
		return soap->error;
	if (soap_out_double(soap, "ny", -1, &(a->ns6__Frame::ny), ""))
		return soap->error;
	if (soap_out_double(soap, "nz", -1, &(a->ns6__Frame::nz), ""))
		return soap->error;
	if (soap_out_double(soap, "ox", -1, &(a->ns6__Frame::ox), ""))
		return soap->error;
	if (soap_out_double(soap, "oy", -1, &(a->ns6__Frame::oy), ""))
		return soap->error;
	if (soap_out_double(soap, "oz", -1, &(a->ns6__Frame::oz), ""))
		return soap->error;
	if (soap_out_double(soap, "ax", -1, &(a->ns6__Frame::ax), ""))
		return soap->error;
	if (soap_out_double(soap, "ay", -1, &(a->ns6__Frame::ay), ""))
		return soap->error;
	if (soap_out_double(soap, "az", -1, &(a->ns6__Frame::az), ""))
		return soap->error;
	if (soap_out_double(soap, "px", -1, &(a->ns6__Frame::px), ""))
		return soap->error;
	if (soap_out_double(soap, "py", -1, &(a->ns6__Frame::py), ""))
		return soap->error;
	if (soap_out_double(soap, "pz", -1, &(a->ns6__Frame::pz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Frame::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Frame(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Frame * SOAP_FMAC4 soap_get_ns6__Frame(struct soap *soap, ns6__Frame *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Frame::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Frame(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Frame * SOAP_FMAC4 soap_in_ns6__Frame(struct soap *soap, const char *tag, ns6__Frame *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Frame *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Frame, sizeof(ns6__Frame), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Frame)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Frame *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nx1 = 1;
	size_t soap_flag_ny1 = 1;
	size_t soap_flag_nz1 = 1;
	size_t soap_flag_ox1 = 1;
	size_t soap_flag_oy1 = 1;
	size_t soap_flag_oz1 = 1;
	size_t soap_flag_ax1 = 1;
	size_t soap_flag_ay1 = 1;
	size_t soap_flag_az1 = 1;
	size_t soap_flag_px1 = 1;
	size_t soap_flag_py1 = 1;
	size_t soap_flag_pz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nx", &(a->ns6__Frame::nx), "xsd:double"))
				{	soap_flag_nx1--;
					continue;
				}
			if (soap_flag_ny1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ny", &(a->ns6__Frame::ny), "xsd:double"))
				{	soap_flag_ny1--;
					continue;
				}
			if (soap_flag_nz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "nz", &(a->ns6__Frame::nz), "xsd:double"))
				{	soap_flag_nz1--;
					continue;
				}
			if (soap_flag_ox1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ox", &(a->ns6__Frame::ox), "xsd:double"))
				{	soap_flag_ox1--;
					continue;
				}
			if (soap_flag_oy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "oy", &(a->ns6__Frame::oy), "xsd:double"))
				{	soap_flag_oy1--;
					continue;
				}
			if (soap_flag_oz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "oz", &(a->ns6__Frame::oz), "xsd:double"))
				{	soap_flag_oz1--;
					continue;
				}
			if (soap_flag_ax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ax", &(a->ns6__Frame::ax), "xsd:double"))
				{	soap_flag_ax1--;
					continue;
				}
			if (soap_flag_ay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ay", &(a->ns6__Frame::ay), "xsd:double"))
				{	soap_flag_ay1--;
					continue;
				}
			if (soap_flag_az1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "az", &(a->ns6__Frame::az), "xsd:double"))
				{	soap_flag_az1--;
					continue;
				}
			if (soap_flag_px1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "px", &(a->ns6__Frame::px), "xsd:double"))
				{	soap_flag_px1--;
					continue;
				}
			if (soap_flag_py1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "py", &(a->ns6__Frame::py), "xsd:double"))
				{	soap_flag_py1--;
					continue;
				}
			if (soap_flag_pz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "pz", &(a->ns6__Frame::pz), "xsd:double"))
				{	soap_flag_pz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Frame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Frame, 0, sizeof(ns6__Frame), 0, soap_copy_ns6__Frame);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nx1 > 0 || soap_flag_ny1 > 0 || soap_flag_nz1 > 0 || soap_flag_ox1 > 0 || soap_flag_oy1 > 0 || soap_flag_oz1 > 0 || soap_flag_ax1 > 0 || soap_flag_ay1 > 0 || soap_flag_az1 > 0 || soap_flag_px1 > 0 || soap_flag_py1 > 0 || soap_flag_pz1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Frame * SOAP_FMAC4 soap_instantiate_ns6__Frame(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Frame(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Frame, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Frame;
		if (size)
			*size = sizeof(ns6__Frame);
		((ns6__Frame*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Frame[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Frame);
		for (int i = 0; i < n; i++)
			((ns6__Frame*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Frame*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Frame(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Frame %p -> %p\n", q, p));
	*(ns6__Frame*)p = *(ns6__Frame*)q;
}

void ns6__Records::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns6__Records::record);
	/* transient soap skipped */
}

void ns6__Records::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns6__Records::record);
	/* transient soap skipped */
}

int ns6__Records::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Records);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Records::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Records(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Records(struct soap *soap, const char *tag, int id, const ns6__Records *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Records), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "record", -1, &(a->ns6__Records::record), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Records::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Records(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Records * SOAP_FMAC4 soap_get_ns6__Records(struct soap *soap, ns6__Records *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Records::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Records(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Records * SOAP_FMAC4 soap_in_ns6__Records(struct soap *soap, const char *tag, ns6__Records *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Records *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Records, sizeof(ns6__Records), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Records)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Records *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "record", &(a->ns6__Records::record), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Records *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Records, 0, sizeof(ns6__Records), 0, soap_copy_ns6__Records);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Records * SOAP_FMAC4 soap_instantiate_ns6__Records(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Records(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Records, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Records;
		if (size)
			*size = sizeof(ns6__Records);
		((ns6__Records*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Records[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Records);
		for (int i = 0; i < n; i++)
			((ns6__Records*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Records*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Records(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Records %p -> %p\n", q, p));
	*(ns6__Records*)p = *(ns6__Records*)q;
}

void ns6__VALApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns6__VALApplications::application);
	/* transient soap skipped */
}

void ns6__VALApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns6__VALApplications::application);
	/* transient soap skipped */
}

int ns6__VALApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__VALApplications);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__VALApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__VALApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__VALApplications(struct soap *soap, const char *tag, int id, const ns6__VALApplications *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__VALApplications), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", -1, &(a->ns6__VALApplications::application), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__VALApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__VALApplications(soap, this, tag, type);
}

SOAP_FMAC3 ns6__VALApplications * SOAP_FMAC4 soap_get_ns6__VALApplications(struct soap *soap, ns6__VALApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__VALApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__VALApplications(soap, tag, this, type);
}

SOAP_FMAC3 ns6__VALApplications * SOAP_FMAC4 soap_in_ns6__VALApplications(struct soap *soap, const char *tag, ns6__VALApplications *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__VALApplications *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__VALApplications, sizeof(ns6__VALApplications), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__VALApplications)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__VALApplications *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", &(a->ns6__VALApplications::application), "ns2:VALApplication"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__VALApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__VALApplications, 0, sizeof(ns6__VALApplications), 0, soap_copy_ns6__VALApplications);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__VALApplications * SOAP_FMAC4 soap_instantiate_ns6__VALApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__VALApplications(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__VALApplications, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__VALApplications;
		if (size)
			*size = sizeof(ns6__VALApplications);
		((ns6__VALApplications*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__VALApplications[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__VALApplications);
		for (int i = 0; i < n; i++)
			((ns6__VALApplications*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__VALApplications*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__VALApplications(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__VALApplications %p -> %p\n", q, p));
	*(ns6__VALApplications*)p = *(ns6__VALApplications*)q;
}

void ns6__Robots::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns6__Robots::Robots);
	/* transient soap skipped */
}

void ns6__Robots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns6__Robots::Robots);
	/* transient soap skipped */
}

int ns6__Robots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Robots);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Robots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Robots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Robots(struct soap *soap, const char *tag, int id, const ns6__Robots *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Robots), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", -1, &(a->ns6__Robots::Robots), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Robots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Robots(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Robots * SOAP_FMAC4 soap_get_ns6__Robots(struct soap *soap, ns6__Robots *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Robots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Robots(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Robots * SOAP_FMAC4 soap_in_ns6__Robots(struct soap *soap, const char *tag, ns6__Robots *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Robots *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Robots, sizeof(ns6__Robots), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Robots)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Robots *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", &(a->ns6__Robots::Robots), "ns1:Robot"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Robots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Robots, 0, sizeof(ns6__Robots), 0, soap_copy_ns6__Robots);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Robots * SOAP_FMAC4 soap_instantiate_ns6__Robots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Robots(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Robots, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Robots;
		if (size)
			*size = sizeof(ns6__Robots);
		((ns6__Robots*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Robots[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Robots);
		for (int i = 0; i < n; i++)
			((ns6__Robots*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Robots*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Robots(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Robots %p -> %p\n", q, p));
	*(ns6__Robots*)p = *(ns6__Robots*)q;
}

void ns6__Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns6__Versions::Versions);
	/* transient soap skipped */
}

void ns6__Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns6__Versions::Versions);
	/* transient soap skipped */
}

int ns6__Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Versions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Versions(struct soap *soap, const char *tag, int id, const ns6__Versions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Versions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", -1, &(a->ns6__Versions::Versions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Versions(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Versions * SOAP_FMAC4 soap_get_ns6__Versions(struct soap *soap, ns6__Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Versions(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Versions * SOAP_FMAC4 soap_in_ns6__Versions(struct soap *soap, const char *tag, ns6__Versions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Versions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Versions, sizeof(ns6__Versions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Versions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Versions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", &(a->ns6__Versions::Versions), "ns1:Version"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Versions, 0, sizeof(ns6__Versions), 0, soap_copy_ns6__Versions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__Versions * SOAP_FMAC4 soap_instantiate_ns6__Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Versions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Versions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__Versions;
		if (size)
			*size = sizeof(ns6__Versions);
		((ns6__Versions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__Versions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Versions);
		for (int i = 0; i < n; i++)
			((ns6__Versions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Versions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Versions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Versions %p -> %p\n", q, p));
	*(ns6__Versions*)p = *(ns6__Versions*)q;
}

void ns6__JointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns6__JointPos::item);
	/* transient soap skipped */
}

void ns6__JointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns6__JointPos::item);
	/* transient soap skipped */
}

int ns6__JointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__JointPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__JointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__JointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__JointPos(struct soap *soap, const char *tag, int id, const ns6__JointPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__JointPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "item", -1, &(a->ns6__JointPos::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__JointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__JointPos(soap, this, tag, type);
}

SOAP_FMAC3 ns6__JointPos * SOAP_FMAC4 soap_get_ns6__JointPos(struct soap *soap, ns6__JointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns6__JointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__JointPos(soap, tag, this, type);
}

SOAP_FMAC3 ns6__JointPos * SOAP_FMAC4 soap_in_ns6__JointPos(struct soap *soap, const char *tag, ns6__JointPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__JointPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__JointPos, sizeof(ns6__JointPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__JointPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__JointPos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "item", &(a->ns6__JointPos::item), "xsd:double"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__JointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__JointPos, 0, sizeof(ns6__JointPos), 0, soap_copy_ns6__JointPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns6__JointPos::item.size() > 100))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns6__JointPos * SOAP_FMAC4 soap_instantiate_ns6__JointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__JointPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__JointPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__JointPos;
		if (size)
			*size = sizeof(ns6__JointPos);
		((ns6__JointPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__JointPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__JointPos);
		for (int i = 0; i < n; i++)
			((ns6__JointPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__JointPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__JointPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__JointPos %p -> %p\n", q, p));
	*(ns6__JointPos*)p = *(ns6__JointPos*)q;
}

void ns5__AllRobotsPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__RobotPos(soap, &this->ns5__AllRobotsPos::RobotsPos);
	/* transient soap skipped */
}

void ns5__AllRobotsPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__RobotPos(soap, &this->ns5__AllRobotsPos::RobotsPos);
	/* transient soap skipped */
}

int ns5__AllRobotsPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__AllRobotsPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__AllRobotsPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__AllRobotsPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__AllRobotsPos(struct soap *soap, const char *tag, int id, const ns5__AllRobotsPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__AllRobotsPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__RobotPos(soap, "RobotsPos", -1, &(a->ns5__AllRobotsPos::RobotsPos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__AllRobotsPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__AllRobotsPos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__AllRobotsPos * SOAP_FMAC4 soap_get_ns5__AllRobotsPos(struct soap *soap, ns5__AllRobotsPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__AllRobotsPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__AllRobotsPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__AllRobotsPos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__AllRobotsPos * SOAP_FMAC4 soap_in_ns5__AllRobotsPos(struct soap *soap, const char *tag, ns5__AllRobotsPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__AllRobotsPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__AllRobotsPos, sizeof(ns5__AllRobotsPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__AllRobotsPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__AllRobotsPos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__RobotPos(soap, "RobotsPos", &(a->ns5__AllRobotsPos::RobotsPos), "ns6:RobotPos"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__AllRobotsPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__AllRobotsPos, 0, sizeof(ns5__AllRobotsPos), 0, soap_copy_ns5__AllRobotsPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns5__AllRobotsPos * SOAP_FMAC4 soap_instantiate_ns5__AllRobotsPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__AllRobotsPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__AllRobotsPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__AllRobotsPos;
		if (size)
			*size = sizeof(ns5__AllRobotsPos);
		((ns5__AllRobotsPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__AllRobotsPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__AllRobotsPos);
		for (int i = 0; i < n; i++)
			((ns5__AllRobotsPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__AllRobotsPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__AllRobotsPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__AllRobotsPos %p -> %p\n", q, p));
	*(ns5__AllRobotsPos*)p = *(ns5__AllRobotsPos*)q;
}

void ns5__Records::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns5__Records::record);
	/* transient soap skipped */
}

void ns5__Records::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns5__Records::record);
	/* transient soap skipped */
}

int ns5__Records::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Records);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__Records::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Records(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Records(struct soap *soap, const char *tag, int id, const ns5__Records *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Records), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "record", -1, &(a->ns5__Records::record), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Records::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Records(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Records * SOAP_FMAC4 soap_get_ns5__Records(struct soap *soap, ns5__Records *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__Records::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Records(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Records * SOAP_FMAC4 soap_in_ns5__Records(struct soap *soap, const char *tag, ns5__Records *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Records *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Records, sizeof(ns5__Records), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Records)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Records *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "record", &(a->ns5__Records::record), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Records *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Records, 0, sizeof(ns5__Records), 0, soap_copy_ns5__Records);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns5__Records * SOAP_FMAC4 soap_instantiate_ns5__Records(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Records(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Records, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__Records;
		if (size)
			*size = sizeof(ns5__Records);
		((ns5__Records*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__Records[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__Records);
		for (int i = 0; i < n; i++)
			((ns5__Records*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__Records*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Records(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Records %p -> %p\n", q, p));
	*(ns5__Records*)p = *(ns5__Records*)q;
}

void ns5__VALApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns5__VALApplications::application);
	/* transient soap skipped */
}

void ns5__VALApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns5__VALApplications::application);
	/* transient soap skipped */
}

int ns5__VALApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__VALApplications);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__VALApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__VALApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__VALApplications(struct soap *soap, const char *tag, int id, const ns5__VALApplications *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__VALApplications), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", -1, &(a->ns5__VALApplications::application), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__VALApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__VALApplications(soap, this, tag, type);
}

SOAP_FMAC3 ns5__VALApplications * SOAP_FMAC4 soap_get_ns5__VALApplications(struct soap *soap, ns5__VALApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__VALApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__VALApplications(soap, tag, this, type);
}

SOAP_FMAC3 ns5__VALApplications * SOAP_FMAC4 soap_in_ns5__VALApplications(struct soap *soap, const char *tag, ns5__VALApplications *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__VALApplications *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__VALApplications, sizeof(ns5__VALApplications), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__VALApplications)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__VALApplications *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", &(a->ns5__VALApplications::application), "ns2:VALApplication"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__VALApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__VALApplications, 0, sizeof(ns5__VALApplications), 0, soap_copy_ns5__VALApplications);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns5__VALApplications * SOAP_FMAC4 soap_instantiate_ns5__VALApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__VALApplications(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__VALApplications, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__VALApplications;
		if (size)
			*size = sizeof(ns5__VALApplications);
		((ns5__VALApplications*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__VALApplications[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__VALApplications);
		for (int i = 0; i < n; i++)
			((ns5__VALApplications*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__VALApplications*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__VALApplications(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__VALApplications %p -> %p\n", q, p));
	*(ns5__VALApplications*)p = *(ns5__VALApplications*)q;
}

void ns5__Robots::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns5__Robots::Robots);
	/* transient soap skipped */
}

void ns5__Robots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns5__Robots::Robots);
	/* transient soap skipped */
}

int ns5__Robots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Robots);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__Robots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Robots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Robots(struct soap *soap, const char *tag, int id, const ns5__Robots *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Robots), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", -1, &(a->ns5__Robots::Robots), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Robots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Robots(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Robots * SOAP_FMAC4 soap_get_ns5__Robots(struct soap *soap, ns5__Robots *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__Robots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Robots(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Robots * SOAP_FMAC4 soap_in_ns5__Robots(struct soap *soap, const char *tag, ns5__Robots *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Robots *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Robots, sizeof(ns5__Robots), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Robots)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Robots *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", &(a->ns5__Robots::Robots), "ns1:Robot"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Robots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Robots, 0, sizeof(ns5__Robots), 0, soap_copy_ns5__Robots);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns5__Robots * SOAP_FMAC4 soap_instantiate_ns5__Robots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Robots(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Robots, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__Robots;
		if (size)
			*size = sizeof(ns5__Robots);
		((ns5__Robots*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__Robots[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__Robots);
		for (int i = 0; i < n; i++)
			((ns5__Robots*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__Robots*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Robots(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Robots %p -> %p\n", q, p));
	*(ns5__Robots*)p = *(ns5__Robots*)q;
}

void ns5__Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns5__Versions::Versions);
	/* transient soap skipped */
}

void ns5__Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns5__Versions::Versions);
	/* transient soap skipped */
}

int ns5__Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Versions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Versions(struct soap *soap, const char *tag, int id, const ns5__Versions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Versions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", -1, &(a->ns5__Versions::Versions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Versions(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Versions * SOAP_FMAC4 soap_get_ns5__Versions(struct soap *soap, ns5__Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Versions(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Versions * SOAP_FMAC4 soap_in_ns5__Versions(struct soap *soap, const char *tag, ns5__Versions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Versions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Versions, sizeof(ns5__Versions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Versions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Versions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", &(a->ns5__Versions::Versions), "ns1:Version"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Versions, 0, sizeof(ns5__Versions), 0, soap_copy_ns5__Versions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns5__Versions * SOAP_FMAC4 soap_instantiate_ns5__Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Versions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Versions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__Versions;
		if (size)
			*size = sizeof(ns5__Versions);
		((ns5__Versions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__Versions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__Versions);
		for (int i = 0; i < n; i++)
			((ns5__Versions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__Versions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Versions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Versions %p -> %p\n", q, p));
	*(ns5__Versions*)p = *(ns5__Versions*)q;
}

void ns5__JointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns5__JointPos::item);
	/* transient soap skipped */
}

void ns5__JointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns5__JointPos::item);
	/* transient soap skipped */
}

int ns5__JointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__JointPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__JointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__JointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__JointPos(struct soap *soap, const char *tag, int id, const ns5__JointPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__JointPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "item", -1, &(a->ns5__JointPos::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__JointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__JointPos(soap, this, tag, type);
}

SOAP_FMAC3 ns5__JointPos * SOAP_FMAC4 soap_get_ns5__JointPos(struct soap *soap, ns5__JointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__JointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__JointPos(soap, tag, this, type);
}

SOAP_FMAC3 ns5__JointPos * SOAP_FMAC4 soap_in_ns5__JointPos(struct soap *soap, const char *tag, ns5__JointPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__JointPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__JointPos, sizeof(ns5__JointPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__JointPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__JointPos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "item", &(a->ns5__JointPos::item), "xsd:double"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__JointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__JointPos, 0, sizeof(ns5__JointPos), 0, soap_copy_ns5__JointPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns5__JointPos::item.size() > 100))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns5__JointPos * SOAP_FMAC4 soap_instantiate_ns5__JointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__JointPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__JointPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__JointPos;
		if (size)
			*size = sizeof(ns5__JointPos);
		((ns5__JointPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__JointPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__JointPos);
		for (int i = 0; i < n; i++)
			((ns5__JointPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__JointPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__JointPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__JointPos %p -> %p\n", q, p));
	*(ns5__JointPos*)p = *(ns5__JointPos*)q;
}

void ns4__hexBinary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__hexBinary::__item.xsd__hexBinary::soap_default(soap);
	this->ns4__hexBinary::ns4__contentType = NULL;
	/* transient soap skipped */
}

void ns4__hexBinary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__hexBinary::__item.soap_serialize(soap);
	/* transient soap skipped */
}

int ns4__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__hexBinary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__hexBinary(struct soap *soap, const char *tag, int id, const ns4__hexBinary *a, const char *type)
{
	if (((ns4__hexBinary*)a)->ns4__contentType)
		soap_set_attr(soap, "ns4:contentType", ((ns4__hexBinary*)a)->ns4__contentType->c_str());
	return (a->ns4__hexBinary::__item).soap_out(soap, tag, id, "");
}

void *ns4__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 ns4__hexBinary * SOAP_FMAC4 soap_get_ns4__hexBinary(struct soap *soap, ns4__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 ns4__hexBinary * SOAP_FMAC4 soap_in_ns4__hexBinary(struct soap *soap, const char *tag, ns4__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__hexBinary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__hexBinary, sizeof(ns4__hexBinary), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__hexBinary)
			return (ns4__hexBinary *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "ns4:contentType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((ns4__hexBinary*)a)->ns4__contentType = soap_new_std__string(soap, -1);
				((ns4__hexBinary*)a)->ns4__contentType->assign(s);
			}
		}
	}
	if (!(a->ns4__hexBinary::__item).soap_in(soap, tag, "ns4:hexBinary"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__hexBinary * SOAP_FMAC4 soap_instantiate_ns4__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__hexBinary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__hexBinary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__hexBinary;
		if (size)
			*size = sizeof(ns4__hexBinary);
		((ns4__hexBinary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__hexBinary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__hexBinary);
		for (int i = 0; i < n; i++)
			((ns4__hexBinary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__hexBinary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__hexBinary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__hexBinary %p -> %p\n", q, p));
	*(ns4__hexBinary*)p = *(ns4__hexBinary*)q;
}

void ns4__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns4__base64Binary::__item.xsd__base64Binary::soap_default(soap);
	this->ns4__base64Binary::ns4__contentType = NULL;
	/* transient soap skipped */
}

void ns4__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->ns4__base64Binary::__item.soap_serialize(soap);
	/* transient soap skipped */
}

int ns4__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__base64Binary(struct soap *soap, const char *tag, int id, const ns4__base64Binary *a, const char *type)
{
	if (((ns4__base64Binary*)a)->ns4__contentType)
		soap_set_attr(soap, "ns4:contentType", ((ns4__base64Binary*)a)->ns4__contentType->c_str());
	return (a->ns4__base64Binary::__item).soap_out(soap, tag, id, "");
}

void *ns4__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 ns4__base64Binary * SOAP_FMAC4 soap_get_ns4__base64Binary(struct soap *soap, ns4__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 ns4__base64Binary * SOAP_FMAC4 soap_in_ns4__base64Binary(struct soap *soap, const char *tag, ns4__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns4__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__base64Binary, sizeof(ns4__base64Binary), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__base64Binary)
			return (ns4__base64Binary *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "ns4:contentType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((ns4__base64Binary*)a)->ns4__contentType = soap_new_std__string(soap, -1);
				((ns4__base64Binary*)a)->ns4__contentType->assign(s);
			}
		}
	}
	if (!(a->ns4__base64Binary::__item).soap_in(soap, tag, "ns4:base64Binary"))
		return NULL;
	return a;
}

SOAP_FMAC3 ns4__base64Binary * SOAP_FMAC4 soap_instantiate_ns4__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__base64Binary;
		if (size)
			*size = sizeof(ns4__base64Binary);
		((ns4__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__base64Binary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__base64Binary);
		for (int i = 0; i < n; i++)
			((ns4__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__base64Binary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__base64Binary %p -> %p\n", q, p));
	*(ns4__base64Binary*)p = *(ns4__base64Binary*)q;
}

void ns3__Include::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns3__Include::__any);
	soap_default_xsd__anyURI(soap, &this->ns3__Include::href);
	this->ns3__Include::__anyAttribute = NULL;
	/* transient soap skipped */
}

void ns3__Include::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns3__Include::__any);
	/* transient soap skipped */
}

int ns3__Include::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__Include);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__Include::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__Include(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__Include(struct soap *soap, const char *tag, int id, const ns3__Include *a, const char *type)
{
	if (!((ns3__Include*)a)->href.empty())
		soap_set_attr(soap, "href", ((ns3__Include*)a)->href.c_str());
	if (((ns3__Include*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns3__Include*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__Include), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->ns3__Include::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__Include::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__Include(soap, this, tag, type);
}

SOAP_FMAC3 ns3__Include * SOAP_FMAC4 soap_get_ns3__Include(struct soap *soap, ns3__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__Include::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__Include(soap, tag, this, type);
}

SOAP_FMAC3 ns3__Include * SOAP_FMAC4 soap_in_ns3__Include(struct soap *soap, const char *tag, ns3__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__Include *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__Include, sizeof(ns3__Include), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__Include)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__Include *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "href", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((ns3__Include*)a)->href.assign(s);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns3__Include*)a)->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->ns3__Include::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__Include, 0, sizeof(ns3__Include), 0, soap_copy_ns3__Include);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns3__Include * SOAP_FMAC4 soap_instantiate_ns3__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__Include(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__Include, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__Include;
		if (size)
			*size = sizeof(ns3__Include);
		((ns3__Include*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__Include[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__Include);
		for (int i = 0; i < n; i++)
			((ns3__Include*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__Include*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__Include(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__Include %p -> %p\n", q, p));
	*(ns3__Include*)p = *(ns3__Include*)q;
}

void _ns2__getJointRangeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getJointRangeResponse::range = NULL;
	/* transient soap skipped */
}

void _ns2__getJointRangeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__JointRange(soap, &this->_ns2__getJointRangeResponse::range);
	/* transient soap skipped */
}

int _ns2__getJointRangeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getJointRangeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getJointRangeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getJointRangeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getJointRangeResponse(struct soap *soap, const char *tag, int id, const _ns2__getJointRangeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getJointRangeResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__JointRange(soap, "range", -1, &(a->_ns2__getJointRangeResponse::range), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getJointRangeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getJointRangeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getJointRangeResponse * SOAP_FMAC4 soap_get__ns2__getJointRangeResponse(struct soap *soap, _ns2__getJointRangeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getJointRangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getJointRangeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getJointRangeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getJointRangeResponse * SOAP_FMAC4 soap_in__ns2__getJointRangeResponse(struct soap *soap, const char *tag, _ns2__getJointRangeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getJointRangeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getJointRangeResponse, sizeof(_ns2__getJointRangeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getJointRangeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getJointRangeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_range1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_range1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__JointRange(soap, "range", &(a->_ns2__getJointRangeResponse::range), "ns2:JointRange"))
				{	soap_flag_range1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getJointRangeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getJointRangeResponse, 0, sizeof(_ns2__getJointRangeResponse), 0, soap_copy__ns2__getJointRangeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_range1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getJointRangeResponse * SOAP_FMAC4 soap_instantiate__ns2__getJointRangeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getJointRangeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getJointRangeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getJointRangeResponse;
		if (size)
			*size = sizeof(_ns2__getJointRangeResponse);
		((_ns2__getJointRangeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getJointRangeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getJointRangeResponse);
		for (int i = 0; i < n; i++)
			((_ns2__getJointRangeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getJointRangeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getJointRangeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getJointRangeResponse %p -> %p\n", q, p));
	*(_ns2__getJointRangeResponse*)p = *(_ns2__getJointRangeResponse*)q;
}

void _ns2__getJointRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns2__getJointRange::robot);
	/* transient soap skipped */
}

void _ns2__getJointRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns2__getJointRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getJointRange);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getJointRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getJointRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getJointRange(struct soap *soap, const char *tag, int id, const _ns2__getJointRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getJointRange), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns2__getJointRange::robot), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getJointRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getJointRange(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getJointRange * SOAP_FMAC4 soap_get__ns2__getJointRange(struct soap *soap, _ns2__getJointRange *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getJointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getJointRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getJointRange(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getJointRange * SOAP_FMAC4 soap_in__ns2__getJointRange(struct soap *soap, const char *tag, _ns2__getJointRange *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getJointRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getJointRange, sizeof(_ns2__getJointRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getJointRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getJointRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns2__getJointRange::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getJointRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getJointRange, 0, sizeof(_ns2__getJointRange), 0, soap_copy__ns2__getJointRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getJointRange * SOAP_FMAC4 soap_instantiate__ns2__getJointRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getJointRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getJointRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getJointRange;
		if (size)
			*size = sizeof(_ns2__getJointRange);
		((_ns2__getJointRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getJointRange[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getJointRange);
		for (int i = 0; i < n; i++)
			((_ns2__getJointRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getJointRange*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getJointRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getJointRange %p -> %p\n", q, p));
	*(_ns2__getJointRange*)p = *(_ns2__getJointRange*)q;
}

void _ns2__getRecordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getRecordResponse::data.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns2__getRecordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns2__getRecordResponse::data.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns2__getRecordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getRecordResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getRecordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecordResponse(struct soap *soap, const char *tag, int id, const _ns2__getRecordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecordResponse), type))
		return soap->error;
	if ((a->_ns2__getRecordResponse::data).soap_out(soap, "data", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecordResponse * SOAP_FMAC4 soap_get__ns2__getRecordResponse(struct soap *soap, _ns2__getRecordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getRecordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecordResponse * SOAP_FMAC4 soap_in__ns2__getRecordResponse(struct soap *soap, const char *tag, _ns2__getRecordResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecordResponse, sizeof(_ns2__getRecordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getRecordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getRecordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns2__getRecordResponse::data).soap_in(soap, "data", "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getRecordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecordResponse, 0, sizeof(_ns2__getRecordResponse), 0, soap_copy__ns2__getRecordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getRecordResponse * SOAP_FMAC4 soap_instantiate__ns2__getRecordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getRecordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getRecordResponse;
		if (size)
			*size = sizeof(_ns2__getRecordResponse);
		((_ns2__getRecordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getRecordResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getRecordResponse);
		for (int i = 0; i < n; i++)
			((_ns2__getRecordResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getRecordResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getRecordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getRecordResponse %p -> %p\n", q, p));
	*(_ns2__getRecordResponse*)p = *(_ns2__getRecordResponse*)q;
}

void _ns2__getRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getRecord::name = NULL;
	/* transient soap skipped */
}

void _ns2__getRecord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns2__getRecord::name);
	/* transient soap skipped */
}

int _ns2__getRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getRecord);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecord(struct soap *soap, const char *tag, int id, const _ns2__getRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecord), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->_ns2__getRecord::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecord(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecord * SOAP_FMAC4 soap_get__ns2__getRecord(struct soap *soap, _ns2__getRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecord(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecord * SOAP_FMAC4 soap_in__ns2__getRecord(struct soap *soap, const char *tag, _ns2__getRecord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecord, sizeof(_ns2__getRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->_ns2__getRecord::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecord, 0, sizeof(_ns2__getRecord), 0, soap_copy__ns2__getRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getRecord * SOAP_FMAC4 soap_instantiate__ns2__getRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getRecord;
		if (size)
			*size = sizeof(_ns2__getRecord);
		((_ns2__getRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getRecord[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getRecord);
		for (int i = 0; i < n; i++)
			((_ns2__getRecord*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getRecord*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getRecord %p -> %p\n", q, p));
	*(_ns2__getRecord*)p = *(_ns2__getRecord*)q;
}

void _ns2__getRecordsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getRecordsResponse::records = NULL;
	/* transient soap skipped */
}

void _ns2__getRecordsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Records(soap, &this->_ns2__getRecordsResponse::records);
	/* transient soap skipped */
}

int _ns2__getRecordsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getRecordsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getRecordsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecordsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecordsResponse(struct soap *soap, const char *tag, int id, const _ns2__getRecordsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecordsResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__Records(soap, "records", -1, &(a->_ns2__getRecordsResponse::records), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecordsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecordsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecordsResponse * SOAP_FMAC4 soap_get__ns2__getRecordsResponse(struct soap *soap, _ns2__getRecordsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getRecordsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecordsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecordsResponse * SOAP_FMAC4 soap_in__ns2__getRecordsResponse(struct soap *soap, const char *tag, _ns2__getRecordsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecordsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecordsResponse, sizeof(_ns2__getRecordsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getRecordsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getRecordsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_records1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_records1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Records(soap, "records", &(a->_ns2__getRecordsResponse::records), "ns2:Records"))
				{	soap_flag_records1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getRecordsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecordsResponse, 0, sizeof(_ns2__getRecordsResponse), 0, soap_copy__ns2__getRecordsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_records1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getRecordsResponse * SOAP_FMAC4 soap_instantiate__ns2__getRecordsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecordsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getRecordsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getRecordsResponse;
		if (size)
			*size = sizeof(_ns2__getRecordsResponse);
		((_ns2__getRecordsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getRecordsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getRecordsResponse);
		for (int i = 0; i < n; i++)
			((_ns2__getRecordsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getRecordsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getRecordsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getRecordsResponse %p -> %p\n", q, p));
	*(_ns2__getRecordsResponse*)p = *(_ns2__getRecordsResponse*)q;
}

void _ns2__getRecords::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns2__getRecords::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns2__getRecords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getRecords);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getRecords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getRecords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getRecords(struct soap *soap, const char *tag, int id, const _ns2__getRecords *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getRecords), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getRecords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getRecords(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getRecords * SOAP_FMAC4 soap_get__ns2__getRecords(struct soap *soap, _ns2__getRecords *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getRecords::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getRecords(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getRecords * SOAP_FMAC4 soap_in__ns2__getRecords(struct soap *soap, const char *tag, _ns2__getRecords *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getRecords *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getRecords, sizeof(_ns2__getRecords), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getRecords)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getRecords *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getRecords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getRecords, 0, sizeof(_ns2__getRecords), 0, soap_copy__ns2__getRecords);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getRecords * SOAP_FMAC4 soap_instantiate__ns2__getRecords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getRecords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getRecords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getRecords;
		if (size)
			*size = sizeof(_ns2__getRecords);
		((_ns2__getRecords*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getRecords[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getRecords);
		for (int i = 0; i < n; i++)
			((_ns2__getRecords*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getRecords*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getRecords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getRecords %p -> %p\n", q, p));
	*(_ns2__getRecords*)p = *(_ns2__getRecords*)q;
}

void _ns2__getApplicationDatasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getApplicationDatasResponse::data.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns2__getApplicationDatasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns2__getApplicationDatasResponse::data.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns2__getApplicationDatasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getApplicationDatasResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getApplicationDatasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplicationDatasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplicationDatasResponse(struct soap *soap, const char *tag, int id, const _ns2__getApplicationDatasResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplicationDatasResponse), type))
		return soap->error;
	if ((a->_ns2__getApplicationDatasResponse::data).soap_out(soap, "data", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplicationDatasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplicationDatasResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplicationDatasResponse * SOAP_FMAC4 soap_get__ns2__getApplicationDatasResponse(struct soap *soap, _ns2__getApplicationDatasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplicationDatasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getApplicationDatasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplicationDatasResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplicationDatasResponse * SOAP_FMAC4 soap_in__ns2__getApplicationDatasResponse(struct soap *soap, const char *tag, _ns2__getApplicationDatasResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplicationDatasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplicationDatasResponse, sizeof(_ns2__getApplicationDatasResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getApplicationDatasResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getApplicationDatasResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_data1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_data1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns2__getApplicationDatasResponse::data).soap_in(soap, "data", "xsd:base64Binary"))
				{	soap_flag_data1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getApplicationDatasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplicationDatasResponse, 0, sizeof(_ns2__getApplicationDatasResponse), 0, soap_copy__ns2__getApplicationDatasResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_data1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getApplicationDatasResponse * SOAP_FMAC4 soap_instantiate__ns2__getApplicationDatasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplicationDatasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getApplicationDatasResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getApplicationDatasResponse;
		if (size)
			*size = sizeof(_ns2__getApplicationDatasResponse);
		((_ns2__getApplicationDatasResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getApplicationDatasResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getApplicationDatasResponse);
		for (int i = 0; i < n; i++)
			((_ns2__getApplicationDatasResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getApplicationDatasResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getApplicationDatasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getApplicationDatasResponse %p -> %p\n", q, p));
	*(_ns2__getApplicationDatasResponse*)p = *(_ns2__getApplicationDatasResponse*)q;
}

void _ns2__getApplicationDatas::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getApplicationDatas::name = NULL;
	/* transient soap skipped */
}

void _ns2__getApplicationDatas::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns2__getApplicationDatas::name);
	/* transient soap skipped */
}

int _ns2__getApplicationDatas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getApplicationDatas);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getApplicationDatas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplicationDatas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplicationDatas(struct soap *soap, const char *tag, int id, const _ns2__getApplicationDatas *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplicationDatas), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->_ns2__getApplicationDatas::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplicationDatas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplicationDatas(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplicationDatas * SOAP_FMAC4 soap_get__ns2__getApplicationDatas(struct soap *soap, _ns2__getApplicationDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplicationDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getApplicationDatas::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplicationDatas(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplicationDatas * SOAP_FMAC4 soap_in__ns2__getApplicationDatas(struct soap *soap, const char *tag, _ns2__getApplicationDatas *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplicationDatas *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplicationDatas, sizeof(_ns2__getApplicationDatas), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getApplicationDatas)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getApplicationDatas *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->_ns2__getApplicationDatas::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getApplicationDatas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplicationDatas, 0, sizeof(_ns2__getApplicationDatas), 0, soap_copy__ns2__getApplicationDatas);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getApplicationDatas * SOAP_FMAC4 soap_instantiate__ns2__getApplicationDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplicationDatas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getApplicationDatas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getApplicationDatas;
		if (size)
			*size = sizeof(_ns2__getApplicationDatas);
		((_ns2__getApplicationDatas*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getApplicationDatas[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getApplicationDatas);
		for (int i = 0; i < n; i++)
			((_ns2__getApplicationDatas*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getApplicationDatas*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getApplicationDatas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getApplicationDatas %p -> %p\n", q, p));
	*(_ns2__getApplicationDatas*)p = *(_ns2__getApplicationDatas*)q;
}

void _ns2__getApplicationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__getApplicationsResponse::applications = NULL;
	/* transient soap skipped */
}

void _ns2__getApplicationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__VALApplications(soap, &this->_ns2__getApplicationsResponse::applications);
	/* transient soap skipped */
}

int _ns2__getApplicationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getApplicationsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getApplicationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplicationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplicationsResponse(struct soap *soap, const char *tag, int id, const _ns2__getApplicationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplicationsResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__VALApplications(soap, "applications", -1, &(a->_ns2__getApplicationsResponse::applications), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplicationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplicationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplicationsResponse * SOAP_FMAC4 soap_get__ns2__getApplicationsResponse(struct soap *soap, _ns2__getApplicationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplicationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getApplicationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplicationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplicationsResponse * SOAP_FMAC4 soap_in__ns2__getApplicationsResponse(struct soap *soap, const char *tag, _ns2__getApplicationsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplicationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplicationsResponse, sizeof(_ns2__getApplicationsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getApplicationsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getApplicationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_applications1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_applications1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VALApplications(soap, "applications", &(a->_ns2__getApplicationsResponse::applications), "ns2:VALApplications"))
				{	soap_flag_applications1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getApplicationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplicationsResponse, 0, sizeof(_ns2__getApplicationsResponse), 0, soap_copy__ns2__getApplicationsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_applications1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getApplicationsResponse * SOAP_FMAC4 soap_instantiate__ns2__getApplicationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplicationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getApplicationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getApplicationsResponse;
		if (size)
			*size = sizeof(_ns2__getApplicationsResponse);
		((_ns2__getApplicationsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getApplicationsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getApplicationsResponse);
		for (int i = 0; i < n; i++)
			((_ns2__getApplicationsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getApplicationsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getApplicationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getApplicationsResponse %p -> %p\n", q, p));
	*(_ns2__getApplicationsResponse*)p = *(_ns2__getApplicationsResponse*)q;
}

void _ns2__getApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns2__getApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns2__getApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__getApplications);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns2__getApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__getApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__getApplications(struct soap *soap, const char *tag, int id, const _ns2__getApplications *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__getApplications), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__getApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__getApplications(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__getApplications * SOAP_FMAC4 soap_get__ns2__getApplications(struct soap *soap, _ns2__getApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__getApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns2__getApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__getApplications(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__getApplications * SOAP_FMAC4 soap_in__ns2__getApplications(struct soap *soap, const char *tag, _ns2__getApplications *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__getApplications *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__getApplications, sizeof(_ns2__getApplications), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__getApplications)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__getApplications *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__getApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__getApplications, 0, sizeof(_ns2__getApplications), 0, soap_copy__ns2__getApplications);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns2__getApplications * SOAP_FMAC4 soap_instantiate__ns2__getApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__getApplications(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__getApplications, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns2__getApplications;
		if (size)
			*size = sizeof(_ns2__getApplications);
		((_ns2__getApplications*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns2__getApplications[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns2__getApplications);
		for (int i = 0; i < n; i++)
			((_ns2__getApplications*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns2__getApplications*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__getApplications(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__getApplications %p -> %p\n", q, p));
	*(_ns2__getApplications*)p = *(_ns2__getApplications*)q;
}

void ns2__JointRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::min_);
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::max_);
	/* transient soap skipped */
}

void ns2__JointRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::min_);
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns2__JointRange::max_);
	/* transient soap skipped */
}

int ns2__JointRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__JointRange);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__JointRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__JointRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__JointRange(struct soap *soap, const char *tag, int id, const ns2__JointRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__JointRange), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "min", -1, &(a->ns2__JointRange::min_), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "max", -1, &(a->ns2__JointRange::max_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__JointRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__JointRange(soap, this, tag, type);
}

SOAP_FMAC3 ns2__JointRange * SOAP_FMAC4 soap_get_ns2__JointRange(struct soap *soap, ns2__JointRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__JointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns2__JointRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__JointRange(soap, tag, this, type);
}

SOAP_FMAC3 ns2__JointRange * SOAP_FMAC4 soap_in_ns2__JointRange(struct soap *soap, const char *tag, ns2__JointRange *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__JointRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__JointRange, sizeof(ns2__JointRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__JointRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__JointRange *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "min", &(a->ns2__JointRange::min_), "xsd:double"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "max", &(a->ns2__JointRange::max_), "xsd:double"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__JointRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__JointRange, 0, sizeof(ns2__JointRange), 0, soap_copy_ns2__JointRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns2__JointRange * SOAP_FMAC4 soap_instantiate_ns2__JointRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__JointRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__JointRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__JointRange;
		if (size)
			*size = sizeof(ns2__JointRange);
		((ns2__JointRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__JointRange[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__JointRange);
		for (int i = 0; i < n; i++)
			((ns2__JointRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__JointRange*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__JointRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__JointRange %p -> %p\n", q, p));
	*(ns2__JointRange*)p = *(ns2__JointRange*)q;
}

void ns2__Records::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__Records::record);
	/* transient soap skipped */
}

void ns2__Records::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__Records::record);
	/* transient soap skipped */
}

int ns2__Records::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Records);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__Records::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Records(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Records(struct soap *soap, const char *tag, int id, const ns2__Records *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Records), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "record", -1, &(a->ns2__Records::record), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Records::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Records(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Records * SOAP_FMAC4 soap_get_ns2__Records(struct soap *soap, ns2__Records *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns2__Records::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Records(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Records * SOAP_FMAC4 soap_in_ns2__Records(struct soap *soap, const char *tag, ns2__Records *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Records *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Records, sizeof(ns2__Records), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Records)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Records *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "record", &(a->ns2__Records::record), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Records *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Records, 0, sizeof(ns2__Records), 0, soap_copy_ns2__Records);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns2__Records * SOAP_FMAC4 soap_instantiate_ns2__Records(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Records(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Records, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__Records;
		if (size)
			*size = sizeof(ns2__Records);
		((ns2__Records*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__Records[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__Records);
		for (int i = 0; i < n; i++)
			((ns2__Records*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__Records*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Records(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Records %p -> %p\n", q, p));
	*(ns2__Records*)p = *(ns2__Records*)q;
}

void ns2__Data::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Data::ns3__Include_ = NULL;
	this->ns2__Data::ns4__contentType = NULL;
	/* transient soap skipped */
}

void ns2__Data::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__Include(soap, &this->ns2__Data::ns3__Include_);
	/* transient soap skipped */
}

int ns2__Data::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Data);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__Data::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Data(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Data(struct soap *soap, const char *tag, int id, const ns2__Data *a, const char *type)
{
	if (((ns2__Data*)a)->ns4__contentType)
		soap_set_attr(soap, "ns4:contentType", ((ns2__Data*)a)->ns4__contentType->c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Data), type))
		return soap->error;
	if (soap_out_PointerTons3__Include(soap, "ns3:Include", -1, &(a->ns2__Data::ns3__Include_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Data::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Data(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Data * SOAP_FMAC4 soap_get_ns2__Data(struct soap *soap, ns2__Data *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Data(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns2__Data::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Data(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Data * SOAP_FMAC4 soap_in_ns2__Data(struct soap *soap, const char *tag, ns2__Data *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Data *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Data, sizeof(ns2__Data), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Data)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Data *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ns4:contentType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((ns2__Data*)a)->ns4__contentType = soap_new_std__string(soap, -1);
				((ns2__Data*)a)->ns4__contentType->assign(s);
			}
		}
	}
	size_t soap_flag_ns3__Include_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__Include_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__Include(soap, "ns3:Include", &(a->ns2__Data::ns3__Include_), "ns3:Include"))
				{	soap_flag_ns3__Include_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Data *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Data, 0, sizeof(ns2__Data), 0, soap_copy_ns2__Data);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns3__Include_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns2__Data * SOAP_FMAC4 soap_instantiate_ns2__Data(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Data(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Data, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__Data;
		if (size)
			*size = sizeof(ns2__Data);
		((ns2__Data*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__Data[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__Data);
		for (int i = 0; i < n; i++)
			((ns2__Data*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__Data*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Data(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Data %p -> %p\n", q, p));
	*(ns2__Data*)p = *(ns2__Data*)q;
}

void ns2__VALApplications::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns2__VALApplications::application);
	/* transient soap skipped */
}

void ns2__VALApplications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(soap, &this->ns2__VALApplications::application);
	/* transient soap skipped */
}

int ns2__VALApplications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__VALApplications);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__VALApplications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VALApplications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VALApplications(struct soap *soap, const char *tag, int id, const ns2__VALApplications *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VALApplications), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", -1, &(a->ns2__VALApplications::application), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__VALApplications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VALApplications(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VALApplications * SOAP_FMAC4 soap_get_ns2__VALApplications(struct soap *soap, ns2__VALApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns2__VALApplications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VALApplications(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VALApplications * SOAP_FMAC4 soap_in_ns2__VALApplications(struct soap *soap, const char *tag, ns2__VALApplications *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VALApplications *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VALApplications, sizeof(ns2__VALApplications), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__VALApplications)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__VALApplications *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__VALApplication(soap, "application", &(a->ns2__VALApplications::application), "ns2:VALApplication"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VALApplications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VALApplications, 0, sizeof(ns2__VALApplications), 0, soap_copy_ns2__VALApplications);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns2__VALApplications * SOAP_FMAC4 soap_instantiate_ns2__VALApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VALApplications(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__VALApplications, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__VALApplications;
		if (size)
			*size = sizeof(ns2__VALApplications);
		((ns2__VALApplications*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__VALApplications[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__VALApplications);
		for (int i = 0; i < n; i++)
			((ns2__VALApplications*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__VALApplications*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__VALApplications(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__VALApplications %p -> %p\n", q, p));
	*(ns2__VALApplications*)p = *(ns2__VALApplications*)q;
}

void ns2__VALApplication::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VALApplication::name = NULL;
	soap_default_bool(soap, &this->ns2__VALApplication::loaded);
	/* transient soap skipped */
}

void ns2__VALApplication::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__VALApplication::name);
	/* transient soap skipped */
}

int ns2__VALApplication::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__VALApplication);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__VALApplication::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VALApplication(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VALApplication(struct soap *soap, const char *tag, int id, const ns2__VALApplication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VALApplication), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns2__VALApplication::name), ""))
		return soap->error;
	if (soap_out_bool(soap, "loaded", -1, &(a->ns2__VALApplication::loaded), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__VALApplication::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VALApplication(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VALApplication * SOAP_FMAC4 soap_get_ns2__VALApplication(struct soap *soap, ns2__VALApplication *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VALApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns2__VALApplication::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VALApplication(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VALApplication * SOAP_FMAC4 soap_in_ns2__VALApplication(struct soap *soap, const char *tag, ns2__VALApplication *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VALApplication *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VALApplication, sizeof(ns2__VALApplication), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__VALApplication)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__VALApplication *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_loaded1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns2__VALApplication::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_loaded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "loaded", &(a->ns2__VALApplication::loaded), "xsd:boolean"))
				{	soap_flag_loaded1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VALApplication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VALApplication, 0, sizeof(ns2__VALApplication), 0, soap_copy_ns2__VALApplication);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loaded1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns2__VALApplication * SOAP_FMAC4 soap_instantiate_ns2__VALApplication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VALApplication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__VALApplication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__VALApplication;
		if (size)
			*size = sizeof(ns2__VALApplication);
		((ns2__VALApplication*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__VALApplication[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__VALApplication);
		for (int i = 0; i < n; i++)
			((ns2__VALApplication*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__VALApplication*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__VALApplication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__VALApplication %p -> %p\n", q, p));
	*(ns2__VALApplication*)p = *(ns2__VALApplication*)q;
}

void _ns1__getCS8CompatibilityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getCS8CompatibilityResponse::compatibility = NULL;
	/* transient soap skipped */
}

void _ns1__getCS8CompatibilityResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getCS8CompatibilityResponse::compatibility);
	/* transient soap skipped */
}

int _ns1__getCS8CompatibilityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getCS8CompatibilityResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getCS8CompatibilityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8CompatibilityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8CompatibilityResponse(struct soap *soap, const char *tag, int id, const _ns1__getCS8CompatibilityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8CompatibilityResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "compatibility", -1, &(a->_ns1__getCS8CompatibilityResponse::compatibility), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8CompatibilityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8CompatibilityResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8CompatibilityResponse * SOAP_FMAC4 soap_get__ns1__getCS8CompatibilityResponse(struct soap *soap, _ns1__getCS8CompatibilityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8CompatibilityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getCS8CompatibilityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8CompatibilityResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8CompatibilityResponse * SOAP_FMAC4 soap_in__ns1__getCS8CompatibilityResponse(struct soap *soap, const char *tag, _ns1__getCS8CompatibilityResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8CompatibilityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8CompatibilityResponse, sizeof(_ns1__getCS8CompatibilityResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getCS8CompatibilityResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getCS8CompatibilityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_compatibility1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_compatibility1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "compatibility", &(a->_ns1__getCS8CompatibilityResponse::compatibility), "xsd:string"))
				{	soap_flag_compatibility1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getCS8CompatibilityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8CompatibilityResponse, 0, sizeof(_ns1__getCS8CompatibilityResponse), 0, soap_copy__ns1__getCS8CompatibilityResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getCS8CompatibilityResponse * SOAP_FMAC4 soap_instantiate__ns1__getCS8CompatibilityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8CompatibilityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getCS8CompatibilityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getCS8CompatibilityResponse;
		if (size)
			*size = sizeof(_ns1__getCS8CompatibilityResponse);
		((_ns1__getCS8CompatibilityResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getCS8CompatibilityResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getCS8CompatibilityResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getCS8CompatibilityResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getCS8CompatibilityResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getCS8CompatibilityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getCS8CompatibilityResponse %p -> %p\n", q, p));
	*(_ns1__getCS8CompatibilityResponse*)p = *(_ns1__getCS8CompatibilityResponse*)q;
}

void _ns1__getCS8Compatibility::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getCS8Compatibility::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getCS8Compatibility::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getCS8Compatibility);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getCS8Compatibility::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8Compatibility(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8Compatibility(struct soap *soap, const char *tag, int id, const _ns1__getCS8Compatibility *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8Compatibility), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8Compatibility::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8Compatibility(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8Compatibility * SOAP_FMAC4 soap_get__ns1__getCS8Compatibility(struct soap *soap, _ns1__getCS8Compatibility *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8Compatibility(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getCS8Compatibility::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8Compatibility(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8Compatibility * SOAP_FMAC4 soap_in__ns1__getCS8Compatibility(struct soap *soap, const char *tag, _ns1__getCS8Compatibility *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8Compatibility *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8Compatibility, sizeof(_ns1__getCS8Compatibility), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getCS8Compatibility)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getCS8Compatibility *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getCS8Compatibility *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8Compatibility, 0, sizeof(_ns1__getCS8Compatibility), 0, soap_copy__ns1__getCS8Compatibility);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getCS8Compatibility * SOAP_FMAC4 soap_instantiate__ns1__getCS8Compatibility(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8Compatibility(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getCS8Compatibility, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getCS8Compatibility;
		if (size)
			*size = sizeof(_ns1__getCS8Compatibility);
		((_ns1__getCS8Compatibility*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getCS8Compatibility[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getCS8Compatibility);
		for (int i = 0; i < n; i++)
			((_ns1__getCS8Compatibility*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getCS8Compatibility*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getCS8Compatibility(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getCS8Compatibility %p -> %p\n", q, p));
	*(_ns1__getCS8Compatibility*)p = *(_ns1__getCS8Compatibility*)q;
}

void _ns1__getControllerParametersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getControllerParametersResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getControllerParametersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Parameters(soap, &this->_ns1__getControllerParametersResponse::out);
	/* transient soap skipped */
}

int _ns1__getControllerParametersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getControllerParametersResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getControllerParametersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getControllerParametersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getControllerParametersResponse(struct soap *soap, const char *tag, int id, const _ns1__getControllerParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getControllerParametersResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Parameters(soap, "out", -1, &(a->_ns1__getControllerParametersResponse::out), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getControllerParametersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getControllerParametersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getControllerParametersResponse * SOAP_FMAC4 soap_get__ns1__getControllerParametersResponse(struct soap *soap, _ns1__getControllerParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getControllerParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getControllerParametersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getControllerParametersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getControllerParametersResponse * SOAP_FMAC4 soap_in__ns1__getControllerParametersResponse(struct soap *soap, const char *tag, _ns1__getControllerParametersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getControllerParametersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getControllerParametersResponse, sizeof(_ns1__getControllerParametersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getControllerParametersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getControllerParametersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Parameters(soap, "out", &(a->_ns1__getControllerParametersResponse::out), "ns1:Parameters"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getControllerParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getControllerParametersResponse, 0, sizeof(_ns1__getControllerParametersResponse), 0, soap_copy__ns1__getControllerParametersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getControllerParametersResponse * SOAP_FMAC4 soap_instantiate__ns1__getControllerParametersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getControllerParametersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getControllerParametersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getControllerParametersResponse;
		if (size)
			*size = sizeof(_ns1__getControllerParametersResponse);
		((_ns1__getControllerParametersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getControllerParametersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getControllerParametersResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getControllerParametersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getControllerParametersResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getControllerParametersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getControllerParametersResponse %p -> %p\n", q, p));
	*(_ns1__getControllerParametersResponse*)p = *(_ns1__getControllerParametersResponse*)q;
}

void _ns1__getControllerParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getControllerParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getControllerParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getControllerParameters);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getControllerParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getControllerParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getControllerParameters(struct soap *soap, const char *tag, int id, const _ns1__getControllerParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getControllerParameters), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getControllerParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getControllerParameters(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getControllerParameters * SOAP_FMAC4 soap_get__ns1__getControllerParameters(struct soap *soap, _ns1__getControllerParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getControllerParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getControllerParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getControllerParameters(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getControllerParameters * SOAP_FMAC4 soap_in__ns1__getControllerParameters(struct soap *soap, const char *tag, _ns1__getControllerParameters *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getControllerParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getControllerParameters, sizeof(_ns1__getControllerParameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getControllerParameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getControllerParameters *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getControllerParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getControllerParameters, 0, sizeof(_ns1__getControllerParameters), 0, soap_copy__ns1__getControllerParameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getControllerParameters * SOAP_FMAC4 soap_instantiate__ns1__getControllerParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getControllerParameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getControllerParameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getControllerParameters;
		if (size)
			*size = sizeof(_ns1__getControllerParameters);
		((_ns1__getControllerParameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getControllerParameters[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getControllerParameters);
		for (int i = 0; i < n; i++)
			((_ns1__getControllerParameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getControllerParameters*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getControllerParameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getControllerParameters %p -> %p\n", q, p));
	*(_ns1__getControllerParameters*)p = *(_ns1__getControllerParameters*)q;
}

void _ns1__findServerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__findServerResponse::found);
	/* transient soap skipped */
}

void _ns1__findServerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__findServerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findServerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findServerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findServerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findServerResponse(struct soap *soap, const char *tag, int id, const _ns1__findServerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findServerResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "found", -1, &(a->_ns1__findServerResponse::found), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__findServerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findServerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findServerResponse * SOAP_FMAC4 soap_get__ns1__findServerResponse(struct soap *soap, _ns1__findServerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findServerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__findServerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findServerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findServerResponse * SOAP_FMAC4 soap_in__ns1__findServerResponse(struct soap *soap, const char *tag, _ns1__findServerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findServerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findServerResponse, sizeof(_ns1__findServerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findServerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findServerResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_found1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_found1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "found", &(a->_ns1__findServerResponse::found), "xsd:boolean"))
				{	soap_flag_found1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findServerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findServerResponse, 0, sizeof(_ns1__findServerResponse), 0, soap_copy__ns1__findServerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_found1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__findServerResponse * SOAP_FMAC4 soap_instantiate__ns1__findServerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findServerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findServerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findServerResponse;
		if (size)
			*size = sizeof(_ns1__findServerResponse);
		((_ns1__findServerResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findServerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__findServerResponse);
		for (int i = 0; i < n; i++)
			((_ns1__findServerResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findServerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findServerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findServerResponse %p -> %p\n", q, p));
	*(_ns1__findServerResponse*)p = *(_ns1__findServerResponse*)q;
}

void _ns1__findServer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__findServer::serverName = NULL;
	/* transient soap skipped */
}

void _ns1__findServer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__findServer::serverName);
	/* transient soap skipped */
}

int _ns1__findServer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__findServer);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__findServer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__findServer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__findServer(struct soap *soap, const char *tag, int id, const _ns1__findServer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__findServer), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "serverName", -1, &(a->_ns1__findServer::serverName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__findServer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__findServer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__findServer * SOAP_FMAC4 soap_get__ns1__findServer(struct soap *soap, _ns1__findServer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__findServer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__findServer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__findServer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__findServer * SOAP_FMAC4 soap_in__ns1__findServer(struct soap *soap, const char *tag, _ns1__findServer *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__findServer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__findServer, sizeof(_ns1__findServer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__findServer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__findServer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_serverName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serverName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "serverName", &(a->_ns1__findServer::serverName), "xsd:string"))
				{	soap_flag_serverName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__findServer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__findServer, 0, sizeof(_ns1__findServer), 0, soap_copy__ns1__findServer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__findServer * SOAP_FMAC4 soap_instantiate__ns1__findServer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__findServer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__findServer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__findServer;
		if (size)
			*size = sizeof(_ns1__findServer);
		((_ns1__findServer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__findServer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__findServer);
		for (int i = 0; i < n; i++)
			((_ns1__findServer*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__findServer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__findServer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__findServer %p -> %p\n", q, p));
	*(_ns1__findServer*)p = *(_ns1__findServer*)q;
}

void _ns1__setRobotPosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__setRobotPosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__setRobotPosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__setRobotPosResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__setRobotPosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__setRobotPosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRobotPosResponse(struct soap *soap, const char *tag, int id, const _ns1__setRobotPosResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRobotPosResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__setRobotPosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__setRobotPosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__setRobotPosResponse * SOAP_FMAC4 soap_get__ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRobotPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__setRobotPosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__setRobotPosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__setRobotPosResponse * SOAP_FMAC4 soap_in__ns1__setRobotPosResponse(struct soap *soap, const char *tag, _ns1__setRobotPosResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__setRobotPosResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRobotPosResponse, sizeof(_ns1__setRobotPosResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__setRobotPosResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__setRobotPosResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__setRobotPosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRobotPosResponse, 0, sizeof(_ns1__setRobotPosResponse), 0, soap_copy__ns1__setRobotPosResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__setRobotPosResponse * SOAP_FMAC4 soap_instantiate__ns1__setRobotPosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__setRobotPosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__setRobotPosResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__setRobotPosResponse;
		if (size)
			*size = sizeof(_ns1__setRobotPosResponse);
		((_ns1__setRobotPosResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__setRobotPosResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__setRobotPosResponse);
		for (int i = 0; i < n; i++)
			((_ns1__setRobotPosResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__setRobotPosResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__setRobotPosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__setRobotPosResponse %p -> %p\n", q, p));
	*(_ns1__setRobotPosResponse*)p = *(_ns1__setRobotPosResponse*)q;
}

void _ns1__setRobotJointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__setRobotJointPos::robot);
	this->_ns1__setRobotJointPos::pos = NULL;
	/* transient soap skipped */
}

void _ns1__setRobotJointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns1__setRobotJointPos::pos);
	/* transient soap skipped */
}

int _ns1__setRobotJointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__setRobotJointPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__setRobotJointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__setRobotJointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__setRobotJointPos(struct soap *soap, const char *tag, int id, const _ns1__setRobotJointPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__setRobotJointPos), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns1__setRobotJointPos::robot), ""))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "pos", -1, &(a->_ns1__setRobotJointPos::pos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__setRobotJointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__setRobotJointPos(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__setRobotJointPos * SOAP_FMAC4 soap_get__ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__setRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__setRobotJointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__setRobotJointPos(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__setRobotJointPos * SOAP_FMAC4 soap_in__ns1__setRobotJointPos(struct soap *soap, const char *tag, _ns1__setRobotJointPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__setRobotJointPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__setRobotJointPos, sizeof(_ns1__setRobotJointPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__setRobotJointPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__setRobotJointPos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_pos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns1__setRobotJointPos::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "pos", &(a->_ns1__setRobotJointPos::pos), "ns1:JointPos"))
				{	soap_flag_pos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__setRobotJointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__setRobotJointPos, 0, sizeof(_ns1__setRobotJointPos), 0, soap_copy__ns1__setRobotJointPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_pos1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__setRobotJointPos * SOAP_FMAC4 soap_instantiate__ns1__setRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__setRobotJointPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__setRobotJointPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__setRobotJointPos;
		if (size)
			*size = sizeof(_ns1__setRobotJointPos);
		((_ns1__setRobotJointPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__setRobotJointPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__setRobotJointPos);
		for (int i = 0; i < n; i++)
			((_ns1__setRobotJointPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__setRobotJointPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__setRobotJointPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__setRobotJointPos %p -> %p\n", q, p));
	*(_ns1__setRobotJointPos*)p = *(_ns1__setRobotJointPos*)q;
}

void _ns1__getRobotJntCartPosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getRobotJntCartPosResponse::jntPos = NULL;
	this->_ns1__getRobotJntCartPosResponse::cartPos = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotJntCartPosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns1__getRobotJntCartPosResponse::jntPos);
	soap_serialize_PointerTons1__CartesianPos(soap, &this->_ns1__getRobotJntCartPosResponse::cartPos);
	/* transient soap skipped */
}

int _ns1__getRobotJntCartPosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRobotJntCartPosResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getRobotJntCartPosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJntCartPosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, int id, const _ns1__getRobotJntCartPosResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJntCartPosResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "jntPos", -1, &(a->_ns1__getRobotJntCartPosResponse::jntPos), ""))
		return soap->error;
	if (soap_out_PointerTons1__CartesianPos(soap, "cartPos", -1, &(a->_ns1__getRobotJntCartPosResponse::cartPos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJntCartPosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJntCartPosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse * SOAP_FMAC4 soap_get__ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJntCartPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getRobotJntCartPosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJntCartPosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse * SOAP_FMAC4 soap_in__ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJntCartPosResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJntCartPosResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJntCartPosResponse, sizeof(_ns1__getRobotJntCartPosResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRobotJntCartPosResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRobotJntCartPosResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jntPos1 = 1;
	size_t soap_flag_cartPos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jntPos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "jntPos", &(a->_ns1__getRobotJntCartPosResponse::jntPos), "ns1:JointPos"))
				{	soap_flag_jntPos1--;
					continue;
				}
			if (soap_flag_cartPos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CartesianPos(soap, "cartPos", &(a->_ns1__getRobotJntCartPosResponse::cartPos), "ns1:CartesianPos"))
				{	soap_flag_cartPos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRobotJntCartPosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJntCartPosResponse, 0, sizeof(_ns1__getRobotJntCartPosResponse), 0, soap_copy__ns1__getRobotJntCartPosResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jntPos1 > 0 || soap_flag_cartPos1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse * SOAP_FMAC4 soap_instantiate__ns1__getRobotJntCartPosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJntCartPosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRobotJntCartPosResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getRobotJntCartPosResponse;
		if (size)
			*size = sizeof(_ns1__getRobotJntCartPosResponse);
		((_ns1__getRobotJntCartPosResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getRobotJntCartPosResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRobotJntCartPosResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getRobotJntCartPosResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRobotJntCartPosResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRobotJntCartPosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRobotJntCartPosResponse %p -> %p\n", q, p));
	*(_ns1__getRobotJntCartPosResponse*)p = *(_ns1__getRobotJntCartPosResponse*)q;
}

void _ns1__getRobotJntCartPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getRobotJntCartPos::robot);
	this->_ns1__getRobotJntCartPos::tool = NULL;
	this->_ns1__getRobotJntCartPos::frame = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotJntCartPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CartesianPos(soap, &this->_ns1__getRobotJntCartPos::tool);
	soap_serialize_PointerTons1__CartesianPos(soap, &this->_ns1__getRobotJntCartPos::frame);
	/* transient soap skipped */
}

int _ns1__getRobotJntCartPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRobotJntCartPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getRobotJntCartPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJntCartPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJntCartPos(struct soap *soap, const char *tag, int id, const _ns1__getRobotJntCartPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJntCartPos), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns1__getRobotJntCartPos::robot), ""))
		return soap->error;
	if (soap_out_PointerTons1__CartesianPos(soap, "tool", -1, &(a->_ns1__getRobotJntCartPos::tool), ""))
		return soap->error;
	if (soap_out_PointerTons1__CartesianPos(soap, "frame", -1, &(a->_ns1__getRobotJntCartPos::frame), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJntCartPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJntCartPos(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPos * SOAP_FMAC4 soap_get__ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJntCartPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getRobotJntCartPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJntCartPos(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPos * SOAP_FMAC4 soap_in__ns1__getRobotJntCartPos(struct soap *soap, const char *tag, _ns1__getRobotJntCartPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJntCartPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJntCartPos, sizeof(_ns1__getRobotJntCartPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRobotJntCartPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRobotJntCartPos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	size_t soap_flag_tool1 = 1;
	size_t soap_flag_frame1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns1__getRobotJntCartPos::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			if (soap_flag_tool1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CartesianPos(soap, "tool", &(a->_ns1__getRobotJntCartPos::tool), "ns1:CartesianPos"))
				{	soap_flag_tool1--;
					continue;
				}
			if (soap_flag_frame1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CartesianPos(soap, "frame", &(a->_ns1__getRobotJntCartPos::frame), "ns1:CartesianPos"))
				{	soap_flag_frame1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRobotJntCartPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJntCartPos, 0, sizeof(_ns1__getRobotJntCartPos), 0, soap_copy__ns1__getRobotJntCartPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0 || soap_flag_tool1 > 0 || soap_flag_frame1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getRobotJntCartPos * SOAP_FMAC4 soap_instantiate__ns1__getRobotJntCartPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJntCartPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRobotJntCartPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getRobotJntCartPos;
		if (size)
			*size = sizeof(_ns1__getRobotJntCartPos);
		((_ns1__getRobotJntCartPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getRobotJntCartPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRobotJntCartPos);
		for (int i = 0; i < n; i++)
			((_ns1__getRobotJntCartPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRobotJntCartPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRobotJntCartPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRobotJntCartPos %p -> %p\n", q, p));
	*(_ns1__getRobotJntCartPos*)p = *(_ns1__getRobotJntCartPos*)q;
}

void _ns1__getRobotJointPosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getRobotJointPosResponse::pos = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotJointPosResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JointPos(soap, &this->_ns1__getRobotJointPosResponse::pos);
	/* transient soap skipped */
}

int _ns1__getRobotJointPosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRobotJointPosResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getRobotJointPosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJointPosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, int id, const _ns1__getRobotJointPosResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJointPosResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JointPos(soap, "pos", -1, &(a->_ns1__getRobotJointPosResponse::pos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJointPosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJointPosResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse * SOAP_FMAC4 soap_get__ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJointPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getRobotJointPosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJointPosResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse * SOAP_FMAC4 soap_in__ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJointPosResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJointPosResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJointPosResponse, sizeof(_ns1__getRobotJointPosResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRobotJointPosResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRobotJointPosResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_pos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JointPos(soap, "pos", &(a->_ns1__getRobotJointPosResponse::pos), "ns1:JointPos"))
				{	soap_flag_pos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRobotJointPosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJointPosResponse, 0, sizeof(_ns1__getRobotJointPosResponse), 0, soap_copy__ns1__getRobotJointPosResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pos1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse * SOAP_FMAC4 soap_instantiate__ns1__getRobotJointPosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJointPosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRobotJointPosResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getRobotJointPosResponse;
		if (size)
			*size = sizeof(_ns1__getRobotJointPosResponse);
		((_ns1__getRobotJointPosResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getRobotJointPosResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRobotJointPosResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getRobotJointPosResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRobotJointPosResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRobotJointPosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRobotJointPosResponse %p -> %p\n", q, p));
	*(_ns1__getRobotJointPosResponse*)p = *(_ns1__getRobotJointPosResponse*)q;
}

void _ns1__getRobotJointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__getRobotJointPos::robot);
	/* transient soap skipped */
}

void _ns1__getRobotJointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getRobotJointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRobotJointPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getRobotJointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotJointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotJointPos(struct soap *soap, const char *tag, int id, const _ns1__getRobotJointPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotJointPos), type))
		return soap->error;
	if (soap_out_int(soap, "robot", -1, &(a->_ns1__getRobotJointPos::robot), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotJointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotJointPos(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotJointPos * SOAP_FMAC4 soap_get__ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getRobotJointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotJointPos(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotJointPos * SOAP_FMAC4 soap_in__ns1__getRobotJointPos(struct soap *soap, const char *tag, _ns1__getRobotJointPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotJointPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotJointPos, sizeof(_ns1__getRobotJointPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRobotJointPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRobotJointPos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_robot1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_robot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "robot", &(a->_ns1__getRobotJointPos::robot), "xsd:int"))
				{	soap_flag_robot1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRobotJointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotJointPos, 0, sizeof(_ns1__getRobotJointPos), 0, soap_copy__ns1__getRobotJointPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_robot1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getRobotJointPos * SOAP_FMAC4 soap_instantiate__ns1__getRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotJointPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRobotJointPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getRobotJointPos;
		if (size)
			*size = sizeof(_ns1__getRobotJointPos);
		((_ns1__getRobotJointPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getRobotJointPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRobotJointPos);
		for (int i = 0; i < n; i++)
			((_ns1__getRobotJointPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRobotJointPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRobotJointPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRobotJointPos %p -> %p\n", q, p));
	*(_ns1__getRobotJointPos*)p = *(_ns1__getRobotJointPos*)q;
}

void _ns1__getRobotsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getRobotsResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getRobotsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Robots(soap, &this->_ns1__getRobotsResponse::out);
	/* transient soap skipped */
}

int _ns1__getRobotsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRobotsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getRobotsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobotsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobotsResponse(struct soap *soap, const char *tag, int id, const _ns1__getRobotsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobotsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Robots(soap, "out", -1, &(a->_ns1__getRobotsResponse::out), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobotsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobotsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobotsResponse * SOAP_FMAC4 soap_get__ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobotsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getRobotsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobotsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobotsResponse * SOAP_FMAC4 soap_in__ns1__getRobotsResponse(struct soap *soap, const char *tag, _ns1__getRobotsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobotsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobotsResponse, sizeof(_ns1__getRobotsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRobotsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRobotsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Robots(soap, "out", &(a->_ns1__getRobotsResponse::out), "ns1:Robots"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRobotsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobotsResponse, 0, sizeof(_ns1__getRobotsResponse), 0, soap_copy__ns1__getRobotsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getRobotsResponse * SOAP_FMAC4 soap_instantiate__ns1__getRobotsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobotsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRobotsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getRobotsResponse;
		if (size)
			*size = sizeof(_ns1__getRobotsResponse);
		((_ns1__getRobotsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getRobotsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRobotsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getRobotsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRobotsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRobotsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRobotsResponse %p -> %p\n", q, p));
	*(_ns1__getRobotsResponse*)p = *(_ns1__getRobotsResponse*)q;
}

void _ns1__getRobots::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getRobots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getRobots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getRobots);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getRobots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getRobots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getRobots(struct soap *soap, const char *tag, int id, const _ns1__getRobots *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getRobots), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getRobots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getRobots(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getRobots * SOAP_FMAC4 soap_get__ns1__getRobots(struct soap *soap, _ns1__getRobots *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getRobots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getRobots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getRobots(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getRobots * SOAP_FMAC4 soap_in__ns1__getRobots(struct soap *soap, const char *tag, _ns1__getRobots *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getRobots *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getRobots, sizeof(_ns1__getRobots), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getRobots)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getRobots *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getRobots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getRobots, 0, sizeof(_ns1__getRobots), 0, soap_copy__ns1__getRobots);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getRobots * SOAP_FMAC4 soap_instantiate__ns1__getRobots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getRobots(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getRobots, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getRobots;
		if (size)
			*size = sizeof(_ns1__getRobots);
		((_ns1__getRobots*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getRobots[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getRobots);
		for (int i = 0; i < n; i++)
			((_ns1__getRobots*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getRobots*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getRobots(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getRobots %p -> %p\n", q, p));
	*(_ns1__getRobots*)p = *(_ns1__getRobots*)q;
}

void _ns1__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__logoutResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__logoutResponse(struct soap *soap, const char *tag, int id, const _ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__logoutResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__logoutResponse * SOAP_FMAC4 soap_get__ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__logoutResponse * SOAP_FMAC4 soap_in__ns1__logoutResponse(struct soap *soap, const char *tag, _ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__logoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__logoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__logoutResponse, 0, sizeof(_ns1__logoutResponse), 0, soap_copy__ns1__logoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__logoutResponse * SOAP_FMAC4 soap_instantiate__ns1__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__logoutResponse;
		if (size)
			*size = sizeof(_ns1__logoutResponse);
		((_ns1__logoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__logoutResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__logoutResponse);
		for (int i = 0; i < n; i++)
			((_ns1__logoutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__logoutResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__logoutResponse %p -> %p\n", q, p));
	*(_ns1__logoutResponse*)p = *(_ns1__logoutResponse*)q;
}

void _ns1__logout::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__logout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__logout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__logout);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__logout(struct soap *soap, const char *tag, int id, const _ns1__logout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__logout), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__logout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__logout(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__logout * SOAP_FMAC4 soap_get__ns1__logout(struct soap *soap, _ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__logout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__logout(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__logout * SOAP_FMAC4 soap_in__ns1__logout(struct soap *soap, const char *tag, _ns1__logout *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__logout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__logout, sizeof(_ns1__logout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__logout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__logout *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__logout, 0, sizeof(_ns1__logout), 0, soap_copy__ns1__logout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__logout * SOAP_FMAC4 soap_instantiate__ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__logout;
		if (size)
			*size = sizeof(_ns1__logout);
		((_ns1__logout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__logout[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__logout);
		for (int i = 0; i < n; i++)
			((_ns1__logout*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__logout*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__logout %p -> %p\n", q, p));
	*(_ns1__logout*)p = *(_ns1__logout*)q;
}

void _ns1__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__SessionId(soap, &this->_ns1__loginResponse::sid);
	/* transient soap skipped */
}

void _ns1__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__loginResponse::sid, SOAP_TYPE_ns1__SessionId);
	/* transient soap skipped */
}

int _ns1__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__loginResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__loginResponse(struct soap *soap, const char *tag, int id, const _ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__loginResponse), type))
		return soap->error;
	if (soap_out_ns1__SessionId(soap, "sid", -1, &(a->_ns1__loginResponse::sid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_get__ns1__loginResponse(struct soap *soap, _ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_in__ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__loginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__loginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SessionId(soap, "sid", &(a->_ns1__loginResponse::sid), "ns1:SessionId"))
				{	soap_flag_sid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__loginResponse, 0, sizeof(_ns1__loginResponse), 0, soap_copy__ns1__loginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__loginResponse * SOAP_FMAC4 soap_instantiate__ns1__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__loginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__loginResponse;
		if (size)
			*size = sizeof(_ns1__loginResponse);
		((_ns1__loginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__loginResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__loginResponse);
		for (int i = 0; i < n; i++)
			((_ns1__loginResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__loginResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__loginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__loginResponse %p -> %p\n", q, p));
	*(_ns1__loginResponse*)p = *(_ns1__loginResponse*)q;
}

void _ns1__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__login::user = NULL;
	this->_ns1__login::pwd = NULL;
	/* transient soap skipped */
}

void _ns1__login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__login::user);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__login::pwd);
	/* transient soap skipped */
}

int _ns1__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__login);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__login(struct soap *soap, const char *tag, int id, const _ns1__login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "user", -1, &(a->_ns1__login::user), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pwd", -1, &(a->_ns1__login::pwd), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__login(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__login * SOAP_FMAC4 soap_get__ns1__login(struct soap *soap, _ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__login(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__login * SOAP_FMAC4 soap_in__ns1__login(struct soap *soap, const char *tag, _ns1__login *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__login, sizeof(_ns1__login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__login)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__login *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_user1 = 1;
	size_t soap_flag_pwd1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "user", &(a->_ns1__login::user), "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_pwd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pwd", &(a->_ns1__login::pwd), "xsd:string"))
				{	soap_flag_pwd1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__login, 0, sizeof(_ns1__login), 0, soap_copy__ns1__login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__login * SOAP_FMAC4 soap_instantiate__ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__login;
		if (size)
			*size = sizeof(_ns1__login);
		((_ns1__login*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__login[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__login);
		for (int i = 0; i < n; i++)
			((_ns1__login*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__login*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__login %p -> %p\n", q, p));
	*(_ns1__login*)p = *(_ns1__login*)q;
}

void _ns1__getCS8VersionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getCS8VersionsResponse::out = NULL;
	/* transient soap skipped */
}

void _ns1__getCS8VersionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Versions(soap, &this->_ns1__getCS8VersionsResponse::out);
	/* transient soap skipped */
}

int _ns1__getCS8VersionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getCS8VersionsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getCS8VersionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8VersionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, int id, const _ns1__getCS8VersionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8VersionsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Versions(soap, "out", -1, &(a->_ns1__getCS8VersionsResponse::out), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8VersionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8VersionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse * SOAP_FMAC4 soap_get__ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8VersionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getCS8VersionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8VersionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse * SOAP_FMAC4 soap_in__ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, _ns1__getCS8VersionsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8VersionsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8VersionsResponse, sizeof(_ns1__getCS8VersionsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getCS8VersionsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getCS8VersionsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_out1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Versions(soap, "out", &(a->_ns1__getCS8VersionsResponse::out), "ns1:Versions"))
				{	soap_flag_out1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getCS8VersionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8VersionsResponse, 0, sizeof(_ns1__getCS8VersionsResponse), 0, soap_copy__ns1__getCS8VersionsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse * SOAP_FMAC4 soap_instantiate__ns1__getCS8VersionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8VersionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getCS8VersionsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getCS8VersionsResponse;
		if (size)
			*size = sizeof(_ns1__getCS8VersionsResponse);
		((_ns1__getCS8VersionsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getCS8VersionsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getCS8VersionsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getCS8VersionsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getCS8VersionsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getCS8VersionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getCS8VersionsResponse %p -> %p\n", q, p));
	*(_ns1__getCS8VersionsResponse*)p = *(_ns1__getCS8VersionsResponse*)q;
}

void _ns1__getCS8Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getCS8Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__getCS8Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getCS8Versions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getCS8Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getCS8Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getCS8Versions(struct soap *soap, const char *tag, int id, const _ns1__getCS8Versions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getCS8Versions), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getCS8Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getCS8Versions(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getCS8Versions * SOAP_FMAC4 soap_get__ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getCS8Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getCS8Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getCS8Versions(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getCS8Versions * SOAP_FMAC4 soap_in__ns1__getCS8Versions(struct soap *soap, const char *tag, _ns1__getCS8Versions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getCS8Versions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getCS8Versions, sizeof(_ns1__getCS8Versions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getCS8Versions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getCS8Versions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getCS8Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getCS8Versions, 0, sizeof(_ns1__getCS8Versions), 0, soap_copy__ns1__getCS8Versions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getCS8Versions * SOAP_FMAC4 soap_instantiate__ns1__getCS8Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getCS8Versions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getCS8Versions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getCS8Versions;
		if (size)
			*size = sizeof(_ns1__getCS8Versions);
		((_ns1__getCS8Versions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getCS8Versions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getCS8Versions);
		for (int i = 0; i < n; i++)
			((_ns1__getCS8Versions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getCS8Versions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getCS8Versions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getCS8Versions %p -> %p\n", q, p));
	*(_ns1__getCS8Versions*)p = *(_ns1__getCS8Versions*)q;
}

void _ns1__pingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__pingResponse::message = NULL;
	/* transient soap skipped */
}

void _ns1__pingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__pingResponse::message);
	/* transient soap skipped */
}

int _ns1__pingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__pingResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__pingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__pingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__pingResponse(struct soap *soap, const char *tag, int id, const _ns1__pingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__pingResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->_ns1__pingResponse::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__pingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__pingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__pingResponse * SOAP_FMAC4 soap_get__ns1__pingResponse(struct soap *soap, _ns1__pingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__pingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__pingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__pingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__pingResponse * SOAP_FMAC4 soap_in__ns1__pingResponse(struct soap *soap, const char *tag, _ns1__pingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__pingResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__pingResponse, sizeof(_ns1__pingResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__pingResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__pingResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->_ns1__pingResponse::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__pingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__pingResponse, 0, sizeof(_ns1__pingResponse), 0, soap_copy__ns1__pingResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__pingResponse * SOAP_FMAC4 soap_instantiate__ns1__pingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__pingResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__pingResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__pingResponse;
		if (size)
			*size = sizeof(_ns1__pingResponse);
		((_ns1__pingResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__pingResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__pingResponse);
		for (int i = 0; i < n; i++)
			((_ns1__pingResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__pingResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__pingResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__pingResponse %p -> %p\n", q, p));
	*(_ns1__pingResponse*)p = *(_ns1__pingResponse*)q;
}

void _ns1__ping::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ping::message = NULL;
	/* transient soap skipped */
}

void _ns1__ping::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ping::message);
	/* transient soap skipped */
}

int _ns1__ping::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ping);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ping::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ping(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ping(struct soap *soap, const char *tag, int id, const _ns1__ping *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ping), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->_ns1__ping::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ping::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ping(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ping * SOAP_FMAC4 soap_get__ns1__ping(struct soap *soap, _ns1__ping *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__ping::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ping(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ping * SOAP_FMAC4 soap_in__ns1__ping(struct soap *soap, const char *tag, _ns1__ping *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ping *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ping, sizeof(_ns1__ping), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ping)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ping *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->_ns1__ping::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ping *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ping, 0, sizeof(_ns1__ping), 0, soap_copy__ns1__ping);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__ping * SOAP_FMAC4 soap_instantiate__ns1__ping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ping(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ping, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ping;
		if (size)
			*size = sizeof(_ns1__ping);
		((_ns1__ping*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__ping[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ping);
		for (int i = 0; i < n; i++)
			((_ns1__ping*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ping*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ping(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ping %p -> %p\n", q, p));
	*(_ns1__ping*)p = *(_ns1__ping*)q;
}

void _ns1__getSoapServerVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getSoapServerVersionResponse::server = NULL;
	/* transient soap skipped */
}

void _ns1__getSoapServerVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SoapServerVersion(soap, &this->_ns1__getSoapServerVersionResponse::server);
	/* transient soap skipped */
}

int _ns1__getSoapServerVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSoapServerVersionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getSoapServerVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSoapServerVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__getSoapServerVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSoapServerVersionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__SoapServerVersion(soap, "server", -1, &(a->_ns1__getSoapServerVersionResponse::server), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSoapServerVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSoapServerVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse * SOAP_FMAC4 soap_get__ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSoapServerVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getSoapServerVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSoapServerVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse * SOAP_FMAC4 soap_in__ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, _ns1__getSoapServerVersionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSoapServerVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSoapServerVersionResponse, sizeof(_ns1__getSoapServerVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSoapServerVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSoapServerVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_server1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_server1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoapServerVersion(soap, "server", &(a->_ns1__getSoapServerVersionResponse::server), "ns1:SoapServerVersion"))
				{	soap_flag_server1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSoapServerVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSoapServerVersionResponse, 0, sizeof(_ns1__getSoapServerVersionResponse), 0, soap_copy__ns1__getSoapServerVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_server1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse * SOAP_FMAC4 soap_instantiate__ns1__getSoapServerVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSoapServerVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSoapServerVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getSoapServerVersionResponse;
		if (size)
			*size = sizeof(_ns1__getSoapServerVersionResponse);
		((_ns1__getSoapServerVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getSoapServerVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSoapServerVersionResponse);
		for (int i = 0; i < n; i++)
			((_ns1__getSoapServerVersionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSoapServerVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSoapServerVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSoapServerVersionResponse %p -> %p\n", q, p));
	*(_ns1__getSoapServerVersionResponse*)p = *(_ns1__getSoapServerVersionResponse*)q;
}

void _ns1__getSoapServerVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__getSoapServerVersion::cltName = NULL;
	this->_ns1__getSoapServerVersion::cltVersion = NULL;
	/* transient soap skipped */
}

void _ns1__getSoapServerVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getSoapServerVersion::cltName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__getSoapServerVersion::cltVersion);
	/* transient soap skipped */
}

int _ns1__getSoapServerVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__getSoapServerVersion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__getSoapServerVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getSoapServerVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getSoapServerVersion(struct soap *soap, const char *tag, int id, const _ns1__getSoapServerVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getSoapServerVersion), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "cltName", -1, &(a->_ns1__getSoapServerVersion::cltName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "cltVersion", -1, &(a->_ns1__getSoapServerVersion::cltVersion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__getSoapServerVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getSoapServerVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersion * SOAP_FMAC4 soap_get__ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getSoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__getSoapServerVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getSoapServerVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersion * SOAP_FMAC4 soap_in__ns1__getSoapServerVersion(struct soap *soap, const char *tag, _ns1__getSoapServerVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getSoapServerVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getSoapServerVersion, sizeof(_ns1__getSoapServerVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__getSoapServerVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__getSoapServerVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cltName1 = 1;
	size_t soap_flag_cltVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cltName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "cltName", &(a->_ns1__getSoapServerVersion::cltName), "xsd:string"))
				{	soap_flag_cltName1--;
					continue;
				}
			if (soap_flag_cltVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "cltVersion", &(a->_ns1__getSoapServerVersion::cltVersion), "xsd:string"))
				{	soap_flag_cltVersion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getSoapServerVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getSoapServerVersion, 0, sizeof(_ns1__getSoapServerVersion), 0, soap_copy__ns1__getSoapServerVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 _ns1__getSoapServerVersion * SOAP_FMAC4 soap_instantiate__ns1__getSoapServerVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getSoapServerVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__getSoapServerVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__getSoapServerVersion;
		if (size)
			*size = sizeof(_ns1__getSoapServerVersion);
		((_ns1__getSoapServerVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__getSoapServerVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__getSoapServerVersion);
		for (int i = 0; i < n; i++)
			((_ns1__getSoapServerVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__getSoapServerVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__getSoapServerVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__getSoapServerVersion %p -> %p\n", q, p));
	*(_ns1__getSoapServerVersion*)p = *(_ns1__getSoapServerVersion*)q;
}

void ns1__Parameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns1__Parameters::Parameters);
	/* transient soap skipped */
}

void ns1__Parameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Parameter(soap, &this->ns1__Parameters::Parameters);
	/* transient soap skipped */
}

int ns1__Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Parameters);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Parameters(struct soap *soap, const char *tag, int id, const ns1__Parameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Parameters), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", -1, &(a->ns1__Parameters::Parameters), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Parameters(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Parameters * SOAP_FMAC4 soap_get_ns1__Parameters(struct soap *soap, ns1__Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Parameters(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Parameters * SOAP_FMAC4 soap_in_ns1__Parameters(struct soap *soap, const char *tag, ns1__Parameters *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Parameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Parameters, sizeof(ns1__Parameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Parameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Parameters *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Parameter(soap, "Parameters", &(a->ns1__Parameters::Parameters), "ns1:Parameter"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Parameters, 0, sizeof(ns1__Parameters), 0, soap_copy_ns1__Parameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Parameters * SOAP_FMAC4 soap_instantiate_ns1__Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Parameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Parameters, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Parameters;
		if (size)
			*size = sizeof(ns1__Parameters);
		((ns1__Parameters*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Parameters[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Parameters);
		for (int i = 0; i < n; i++)
			((ns1__Parameters*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Parameters*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Parameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Parameters %p -> %p\n", q, p));
	*(ns1__Parameters*)p = *(ns1__Parameters*)q;
}

void ns1__Parameter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Parameter::key = NULL;
	this->ns1__Parameter::name = NULL;
	this->ns1__Parameter::value = NULL;
	/* transient soap skipped */
}

void ns1__Parameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Parameter::key);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Parameter::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Parameter::value);
	/* transient soap skipped */
}

int ns1__Parameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Parameter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Parameter(struct soap *soap, const char *tag, int id, const ns1__Parameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Parameter), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "key", -1, &(a->ns1__Parameter::key), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__Parameter::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "value", -1, &(a->ns1__Parameter::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Parameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Parameter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Parameter * SOAP_FMAC4 soap_get_ns1__Parameter(struct soap *soap, ns1__Parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Parameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Parameter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Parameter * SOAP_FMAC4 soap_in_ns1__Parameter(struct soap *soap, const char *tag, ns1__Parameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Parameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Parameter, sizeof(ns1__Parameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Parameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Parameter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_key1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "key", &(a->ns1__Parameter::key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__Parameter::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "value", &(a->ns1__Parameter::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Parameter, 0, sizeof(ns1__Parameter), 0, soap_copy_ns1__Parameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Parameter * SOAP_FMAC4 soap_instantiate_ns1__Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Parameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Parameter;
		if (size)
			*size = sizeof(ns1__Parameter);
		((ns1__Parameter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Parameter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Parameter);
		for (int i = 0; i < n; i++)
			((ns1__Parameter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Parameter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Parameter %p -> %p\n", q, p));
	*(ns1__Parameter*)p = *(ns1__Parameter*)q;
}

void ns1__Robots::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns1__Robots::Robots);
	/* transient soap skipped */
}

void ns1__Robots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Robot(soap, &this->ns1__Robots::Robots);
	/* transient soap skipped */
}

int ns1__Robots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Robots);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Robots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Robots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Robots(struct soap *soap, const char *tag, int id, const ns1__Robots *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Robots), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", -1, &(a->ns1__Robots::Robots), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Robots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Robots(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Robots * SOAP_FMAC4 soap_get_ns1__Robots(struct soap *soap, ns1__Robots *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Robots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Robots(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Robots * SOAP_FMAC4 soap_in_ns1__Robots(struct soap *soap, const char *tag, ns1__Robots *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Robots *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Robots, sizeof(ns1__Robots), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Robots)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Robots *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Robot(soap, "Robots", &(a->ns1__Robots::Robots), "ns1:Robot"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Robots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Robots, 0, sizeof(ns1__Robots), 0, soap_copy_ns1__Robots);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Robots * SOAP_FMAC4 soap_instantiate_ns1__Robots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Robots(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Robots, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Robots;
		if (size)
			*size = sizeof(ns1__Robots);
		((ns1__Robots*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Robots[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Robots);
		for (int i = 0; i < n; i++)
			((ns1__Robots*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Robots*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Robots(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Robots %p -> %p\n", q, p));
	*(ns1__Robots*)p = *(ns1__Robots*)q;
}

void ns1__SoapServerVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SoapServerVersion::version = "1.2";
	/* transient soap skipped */
}

void ns1__SoapServerVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__SoapServerVersion::version, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__SoapServerVersion::version);
	/* transient soap skipped */
}

int ns1__SoapServerVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoapServerVersion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SoapServerVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoapServerVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoapServerVersion(struct soap *soap, const char *tag, int id, const ns1__SoapServerVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoapServerVersion), type))
		return soap->error;
	if (soap_out_std__string(soap, "version", -1, &(a->ns1__SoapServerVersion::version), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SoapServerVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoapServerVersion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoapServerVersion * SOAP_FMAC4 soap_get_ns1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__SoapServerVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoapServerVersion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoapServerVersion * SOAP_FMAC4 soap_in_ns1__SoapServerVersion(struct soap *soap, const char *tag, ns1__SoapServerVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoapServerVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoapServerVersion, sizeof(ns1__SoapServerVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoapServerVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoapServerVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "version", &(a->ns1__SoapServerVersion::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoapServerVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoapServerVersion, 0, sizeof(ns1__SoapServerVersion), 0, soap_copy_ns1__SoapServerVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__SoapServerVersion * SOAP_FMAC4 soap_instantiate_ns1__SoapServerVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoapServerVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoapServerVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SoapServerVersion;
		if (size)
			*size = sizeof(ns1__SoapServerVersion);
		((ns1__SoapServerVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SoapServerVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoapServerVersion);
		for (int i = 0; i < n; i++)
			((ns1__SoapServerVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoapServerVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoapServerVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoapServerVersion %p -> %p\n", q, p));
	*(ns1__SoapServerVersion*)p = *(ns1__SoapServerVersion*)q;
}

void ns1__Versions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns1__Versions::Versions);
	/* transient soap skipped */
}

void ns1__Versions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Version(soap, &this->ns1__Versions::Versions);
	/* transient soap skipped */
}

int ns1__Versions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Versions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Versions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Versions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Versions(struct soap *soap, const char *tag, int id, const ns1__Versions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Versions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", -1, &(a->ns1__Versions::Versions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Versions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Versions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Versions * SOAP_FMAC4 soap_get_ns1__Versions(struct soap *soap, ns1__Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Versions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Versions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Versions * SOAP_FMAC4 soap_in_ns1__Versions(struct soap *soap, const char *tag, ns1__Versions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Versions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Versions, sizeof(ns1__Versions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Versions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Versions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Version(soap, "Versions", &(a->ns1__Versions::Versions), "ns1:Version"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Versions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Versions, 0, sizeof(ns1__Versions), 0, soap_copy_ns1__Versions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Versions * SOAP_FMAC4 soap_instantiate_ns1__Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Versions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Versions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Versions;
		if (size)
			*size = sizeof(ns1__Versions);
		((ns1__Versions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Versions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Versions);
		for (int i = 0; i < n; i++)
			((ns1__Versions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Versions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Versions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Versions %p -> %p\n", q, p));
	*(ns1__Versions*)p = *(ns1__Versions*)q;
}

void ns1__Version::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Version::name = NULL;
	this->ns1__Version::version = NULL;
	/* transient soap skipped */
}

void ns1__Version::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Version::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Version::version);
	/* transient soap skipped */
}

int ns1__Version::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Version);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Version::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Version(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Version(struct soap *soap, const char *tag, int id, const ns1__Version *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Version), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__Version::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "version", -1, &(a->ns1__Version::version), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Version::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Version(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Version * SOAP_FMAC4 soap_get_ns1__Version(struct soap *soap, ns1__Version *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Version(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Version::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Version(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Version * SOAP_FMAC4 soap_in_ns1__Version(struct soap *soap, const char *tag, ns1__Version *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Version *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Version, sizeof(ns1__Version), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Version)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Version *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__Version::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "version", &(a->ns1__Version::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Version *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Version, 0, sizeof(ns1__Version), 0, soap_copy_ns1__Version);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Version * SOAP_FMAC4 soap_instantiate_ns1__Version(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Version(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Version, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Version;
		if (size)
			*size = sizeof(ns1__Version);
		((ns1__Version*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Version[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Version);
		for (int i = 0; i < n; i++)
			((ns1__Version*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Version*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Version(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Version %p -> %p\n", q, p));
	*(ns1__Version*)p = *(ns1__Version*)q;
}

void ns1__Robot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Kinematic(soap, &this->ns1__Robot::kinematic);
	this->ns1__Robot::arm = NULL;
	this->ns1__Robot::tuning = NULL;
	soap_default_ns1__MountType(soap, &this->ns1__Robot::mountType);
	soap_default_ns1__LengthAxis3(soap, &this->ns1__Robot::lengthAxis3);
	soap_default_ns1__DiameterAxis3(soap, &this->ns1__Robot::diameterAxis3);
	/* transient soap skipped */
}

void ns1__Robot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Robot::arm);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Robot::tuning);
	/* transient soap skipped */
}

int ns1__Robot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Robot);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Robot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Robot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Robot(struct soap *soap, const char *tag, int id, const ns1__Robot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Robot), type))
		return soap->error;
	if (soap_out_ns1__Kinematic(soap, "kinematic", -1, &(a->ns1__Robot::kinematic), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arm", -1, &(a->ns1__Robot::arm), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tuning", -1, &(a->ns1__Robot::tuning), ""))
		return soap->error;
	if (soap_out_ns1__MountType(soap, "mountType", -1, &(a->ns1__Robot::mountType), ""))
		return soap->error;
	if (soap_out_ns1__LengthAxis3(soap, "lengthAxis3", -1, &(a->ns1__Robot::lengthAxis3), ""))
		return soap->error;
	if (soap_out_ns1__DiameterAxis3(soap, "diameterAxis3", -1, &(a->ns1__Robot::diameterAxis3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Robot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Robot(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Robot * SOAP_FMAC4 soap_get_ns1__Robot(struct soap *soap, ns1__Robot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Robot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Robot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Robot(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Robot * SOAP_FMAC4 soap_in_ns1__Robot(struct soap *soap, const char *tag, ns1__Robot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Robot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Robot, sizeof(ns1__Robot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Robot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Robot *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_kinematic1 = 1;
	size_t soap_flag_arm1 = 1;
	size_t soap_flag_tuning1 = 1;
	size_t soap_flag_mountType1 = 1;
	size_t soap_flag_lengthAxis31 = 1;
	size_t soap_flag_diameterAxis31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_kinematic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__Kinematic(soap, "kinematic", &(a->ns1__Robot::kinematic), "ns1:Kinematic"))
				{	soap_flag_kinematic1--;
					continue;
				}
			if (soap_flag_arm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arm", &(a->ns1__Robot::arm), "xsd:string"))
				{	soap_flag_arm1--;
					continue;
				}
			if (soap_flag_tuning1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tuning", &(a->ns1__Robot::tuning), "xsd:string"))
				{	soap_flag_tuning1--;
					continue;
				}
			if (soap_flag_mountType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__MountType(soap, "mountType", &(a->ns1__Robot::mountType), "ns1:MountType"))
				{	soap_flag_mountType1--;
					continue;
				}
			if (soap_flag_lengthAxis31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__LengthAxis3(soap, "lengthAxis3", &(a->ns1__Robot::lengthAxis3), "ns1:LengthAxis3"))
				{	soap_flag_lengthAxis31--;
					continue;
				}
			if (soap_flag_diameterAxis31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__DiameterAxis3(soap, "diameterAxis3", &(a->ns1__Robot::diameterAxis3), "ns1:DiameterAxis3"))
				{	soap_flag_diameterAxis31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Robot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Robot, 0, sizeof(ns1__Robot), 0, soap_copy_ns1__Robot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_kinematic1 > 0 || soap_flag_mountType1 > 0 || soap_flag_lengthAxis31 > 0 || soap_flag_diameterAxis31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__Robot * SOAP_FMAC4 soap_instantiate_ns1__Robot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Robot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Robot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Robot;
		if (size)
			*size = sizeof(ns1__Robot);
		((ns1__Robot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Robot[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Robot);
		for (int i = 0; i < n; i++)
			((ns1__Robot*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Robot*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Robot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Robot %p -> %p\n", q, p));
	*(ns1__Robot*)p = *(ns1__Robot*)q;
}

void ns1__CartesianPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns1__CartesianPos::x);
	soap_default_double(soap, &this->ns1__CartesianPos::y);
	soap_default_double(soap, &this->ns1__CartesianPos::z);
	soap_default_double(soap, &this->ns1__CartesianPos::rx);
	soap_default_double(soap, &this->ns1__CartesianPos::ry);
	soap_default_double(soap, &this->ns1__CartesianPos::rz);
	/* transient soap skipped */
}

void ns1__CartesianPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__CartesianPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CartesianPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CartesianPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CartesianPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CartesianPos(struct soap *soap, const char *tag, int id, const ns1__CartesianPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CartesianPos), type))
		return soap->error;
	if (soap_out_double(soap, "x", -1, &(a->ns1__CartesianPos::x), ""))
		return soap->error;
	if (soap_out_double(soap, "y", -1, &(a->ns1__CartesianPos::y), ""))
		return soap->error;
	if (soap_out_double(soap, "z", -1, &(a->ns1__CartesianPos::z), ""))
		return soap->error;
	if (soap_out_double(soap, "rx", -1, &(a->ns1__CartesianPos::rx), ""))
		return soap->error;
	if (soap_out_double(soap, "ry", -1, &(a->ns1__CartesianPos::ry), ""))
		return soap->error;
	if (soap_out_double(soap, "rz", -1, &(a->ns1__CartesianPos::rz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CartesianPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CartesianPos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CartesianPos * SOAP_FMAC4 soap_get_ns1__CartesianPos(struct soap *soap, ns1__CartesianPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CartesianPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__CartesianPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CartesianPos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CartesianPos * SOAP_FMAC4 soap_in_ns1__CartesianPos(struct soap *soap, const char *tag, ns1__CartesianPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CartesianPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CartesianPos, sizeof(ns1__CartesianPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CartesianPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CartesianPos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_x1 = 1;
	size_t soap_flag_y1 = 1;
	size_t soap_flag_z1 = 1;
	size_t soap_flag_rx1 = 1;
	size_t soap_flag_ry1 = 1;
	size_t soap_flag_rz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_x1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "x", &(a->ns1__CartesianPos::x), "xsd:double"))
				{	soap_flag_x1--;
					continue;
				}
			if (soap_flag_y1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "y", &(a->ns1__CartesianPos::y), "xsd:double"))
				{	soap_flag_y1--;
					continue;
				}
			if (soap_flag_z1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "z", &(a->ns1__CartesianPos::z), "xsd:double"))
				{	soap_flag_z1--;
					continue;
				}
			if (soap_flag_rx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "rx", &(a->ns1__CartesianPos::rx), "xsd:double"))
				{	soap_flag_rx1--;
					continue;
				}
			if (soap_flag_ry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ry", &(a->ns1__CartesianPos::ry), "xsd:double"))
				{	soap_flag_ry1--;
					continue;
				}
			if (soap_flag_rz1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "rz", &(a->ns1__CartesianPos::rz), "xsd:double"))
				{	soap_flag_rz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CartesianPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CartesianPos, 0, sizeof(ns1__CartesianPos), 0, soap_copy_ns1__CartesianPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_x1 > 0 || soap_flag_y1 > 0 || soap_flag_z1 > 0 || soap_flag_rx1 > 0 || soap_flag_ry1 > 0 || soap_flag_rz1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__CartesianPos * SOAP_FMAC4 soap_instantiate_ns1__CartesianPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CartesianPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CartesianPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CartesianPos;
		if (size)
			*size = sizeof(ns1__CartesianPos);
		((ns1__CartesianPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CartesianPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CartesianPos);
		for (int i = 0; i < n; i++)
			((ns1__CartesianPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CartesianPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CartesianPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CartesianPos %p -> %p\n", q, p));
	*(ns1__CartesianPos*)p = *(ns1__CartesianPos*)q;
}

void ns1__JointPos::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &this->ns1__JointPos::item);
	/* transient soap skipped */
}

void ns1__JointPos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdouble(soap, &this->ns1__JointPos::item);
	/* transient soap skipped */
}

int ns1__JointPos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__JointPos);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__JointPos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__JointPos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JointPos(struct soap *soap, const char *tag, int id, const ns1__JointPos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JointPos), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdouble(soap, "item", -1, &(a->ns1__JointPos::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__JointPos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__JointPos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__JointPos * SOAP_FMAC4 soap_get_ns1__JointPos(struct soap *soap, ns1__JointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__JointPos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__JointPos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__JointPos * SOAP_FMAC4 soap_in_ns1__JointPos(struct soap *soap, const char *tag, ns1__JointPos *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__JointPos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JointPos, sizeof(ns1__JointPos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__JointPos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__JointPos *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "item", &(a->ns1__JointPos::item), "xsd:double"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__JointPos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JointPos, 0, sizeof(ns1__JointPos), 0, soap_copy_ns1__JointPos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__JointPos::item.size() > 100))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__JointPos * SOAP_FMAC4 soap_instantiate_ns1__JointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__JointPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__JointPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__JointPos;
		if (size)
			*size = sizeof(ns1__JointPos);
		((ns1__JointPos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__JointPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__JointPos);
		for (int i = 0; i < n; i++)
			((ns1__JointPos*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__JointPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__JointPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__JointPos %p -> %p\n", q, p));
	*(ns1__JointPos*)p = *(ns1__JointPos*)q;
}

void ns1__ServerException::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ServerExceptionCode(soap, &this->ns1__ServerException::code);
	this->ns1__ServerException::description = NULL;
	/* transient soap skipped */
}

void ns1__ServerException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__ServerException::description);
	/* transient soap skipped */
}

int ns1__ServerException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ServerException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ServerException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ServerException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServerException(struct soap *soap, const char *tag, int id, const ns1__ServerException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServerException), type))
		return soap->error;
	if (soap_out_ns1__ServerExceptionCode(soap, "code", -1, &(a->ns1__ServerException::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__ServerException::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ServerException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ServerException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ServerException * SOAP_FMAC4 soap_get_ns1__ServerException(struct soap *soap, ns1__ServerException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServerException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ServerException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ServerException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ServerException * SOAP_FMAC4 soap_in_ns1__ServerException(struct soap *soap, const char *tag, ns1__ServerException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ServerException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServerException, sizeof(ns1__ServerException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ServerException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ServerException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ServerExceptionCode(soap, "code", &(a->ns1__ServerException::code), "ns1:ServerExceptionCode"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__ServerException::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ServerException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServerException, 0, sizeof(ns1__ServerException), 0, soap_copy_ns1__ServerException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__ServerException * SOAP_FMAC4 soap_instantiate_ns1__ServerException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ServerException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ServerException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ServerException;
		if (size)
			*size = sizeof(ns1__ServerException);
		((ns1__ServerException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ServerException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ServerException);
		for (int i = 0; i < n; i++)
			((ns1__ServerException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ServerException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ServerException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ServerException %p -> %p\n", q, p));
	*(ns1__ServerException*)p = *(ns1__ServerException*)q;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__hexBinary);
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__hexBinary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__hexBinary);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, 0, sizeof(xsd__hexBinary), 0, soap_copy_xsd__hexBinary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__hexBinary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__hexBinary;
		if (size)
			*size = sizeof(xsd__hexBinary);
	}
	else
	{	cp->ptr = (void*)new xsd__hexBinary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__hexBinary);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__hexBinary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__hexBinary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__hexBinary %p -> %p\n", q, p));
	*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__base64Binary;
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__base64Binary[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__setPower(struct soap *soap, struct __ns6__setPower *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__setPower = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__setPower(struct soap *soap, const struct __ns6__setPower *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__setPower(soap, &a->ns6__setPower);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__setPower(struct soap *soap, const struct __ns6__setPower *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__setPower(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__setPower(struct soap *soap, const char *tag, int id, const struct __ns6__setPower *a, const char *type)
{
	if (soap_out_PointerTo_ns6__setPower(soap, "ns6:setPower", -1, &a->ns6__setPower, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__setPower * SOAP_FMAC4 soap_get___ns6__setPower(struct soap *soap, struct __ns6__setPower *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__setPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__setPower * SOAP_FMAC4 soap_in___ns6__setPower(struct soap *soap, const char *tag, struct __ns6__setPower *a, const char *type)
{
	size_t soap_flag_ns6__setPower = 1;
	short soap_flag;
	a = (struct __ns6__setPower *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__setPower, sizeof(struct __ns6__setPower), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__setPower(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__setPower && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__setPower(soap, "ns6:setPower", &a->ns6__setPower, ""))
				{	soap_flag_ns6__setPower--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__setPower * SOAP_FMAC4 soap_instantiate___ns6__setPower(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__setPower(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__setPower, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__setPower;
		if (size)
			*size = sizeof(struct __ns6__setPower);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__setPower[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__setPower);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__setPower*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__setPower(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__setPower %p -> %p\n", q, p));
	*(struct __ns6__setPower*)p = *(struct __ns6__setPower*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__schedulerRefresh(struct soap *soap, struct __ns6__schedulerRefresh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__schedulerRefresh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__schedulerRefresh(struct soap *soap, const struct __ns6__schedulerRefresh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__schedulerRefresh(soap, &a->ns6__schedulerRefresh);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__schedulerRefresh(struct soap *soap, const struct __ns6__schedulerRefresh *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__schedulerRefresh(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__schedulerRefresh(struct soap *soap, const char *tag, int id, const struct __ns6__schedulerRefresh *a, const char *type)
{
	if (soap_out_PointerTo_ns6__schedulerRefresh(soap, "ns6:schedulerRefresh", -1, &a->ns6__schedulerRefresh, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__schedulerRefresh * SOAP_FMAC4 soap_get___ns6__schedulerRefresh(struct soap *soap, struct __ns6__schedulerRefresh *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__schedulerRefresh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__schedulerRefresh * SOAP_FMAC4 soap_in___ns6__schedulerRefresh(struct soap *soap, const char *tag, struct __ns6__schedulerRefresh *a, const char *type)
{
	size_t soap_flag_ns6__schedulerRefresh = 1;
	short soap_flag;
	a = (struct __ns6__schedulerRefresh *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__schedulerRefresh, sizeof(struct __ns6__schedulerRefresh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__schedulerRefresh(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__schedulerRefresh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__schedulerRefresh(soap, "ns6:schedulerRefresh", &a->ns6__schedulerRefresh, ""))
				{	soap_flag_ns6__schedulerRefresh--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__schedulerRefresh * SOAP_FMAC4 soap_instantiate___ns6__schedulerRefresh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__schedulerRefresh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__schedulerRefresh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__schedulerRefresh;
		if (size)
			*size = sizeof(struct __ns6__schedulerRefresh);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__schedulerRefresh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__schedulerRefresh);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__schedulerRefresh*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__schedulerRefresh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__schedulerRefresh %p -> %p\n", q, p));
	*(struct __ns6__schedulerRefresh*)p = *(struct __ns6__schedulerRefresh*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__setSchedulingMode(struct soap *soap, struct __ns6__setSchedulingMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__setSchedulingMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__setSchedulingMode(struct soap *soap, const struct __ns6__setSchedulingMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__setSchedulingMode(soap, &a->ns6__setSchedulingMode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__setSchedulingMode(struct soap *soap, const struct __ns6__setSchedulingMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__setSchedulingMode(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__setSchedulingMode(struct soap *soap, const char *tag, int id, const struct __ns6__setSchedulingMode *a, const char *type)
{
	if (soap_out_PointerTo_ns6__setSchedulingMode(soap, "ns6:setSchedulingMode", -1, &a->ns6__setSchedulingMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__setSchedulingMode * SOAP_FMAC4 soap_get___ns6__setSchedulingMode(struct soap *soap, struct __ns6__setSchedulingMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__setSchedulingMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__setSchedulingMode * SOAP_FMAC4 soap_in___ns6__setSchedulingMode(struct soap *soap, const char *tag, struct __ns6__setSchedulingMode *a, const char *type)
{
	size_t soap_flag_ns6__setSchedulingMode = 1;
	short soap_flag;
	a = (struct __ns6__setSchedulingMode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__setSchedulingMode, sizeof(struct __ns6__setSchedulingMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__setSchedulingMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__setSchedulingMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__setSchedulingMode(soap, "ns6:setSchedulingMode", &a->ns6__setSchedulingMode, ""))
				{	soap_flag_ns6__setSchedulingMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__setSchedulingMode * SOAP_FMAC4 soap_instantiate___ns6__setSchedulingMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__setSchedulingMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__setSchedulingMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__setSchedulingMode;
		if (size)
			*size = sizeof(struct __ns6__setSchedulingMode);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__setSchedulingMode[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__setSchedulingMode);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__setSchedulingMode*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__setSchedulingMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__setSchedulingMode %p -> %p\n", q, p));
	*(struct __ns6__setSchedulingMode*)p = *(struct __ns6__setSchedulingMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__restartMotion(struct soap *soap, struct __ns6__restartMotion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__restartMotion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__restartMotion(struct soap *soap, const struct __ns6__restartMotion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__restartMotion(soap, &a->ns6__restartMotion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__restartMotion(struct soap *soap, const struct __ns6__restartMotion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__restartMotion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__restartMotion(struct soap *soap, const char *tag, int id, const struct __ns6__restartMotion *a, const char *type)
{
	if (soap_out_PointerTo_ns6__restartMotion(soap, "ns6:restartMotion", -1, &a->ns6__restartMotion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__restartMotion * SOAP_FMAC4 soap_get___ns6__restartMotion(struct soap *soap, struct __ns6__restartMotion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__restartMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__restartMotion * SOAP_FMAC4 soap_in___ns6__restartMotion(struct soap *soap, const char *tag, struct __ns6__restartMotion *a, const char *type)
{
	size_t soap_flag_ns6__restartMotion = 1;
	short soap_flag;
	a = (struct __ns6__restartMotion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__restartMotion, sizeof(struct __ns6__restartMotion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__restartMotion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__restartMotion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__restartMotion(soap, "ns6:restartMotion", &a->ns6__restartMotion, ""))
				{	soap_flag_ns6__restartMotion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__restartMotion * SOAP_FMAC4 soap_instantiate___ns6__restartMotion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__restartMotion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__restartMotion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__restartMotion;
		if (size)
			*size = sizeof(struct __ns6__restartMotion);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__restartMotion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__restartMotion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__restartMotion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__restartMotion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__restartMotion %p -> %p\n", q, p));
	*(struct __ns6__restartMotion*)p = *(struct __ns6__restartMotion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__stopMotion(struct soap *soap, struct __ns6__stopMotion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__stopMotion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__stopMotion(struct soap *soap, const struct __ns6__stopMotion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__stopMotion(soap, &a->ns6__stopMotion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__stopMotion(struct soap *soap, const struct __ns6__stopMotion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__stopMotion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__stopMotion(struct soap *soap, const char *tag, int id, const struct __ns6__stopMotion *a, const char *type)
{
	if (soap_out_PointerTo_ns6__stopMotion(soap, "ns6:stopMotion", -1, &a->ns6__stopMotion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__stopMotion * SOAP_FMAC4 soap_get___ns6__stopMotion(struct soap *soap, struct __ns6__stopMotion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__stopMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__stopMotion * SOAP_FMAC4 soap_in___ns6__stopMotion(struct soap *soap, const char *tag, struct __ns6__stopMotion *a, const char *type)
{
	size_t soap_flag_ns6__stopMotion = 1;
	short soap_flag;
	a = (struct __ns6__stopMotion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__stopMotion, sizeof(struct __ns6__stopMotion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__stopMotion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__stopMotion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__stopMotion(soap, "ns6:stopMotion", &a->ns6__stopMotion, ""))
				{	soap_flag_ns6__stopMotion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__stopMotion * SOAP_FMAC4 soap_instantiate___ns6__stopMotion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__stopMotion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__stopMotion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__stopMotion;
		if (size)
			*size = sizeof(struct __ns6__stopMotion);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__stopMotion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__stopMotion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__stopMotion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__stopMotion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__stopMotion %p -> %p\n", q, p));
	*(struct __ns6__stopMotion*)p = *(struct __ns6__stopMotion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__resetMotion(struct soap *soap, struct __ns6__resetMotion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__resetMotion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__resetMotion(struct soap *soap, const struct __ns6__resetMotion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__resetMotion(soap, &a->ns6__resetMotion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__resetMotion(struct soap *soap, const struct __ns6__resetMotion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__resetMotion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__resetMotion(struct soap *soap, const char *tag, int id, const struct __ns6__resetMotion *a, const char *type)
{
	if (soap_out_PointerTo_ns6__resetMotion(soap, "ns6:resetMotion", -1, &a->ns6__resetMotion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__resetMotion * SOAP_FMAC4 soap_get___ns6__resetMotion(struct soap *soap, struct __ns6__resetMotion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__resetMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__resetMotion * SOAP_FMAC4 soap_in___ns6__resetMotion(struct soap *soap, const char *tag, struct __ns6__resetMotion *a, const char *type)
{
	size_t soap_flag_ns6__resetMotion = 1;
	short soap_flag;
	a = (struct __ns6__resetMotion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__resetMotion, sizeof(struct __ns6__resetMotion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__resetMotion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__resetMotion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__resetMotion(soap, "ns6:resetMotion", &a->ns6__resetMotion, ""))
				{	soap_flag_ns6__resetMotion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__resetMotion * SOAP_FMAC4 soap_instantiate___ns6__resetMotion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__resetMotion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__resetMotion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__resetMotion;
		if (size)
			*size = sizeof(struct __ns6__resetMotion);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__resetMotion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__resetMotion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__resetMotion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__resetMotion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__resetMotion %p -> %p\n", q, p));
	*(struct __ns6__resetMotion*)p = *(struct __ns6__resetMotion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__moveC(struct soap *soap, struct __ns6__moveC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__moveC = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__moveC(struct soap *soap, const struct __ns6__moveC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__moveC(soap, &a->ns6__moveC);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__moveC(struct soap *soap, const struct __ns6__moveC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__moveC(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__moveC(struct soap *soap, const char *tag, int id, const struct __ns6__moveC *a, const char *type)
{
	if (soap_out_PointerTo_ns6__moveC(soap, "ns6:moveC", -1, &a->ns6__moveC, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__moveC * SOAP_FMAC4 soap_get___ns6__moveC(struct soap *soap, struct __ns6__moveC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__moveC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__moveC * SOAP_FMAC4 soap_in___ns6__moveC(struct soap *soap, const char *tag, struct __ns6__moveC *a, const char *type)
{
	size_t soap_flag_ns6__moveC = 1;
	short soap_flag;
	a = (struct __ns6__moveC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__moveC, sizeof(struct __ns6__moveC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__moveC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__moveC && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__moveC(soap, "ns6:moveC", &a->ns6__moveC, ""))
				{	soap_flag_ns6__moveC--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__moveC * SOAP_FMAC4 soap_instantiate___ns6__moveC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__moveC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__moveC, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__moveC;
		if (size)
			*size = sizeof(struct __ns6__moveC);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__moveC[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__moveC);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__moveC*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__moveC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__moveC %p -> %p\n", q, p));
	*(struct __ns6__moveC*)p = *(struct __ns6__moveC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__moveL(struct soap *soap, struct __ns6__moveL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__moveL = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__moveL(struct soap *soap, const struct __ns6__moveL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__moveL(soap, &a->ns6__moveL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__moveL(struct soap *soap, const struct __ns6__moveL *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__moveL(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__moveL(struct soap *soap, const char *tag, int id, const struct __ns6__moveL *a, const char *type)
{
	if (soap_out_PointerTo_ns6__moveL(soap, "ns6:moveL", -1, &a->ns6__moveL, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__moveL * SOAP_FMAC4 soap_get___ns6__moveL(struct soap *soap, struct __ns6__moveL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__moveL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__moveL * SOAP_FMAC4 soap_in___ns6__moveL(struct soap *soap, const char *tag, struct __ns6__moveL *a, const char *type)
{
	size_t soap_flag_ns6__moveL = 1;
	short soap_flag;
	a = (struct __ns6__moveL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__moveL, sizeof(struct __ns6__moveL), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__moveL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__moveL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__moveL(soap, "ns6:moveL", &a->ns6__moveL, ""))
				{	soap_flag_ns6__moveL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__moveL * SOAP_FMAC4 soap_instantiate___ns6__moveL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__moveL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__moveL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__moveL;
		if (size)
			*size = sizeof(struct __ns6__moveL);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__moveL[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__moveL);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__moveL*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__moveL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__moveL %p -> %p\n", q, p));
	*(struct __ns6__moveL*)p = *(struct __ns6__moveL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__moveJC(struct soap *soap, struct __ns6__moveJC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__moveJC = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__moveJC(struct soap *soap, const struct __ns6__moveJC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__moveJC(soap, &a->ns6__moveJC);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__moveJC(struct soap *soap, const struct __ns6__moveJC *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__moveJC(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__moveJC(struct soap *soap, const char *tag, int id, const struct __ns6__moveJC *a, const char *type)
{
	if (soap_out_PointerTo_ns6__moveJC(soap, "ns6:moveJC", -1, &a->ns6__moveJC, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__moveJC * SOAP_FMAC4 soap_get___ns6__moveJC(struct soap *soap, struct __ns6__moveJC *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__moveJC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__moveJC * SOAP_FMAC4 soap_in___ns6__moveJC(struct soap *soap, const char *tag, struct __ns6__moveJC *a, const char *type)
{
	size_t soap_flag_ns6__moveJC = 1;
	short soap_flag;
	a = (struct __ns6__moveJC *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__moveJC, sizeof(struct __ns6__moveJC), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__moveJC(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__moveJC && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__moveJC(soap, "ns6:moveJC", &a->ns6__moveJC, ""))
				{	soap_flag_ns6__moveJC--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__moveJC * SOAP_FMAC4 soap_instantiate___ns6__moveJC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__moveJC(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__moveJC, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__moveJC;
		if (size)
			*size = sizeof(struct __ns6__moveJC);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__moveJC[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__moveJC);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__moveJC*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__moveJC(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__moveJC %p -> %p\n", q, p));
	*(struct __ns6__moveJC*)p = *(struct __ns6__moveJC*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__moveJJ(struct soap *soap, struct __ns6__moveJJ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__moveJJ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__moveJJ(struct soap *soap, const struct __ns6__moveJJ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__moveJJ(soap, &a->ns6__moveJJ);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__moveJJ(struct soap *soap, const struct __ns6__moveJJ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__moveJJ(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__moveJJ(struct soap *soap, const char *tag, int id, const struct __ns6__moveJJ *a, const char *type)
{
	if (soap_out_PointerTo_ns6__moveJJ(soap, "ns6:moveJJ", -1, &a->ns6__moveJJ, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__moveJJ * SOAP_FMAC4 soap_get___ns6__moveJJ(struct soap *soap, struct __ns6__moveJJ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__moveJJ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__moveJJ * SOAP_FMAC4 soap_in___ns6__moveJJ(struct soap *soap, const char *tag, struct __ns6__moveJJ *a, const char *type)
{
	size_t soap_flag_ns6__moveJJ = 1;
	short soap_flag;
	a = (struct __ns6__moveJJ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__moveJJ, sizeof(struct __ns6__moveJJ), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__moveJJ(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__moveJJ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__moveJJ(soap, "ns6:moveJJ", &a->ns6__moveJJ, ""))
				{	soap_flag_ns6__moveJJ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__moveJJ * SOAP_FMAC4 soap_instantiate___ns6__moveJJ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__moveJJ(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__moveJJ, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__moveJJ;
		if (size)
			*size = sizeof(struct __ns6__moveJJ);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__moveJJ[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__moveJJ);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__moveJJ*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__moveJJ(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__moveJJ %p -> %p\n", q, p));
	*(struct __ns6__moveJJ*)p = *(struct __ns6__moveJJ*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__reverseKin(struct soap *soap, struct __ns6__reverseKin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__reverseKin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__reverseKin(struct soap *soap, const struct __ns6__reverseKin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__reverseKin(soap, &a->ns6__reverseKin);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__reverseKin(struct soap *soap, const struct __ns6__reverseKin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__reverseKin(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__reverseKin(struct soap *soap, const char *tag, int id, const struct __ns6__reverseKin *a, const char *type)
{
	if (soap_out_PointerTo_ns6__reverseKin(soap, "ns6:reverseKin", -1, &a->ns6__reverseKin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__reverseKin * SOAP_FMAC4 soap_get___ns6__reverseKin(struct soap *soap, struct __ns6__reverseKin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__reverseKin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__reverseKin * SOAP_FMAC4 soap_in___ns6__reverseKin(struct soap *soap, const char *tag, struct __ns6__reverseKin *a, const char *type)
{
	size_t soap_flag_ns6__reverseKin = 1;
	short soap_flag;
	a = (struct __ns6__reverseKin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__reverseKin, sizeof(struct __ns6__reverseKin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__reverseKin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__reverseKin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__reverseKin(soap, "ns6:reverseKin", &a->ns6__reverseKin, ""))
				{	soap_flag_ns6__reverseKin--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__reverseKin * SOAP_FMAC4 soap_instantiate___ns6__reverseKin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__reverseKin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__reverseKin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__reverseKin;
		if (size)
			*size = sizeof(struct __ns6__reverseKin);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__reverseKin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__reverseKin);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__reverseKin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__reverseKin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__reverseKin %p -> %p\n", q, p));
	*(struct __ns6__reverseKin*)p = *(struct __ns6__reverseKin*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns6__forwardKin(struct soap *soap, struct __ns6__forwardKin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns6__forwardKin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns6__forwardKin(struct soap *soap, const struct __ns6__forwardKin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns6__forwardKin(soap, &a->ns6__forwardKin);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns6__forwardKin(struct soap *soap, const struct __ns6__forwardKin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns6__forwardKin(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns6__forwardKin(struct soap *soap, const char *tag, int id, const struct __ns6__forwardKin *a, const char *type)
{
	if (soap_out_PointerTo_ns6__forwardKin(soap, "ns6:forwardKin", -1, &a->ns6__forwardKin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns6__forwardKin * SOAP_FMAC4 soap_get___ns6__forwardKin(struct soap *soap, struct __ns6__forwardKin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns6__forwardKin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns6__forwardKin * SOAP_FMAC4 soap_in___ns6__forwardKin(struct soap *soap, const char *tag, struct __ns6__forwardKin *a, const char *type)
{
	size_t soap_flag_ns6__forwardKin = 1;
	short soap_flag;
	a = (struct __ns6__forwardKin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns6__forwardKin, sizeof(struct __ns6__forwardKin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns6__forwardKin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns6__forwardKin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns6__forwardKin(soap, "ns6:forwardKin", &a->ns6__forwardKin, ""))
				{	soap_flag_ns6__forwardKin--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns6__forwardKin * SOAP_FMAC4 soap_instantiate___ns6__forwardKin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns6__forwardKin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns6__forwardKin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns6__forwardKin;
		if (size)
			*size = sizeof(struct __ns6__forwardKin);
	}
	else
	{	cp->ptr = (void*)new struct __ns6__forwardKin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns6__forwardKin);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns6__forwardKin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns6__forwardKin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns6__forwardKin %p -> %p\n", q, p));
	*(struct __ns6__forwardKin*)p = *(struct __ns6__forwardKin*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__getJointRange(struct soap *soap, struct __ns2__getJointRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getJointRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__getJointRange(struct soap *soap, const struct __ns2__getJointRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__getJointRange(soap, &a->ns2__getJointRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__getJointRange(struct soap *soap, const struct __ns2__getJointRange *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__getJointRange(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__getJointRange(struct soap *soap, const char *tag, int id, const struct __ns2__getJointRange *a, const char *type)
{
	if (soap_out_PointerTo_ns2__getJointRange(soap, "ns2:getJointRange", -1, &a->ns2__getJointRange, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__getJointRange * SOAP_FMAC4 soap_get___ns2__getJointRange(struct soap *soap, struct __ns2__getJointRange *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__getJointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__getJointRange * SOAP_FMAC4 soap_in___ns2__getJointRange(struct soap *soap, const char *tag, struct __ns2__getJointRange *a, const char *type)
{
	size_t soap_flag_ns2__getJointRange = 1;
	short soap_flag;
	a = (struct __ns2__getJointRange *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__getJointRange, sizeof(struct __ns2__getJointRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__getJointRange(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getJointRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__getJointRange(soap, "ns2:getJointRange", &a->ns2__getJointRange, ""))
				{	soap_flag_ns2__getJointRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__getJointRange * SOAP_FMAC4 soap_instantiate___ns2__getJointRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__getJointRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__getJointRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__getJointRange;
		if (size)
			*size = sizeof(struct __ns2__getJointRange);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__getJointRange[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__getJointRange);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__getJointRange*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__getJointRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__getJointRange %p -> %p\n", q, p));
	*(struct __ns2__getJointRange*)p = *(struct __ns2__getJointRange*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__getRecord(struct soap *soap, struct __ns2__getRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getRecord = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__getRecord(struct soap *soap, const struct __ns2__getRecord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__getRecord(soap, &a->ns2__getRecord);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__getRecord(struct soap *soap, const struct __ns2__getRecord *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__getRecord(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__getRecord(struct soap *soap, const char *tag, int id, const struct __ns2__getRecord *a, const char *type)
{
	if (soap_out_PointerTo_ns2__getRecord(soap, "ns2:getRecord", -1, &a->ns2__getRecord, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__getRecord * SOAP_FMAC4 soap_get___ns2__getRecord(struct soap *soap, struct __ns2__getRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__getRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__getRecord * SOAP_FMAC4 soap_in___ns2__getRecord(struct soap *soap, const char *tag, struct __ns2__getRecord *a, const char *type)
{
	size_t soap_flag_ns2__getRecord = 1;
	short soap_flag;
	a = (struct __ns2__getRecord *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__getRecord, sizeof(struct __ns2__getRecord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__getRecord(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getRecord && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__getRecord(soap, "ns2:getRecord", &a->ns2__getRecord, ""))
				{	soap_flag_ns2__getRecord--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__getRecord * SOAP_FMAC4 soap_instantiate___ns2__getRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__getRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__getRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__getRecord;
		if (size)
			*size = sizeof(struct __ns2__getRecord);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__getRecord[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__getRecord);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__getRecord*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__getRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__getRecord %p -> %p\n", q, p));
	*(struct __ns2__getRecord*)p = *(struct __ns2__getRecord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__getRecords(struct soap *soap, struct __ns2__getRecords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getRecords = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__getRecords(struct soap *soap, const struct __ns2__getRecords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__getRecords(soap, &a->ns2__getRecords);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__getRecords(struct soap *soap, const struct __ns2__getRecords *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__getRecords(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__getRecords(struct soap *soap, const char *tag, int id, const struct __ns2__getRecords *a, const char *type)
{
	if (soap_out_PointerTo_ns2__getRecords(soap, "ns2:getRecords", -1, &a->ns2__getRecords, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__getRecords * SOAP_FMAC4 soap_get___ns2__getRecords(struct soap *soap, struct __ns2__getRecords *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__getRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__getRecords * SOAP_FMAC4 soap_in___ns2__getRecords(struct soap *soap, const char *tag, struct __ns2__getRecords *a, const char *type)
{
	size_t soap_flag_ns2__getRecords = 1;
	short soap_flag;
	a = (struct __ns2__getRecords *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__getRecords, sizeof(struct __ns2__getRecords), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__getRecords(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getRecords && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__getRecords(soap, "ns2:getRecords", &a->ns2__getRecords, ""))
				{	soap_flag_ns2__getRecords--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__getRecords * SOAP_FMAC4 soap_instantiate___ns2__getRecords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__getRecords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__getRecords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__getRecords;
		if (size)
			*size = sizeof(struct __ns2__getRecords);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__getRecords[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__getRecords);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__getRecords*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__getRecords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__getRecords %p -> %p\n", q, p));
	*(struct __ns2__getRecords*)p = *(struct __ns2__getRecords*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__getApplicationDatas(struct soap *soap, struct __ns2__getApplicationDatas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getApplicationDatas = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__getApplicationDatas(struct soap *soap, const struct __ns2__getApplicationDatas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__getApplicationDatas(soap, &a->ns2__getApplicationDatas);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__getApplicationDatas(struct soap *soap, const struct __ns2__getApplicationDatas *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__getApplicationDatas(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__getApplicationDatas(struct soap *soap, const char *tag, int id, const struct __ns2__getApplicationDatas *a, const char *type)
{
	if (soap_out_PointerTo_ns2__getApplicationDatas(soap, "ns2:getApplicationDatas", -1, &a->ns2__getApplicationDatas, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__getApplicationDatas * SOAP_FMAC4 soap_get___ns2__getApplicationDatas(struct soap *soap, struct __ns2__getApplicationDatas *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__getApplicationDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__getApplicationDatas * SOAP_FMAC4 soap_in___ns2__getApplicationDatas(struct soap *soap, const char *tag, struct __ns2__getApplicationDatas *a, const char *type)
{
	size_t soap_flag_ns2__getApplicationDatas = 1;
	short soap_flag;
	a = (struct __ns2__getApplicationDatas *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__getApplicationDatas, sizeof(struct __ns2__getApplicationDatas), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__getApplicationDatas(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getApplicationDatas && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__getApplicationDatas(soap, "ns2:getApplicationDatas", &a->ns2__getApplicationDatas, ""))
				{	soap_flag_ns2__getApplicationDatas--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__getApplicationDatas * SOAP_FMAC4 soap_instantiate___ns2__getApplicationDatas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__getApplicationDatas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__getApplicationDatas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__getApplicationDatas;
		if (size)
			*size = sizeof(struct __ns2__getApplicationDatas);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__getApplicationDatas[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__getApplicationDatas);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__getApplicationDatas*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__getApplicationDatas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__getApplicationDatas %p -> %p\n", q, p));
	*(struct __ns2__getApplicationDatas*)p = *(struct __ns2__getApplicationDatas*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__getApplications(struct soap *soap, struct __ns2__getApplications *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__getApplications = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__getApplications(struct soap *soap, const struct __ns2__getApplications *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__getApplications(soap, &a->ns2__getApplications);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__getApplications(struct soap *soap, const struct __ns2__getApplications *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__getApplications(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__getApplications(struct soap *soap, const char *tag, int id, const struct __ns2__getApplications *a, const char *type)
{
	if (soap_out_PointerTo_ns2__getApplications(soap, "ns2:getApplications", -1, &a->ns2__getApplications, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__getApplications * SOAP_FMAC4 soap_get___ns2__getApplications(struct soap *soap, struct __ns2__getApplications *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__getApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns2__getApplications * SOAP_FMAC4 soap_in___ns2__getApplications(struct soap *soap, const char *tag, struct __ns2__getApplications *a, const char *type)
{
	size_t soap_flag_ns2__getApplications = 1;
	short soap_flag;
	a = (struct __ns2__getApplications *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__getApplications, sizeof(struct __ns2__getApplications), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__getApplications(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__getApplications && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__getApplications(soap, "ns2:getApplications", &a->ns2__getApplications, ""))
				{	soap_flag_ns2__getApplications--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns2__getApplications * SOAP_FMAC4 soap_instantiate___ns2__getApplications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__getApplications(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__getApplications, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns2__getApplications;
		if (size)
			*size = sizeof(struct __ns2__getApplications);
	}
	else
	{	cp->ptr = (void*)new struct __ns2__getApplications[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__getApplications);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__getApplications*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__getApplications(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__getApplications %p -> %p\n", q, p));
	*(struct __ns2__getApplications*)p = *(struct __ns2__getApplications*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setRobotJointPos(struct soap *soap, struct __ns1__setRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setRobotJointPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setRobotJointPos(struct soap *soap, const struct __ns1__setRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__setRobotJointPos(soap, &a->ns1__setRobotJointPos);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setRobotJointPos(struct soap *soap, const struct __ns1__setRobotJointPos *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setRobotJointPos(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setRobotJointPos(struct soap *soap, const char *tag, int id, const struct __ns1__setRobotJointPos *a, const char *type)
{
	if (soap_out_PointerTo_ns1__setRobotJointPos(soap, "ns1:setRobotJointPos", -1, &a->ns1__setRobotJointPos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRobotJointPos * SOAP_FMAC4 soap_get___ns1__setRobotJointPos(struct soap *soap, struct __ns1__setRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__setRobotJointPos * SOAP_FMAC4 soap_in___ns1__setRobotJointPos(struct soap *soap, const char *tag, struct __ns1__setRobotJointPos *a, const char *type)
{
	size_t soap_flag_ns1__setRobotJointPos = 1;
	short soap_flag;
	a = (struct __ns1__setRobotJointPos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setRobotJointPos, sizeof(struct __ns1__setRobotJointPos), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setRobotJointPos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setRobotJointPos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__setRobotJointPos(soap, "ns1:setRobotJointPos", &a->ns1__setRobotJointPos, ""))
				{	soap_flag_ns1__setRobotJointPos--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__setRobotJointPos * SOAP_FMAC4 soap_instantiate___ns1__setRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setRobotJointPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setRobotJointPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__setRobotJointPos;
		if (size)
			*size = sizeof(struct __ns1__setRobotJointPos);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__setRobotJointPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setRobotJointPos);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setRobotJointPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setRobotJointPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setRobotJointPos %p -> %p\n", q, p));
	*(struct __ns1__setRobotJointPos*)p = *(struct __ns1__setRobotJointPos*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRobotJntCartPos(struct soap *soap, struct __ns1__getRobotJntCartPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRobotJntCartPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRobotJntCartPos(struct soap *soap, const struct __ns1__getRobotJntCartPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getRobotJntCartPos(soap, &a->ns1__getRobotJntCartPos);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRobotJntCartPos(struct soap *soap, const struct __ns1__getRobotJntCartPos *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRobotJntCartPos(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRobotJntCartPos(struct soap *soap, const char *tag, int id, const struct __ns1__getRobotJntCartPos *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobotJntCartPos(soap, "ns1:getRobotJntCartPos", -1, &a->ns1__getRobotJntCartPos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobotJntCartPos * SOAP_FMAC4 soap_get___ns1__getRobotJntCartPos(struct soap *soap, struct __ns1__getRobotJntCartPos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRobotJntCartPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getRobotJntCartPos * SOAP_FMAC4 soap_in___ns1__getRobotJntCartPos(struct soap *soap, const char *tag, struct __ns1__getRobotJntCartPos *a, const char *type)
{
	size_t soap_flag_ns1__getRobotJntCartPos = 1;
	short soap_flag;
	a = (struct __ns1__getRobotJntCartPos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRobotJntCartPos, sizeof(struct __ns1__getRobotJntCartPos), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRobotJntCartPos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRobotJntCartPos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getRobotJntCartPos(soap, "ns1:getRobotJntCartPos", &a->ns1__getRobotJntCartPos, ""))
				{	soap_flag_ns1__getRobotJntCartPos--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__getRobotJntCartPos * SOAP_FMAC4 soap_instantiate___ns1__getRobotJntCartPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRobotJntCartPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getRobotJntCartPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getRobotJntCartPos;
		if (size)
			*size = sizeof(struct __ns1__getRobotJntCartPos);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getRobotJntCartPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getRobotJntCartPos);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getRobotJntCartPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRobotJntCartPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRobotJntCartPos %p -> %p\n", q, p));
	*(struct __ns1__getRobotJntCartPos*)p = *(struct __ns1__getRobotJntCartPos*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRobotJointPos(struct soap *soap, struct __ns1__getRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRobotJointPos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRobotJointPos(struct soap *soap, const struct __ns1__getRobotJointPos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getRobotJointPos(soap, &a->ns1__getRobotJointPos);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRobotJointPos(struct soap *soap, const struct __ns1__getRobotJointPos *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRobotJointPos(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRobotJointPos(struct soap *soap, const char *tag, int id, const struct __ns1__getRobotJointPos *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobotJointPos(soap, "ns1:getRobotJointPos", -1, &a->ns1__getRobotJointPos, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobotJointPos * SOAP_FMAC4 soap_get___ns1__getRobotJointPos(struct soap *soap, struct __ns1__getRobotJointPos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getRobotJointPos * SOAP_FMAC4 soap_in___ns1__getRobotJointPos(struct soap *soap, const char *tag, struct __ns1__getRobotJointPos *a, const char *type)
{
	size_t soap_flag_ns1__getRobotJointPos = 1;
	short soap_flag;
	a = (struct __ns1__getRobotJointPos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRobotJointPos, sizeof(struct __ns1__getRobotJointPos), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRobotJointPos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRobotJointPos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getRobotJointPos(soap, "ns1:getRobotJointPos", &a->ns1__getRobotJointPos, ""))
				{	soap_flag_ns1__getRobotJointPos--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__getRobotJointPos * SOAP_FMAC4 soap_instantiate___ns1__getRobotJointPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRobotJointPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getRobotJointPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getRobotJointPos;
		if (size)
			*size = sizeof(struct __ns1__getRobotJointPos);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getRobotJointPos[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getRobotJointPos);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getRobotJointPos*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRobotJointPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRobotJointPos %p -> %p\n", q, p));
	*(struct __ns1__getRobotJointPos*)p = *(struct __ns1__getRobotJointPos*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRobots(struct soap *soap, struct __ns1__getRobots *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRobots = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRobots(struct soap *soap, const struct __ns1__getRobots *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getRobots(soap, &a->ns1__getRobots);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRobots(struct soap *soap, const struct __ns1__getRobots *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRobots(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRobots(struct soap *soap, const char *tag, int id, const struct __ns1__getRobots *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getRobots(soap, "ns1:getRobots", -1, &a->ns1__getRobots, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRobots * SOAP_FMAC4 soap_get___ns1__getRobots(struct soap *soap, struct __ns1__getRobots *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRobots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getRobots * SOAP_FMAC4 soap_in___ns1__getRobots(struct soap *soap, const char *tag, struct __ns1__getRobots *a, const char *type)
{
	size_t soap_flag_ns1__getRobots = 1;
	short soap_flag;
	a = (struct __ns1__getRobots *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRobots, sizeof(struct __ns1__getRobots), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRobots(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRobots && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getRobots(soap, "ns1:getRobots", &a->ns1__getRobots, ""))
				{	soap_flag_ns1__getRobots--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__getRobots * SOAP_FMAC4 soap_instantiate___ns1__getRobots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRobots(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getRobots, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getRobots;
		if (size)
			*size = sizeof(struct __ns1__getRobots);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getRobots[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getRobots);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getRobots*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRobots(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRobots %p -> %p\n", q, p));
	*(struct __ns1__getRobots*)p = *(struct __ns1__getRobots*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logout(struct soap *soap, struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__logout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logout(struct soap *soap, const struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__logout(soap, &a->ns1__logout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logout(struct soap *soap, const struct __ns1__logout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__logout(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logout(struct soap *soap, const char *tag, int id, const struct __ns1__logout *a, const char *type)
{
	if (soap_out_PointerTo_ns1__logout(soap, "ns1:logout", -1, &a->ns1__logout, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_get___ns1__logout(struct soap *soap, struct __ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_in___ns1__logout(struct soap *soap, const char *tag, struct __ns1__logout *a, const char *type)
{
	size_t soap_flag_ns1__logout = 1;
	short soap_flag;
	a = (struct __ns1__logout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logout, sizeof(struct __ns1__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__logout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__logout(soap, "ns1:logout", &a->ns1__logout, ""))
				{	soap_flag_ns1__logout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_instantiate___ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__logout;
		if (size)
			*size = sizeof(struct __ns1__logout);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__logout[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__logout);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__logout*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__logout %p -> %p\n", q, p));
	*(struct __ns1__logout*)p = *(struct __ns1__logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__login(struct soap *soap, struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__login(struct soap *soap, const struct __ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__login(soap, &a->ns1__login);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__login(struct soap *soap, const struct __ns1__login *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__login(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__login(struct soap *soap, const char *tag, int id, const struct __ns1__login *a, const char *type)
{
	if (soap_out_PointerTo_ns1__login(soap, "ns1:login", -1, &a->ns1__login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_get___ns1__login(struct soap *soap, struct __ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_in___ns1__login(struct soap *soap, const char *tag, struct __ns1__login *a, const char *type)
{
	size_t soap_flag_ns1__login = 1;
	short soap_flag;
	a = (struct __ns1__login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__login, sizeof(struct __ns1__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__login(soap, "ns1:login", &a->ns1__login, ""))
				{	soap_flag_ns1__login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__login * SOAP_FMAC4 soap_instantiate___ns1__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__login;
		if (size)
			*size = sizeof(struct __ns1__login);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__login[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__login);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__login*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__login %p -> %p\n", q, p));
	*(struct __ns1__login*)p = *(struct __ns1__login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCS8Versions(struct soap *soap, struct __ns1__getCS8Versions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCS8Versions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCS8Versions(struct soap *soap, const struct __ns1__getCS8Versions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getCS8Versions(soap, &a->ns1__getCS8Versions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCS8Versions(struct soap *soap, const struct __ns1__getCS8Versions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCS8Versions(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCS8Versions(struct soap *soap, const char *tag, int id, const struct __ns1__getCS8Versions *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getCS8Versions(soap, "ns1:getCS8Versions", -1, &a->ns1__getCS8Versions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCS8Versions * SOAP_FMAC4 soap_get___ns1__getCS8Versions(struct soap *soap, struct __ns1__getCS8Versions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCS8Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getCS8Versions * SOAP_FMAC4 soap_in___ns1__getCS8Versions(struct soap *soap, const char *tag, struct __ns1__getCS8Versions *a, const char *type)
{
	size_t soap_flag_ns1__getCS8Versions = 1;
	short soap_flag;
	a = (struct __ns1__getCS8Versions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCS8Versions, sizeof(struct __ns1__getCS8Versions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCS8Versions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCS8Versions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getCS8Versions(soap, "ns1:getCS8Versions", &a->ns1__getCS8Versions, ""))
				{	soap_flag_ns1__getCS8Versions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__getCS8Versions * SOAP_FMAC4 soap_instantiate___ns1__getCS8Versions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCS8Versions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCS8Versions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getCS8Versions;
		if (size)
			*size = sizeof(struct __ns1__getCS8Versions);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getCS8Versions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getCS8Versions);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getCS8Versions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCS8Versions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCS8Versions %p -> %p\n", q, p));
	*(struct __ns1__getCS8Versions*)p = *(struct __ns1__getCS8Versions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ping(struct soap *soap, struct __ns1__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ping = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ping(struct soap *soap, const struct __ns1__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ping(soap, &a->ns1__ping);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ping(struct soap *soap, const struct __ns1__ping *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ping(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ping(struct soap *soap, const char *tag, int id, const struct __ns1__ping *a, const char *type)
{
	if (soap_out_PointerTo_ns1__ping(soap, "ns1:ping", -1, &a->ns1__ping, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ping * SOAP_FMAC4 soap_get___ns1__ping(struct soap *soap, struct __ns1__ping *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__ping * SOAP_FMAC4 soap_in___ns1__ping(struct soap *soap, const char *tag, struct __ns1__ping *a, const char *type)
{
	size_t soap_flag_ns1__ping = 1;
	short soap_flag;
	a = (struct __ns1__ping *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ping, sizeof(struct __ns1__ping), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ping(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ping && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ping(soap, "ns1:ping", &a->ns1__ping, ""))
				{	soap_flag_ns1__ping--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__ping * SOAP_FMAC4 soap_instantiate___ns1__ping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ping(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ping, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__ping;
		if (size)
			*size = sizeof(struct __ns1__ping);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__ping[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__ping);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__ping*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ping(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ping %p -> %p\n", q, p));
	*(struct __ns1__ping*)p = *(struct __ns1__ping*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getSoapServerVersion(struct soap *soap, struct __ns1__getSoapServerVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getSoapServerVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getSoapServerVersion(struct soap *soap, const struct __ns1__getSoapServerVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__getSoapServerVersion(soap, &a->ns1__getSoapServerVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getSoapServerVersion(struct soap *soap, const struct __ns1__getSoapServerVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getSoapServerVersion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getSoapServerVersion(struct soap *soap, const char *tag, int id, const struct __ns1__getSoapServerVersion *a, const char *type)
{
	if (soap_out_PointerTo_ns1__getSoapServerVersion(soap, "ns1:getSoapServerVersion", -1, &a->ns1__getSoapServerVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getSoapServerVersion * SOAP_FMAC4 soap_get___ns1__getSoapServerVersion(struct soap *soap, struct __ns1__getSoapServerVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getSoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getSoapServerVersion * SOAP_FMAC4 soap_in___ns1__getSoapServerVersion(struct soap *soap, const char *tag, struct __ns1__getSoapServerVersion *a, const char *type)
{
	size_t soap_flag_ns1__getSoapServerVersion = 1;
	short soap_flag;
	a = (struct __ns1__getSoapServerVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getSoapServerVersion, sizeof(struct __ns1__getSoapServerVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getSoapServerVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getSoapServerVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getSoapServerVersion(soap, "ns1:getSoapServerVersion", &a->ns1__getSoapServerVersion, ""))
				{	soap_flag_ns1__getSoapServerVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__getSoapServerVersion * SOAP_FMAC4 soap_instantiate___ns1__getSoapServerVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getSoapServerVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getSoapServerVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getSoapServerVersion;
		if (size)
			*size = sizeof(struct __ns1__getSoapServerVersion);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getSoapServerVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getSoapServerVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getSoapServerVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getSoapServerVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getSoapServerVersion %p -> %p\n", q, p));
	*(struct __ns1__getSoapServerVersion*)p = *(struct __ns1__getSoapServerVersion*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ServerException_ = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ServerException(soap, &a->ns1__ServerException_);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons1__ServerException(soap, "ns1:ServerException", -1, &a->ns1__ServerException_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__ServerException_ = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ServerException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ServerException(soap, "ns1:ServerException", &a->ns1__ServerException_, "ns1:ServerException"))
				{	soap_flag_ns1__ServerException_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sessionId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SessionId(soap, &a->ns1__sessionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__SessionId(soap, "ns1:sessionId", -1, &a->ns1__sessionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns1__sessionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sessionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SessionId(soap, "ns1:sessionId", &a->ns1__sessionId, "ns1:SessionId"))
				{	soap_flag_ns1__sessionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns6__union_Config(struct soap *soap, int choice, const union _ns6__union_Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns6__union_Config_anthroConfig:
		soap_serialize_PointerTons6__AnthroConfig(soap, &a->anthroConfig);
		break;
	case SOAP_UNION__ns6__union_Config_scaraConfig:
		soap_serialize_PointerTons6__ScaraConfig(soap, &a->scaraConfig);
		break;
	case SOAP_UNION__ns6__union_Config_vrbxConfig:
		soap_serialize_PointerTons6__VrbxConfig(soap, &a->vrbxConfig);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns6__union_Config(struct soap *soap, int choice, const union _ns6__union_Config *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns6__union_Config_anthroConfig:
		return soap_out_PointerTons6__AnthroConfig(soap, "anthroConfig", -1, &a->anthroConfig, "");
	case SOAP_UNION__ns6__union_Config_scaraConfig:
		return soap_out_PointerTons6__ScaraConfig(soap, "scaraConfig", -1, &a->scaraConfig, "");
	case SOAP_UNION__ns6__union_Config_vrbxConfig:
		return soap_out_PointerTons6__VrbxConfig(soap, "vrbxConfig", -1, &a->vrbxConfig, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns6__union_Config * SOAP_FMAC4 soap_in__ns6__union_Config(struct soap *soap, int *choice, union _ns6__union_Config *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->anthroConfig = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__AnthroConfig(soap, "anthroConfig", &a->anthroConfig, "ns6:AnthroConfig"))
	{	*choice = SOAP_UNION__ns6__union_Config_anthroConfig;
		return a;
	}
	a->scaraConfig = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__ScaraConfig(soap, "scaraConfig", &a->scaraConfig, "ns6:ScaraConfig"))
	{	*choice = SOAP_UNION__ns6__union_Config_scaraConfig;
		return a;
	}
	a->vrbxConfig = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons6__VrbxConfig(soap, "vrbxConfig", &a->vrbxConfig, "ns6:VrbxConfig"))
	{	*choice = SOAP_UNION__ns6__union_Config_vrbxConfig;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__setPowerResponse(struct soap *soap, _ns6__setPowerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__setPowerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__setPowerResponse(struct soap *soap, _ns6__setPowerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__setPowerResponse);
	if (soap_out_PointerTo_ns6__setPowerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__setPowerResponse(struct soap *soap, const char *tag, int id, _ns6__setPowerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__setPowerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__setPowerResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__setPowerResponse(struct soap *soap, _ns6__setPowerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__setPowerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__setPowerResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__setPowerResponse(struct soap *soap, const char *tag, _ns6__setPowerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__setPowerResponse **)soap_malloc(soap, sizeof(_ns6__setPowerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__setPowerResponse *)soap_instantiate__ns6__setPowerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__setPowerResponse ** p = (_ns6__setPowerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__setPowerResponse, sizeof(_ns6__setPowerResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__setPower(struct soap *soap, _ns6__setPower *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__setPower))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__setPower(struct soap *soap, _ns6__setPower *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__setPower);
	if (soap_out_PointerTo_ns6__setPower(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__setPower(struct soap *soap, const char *tag, int id, _ns6__setPower *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__setPower);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__setPower ** SOAP_FMAC4 soap_get_PointerTo_ns6__setPower(struct soap *soap, _ns6__setPower **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__setPower(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__setPower ** SOAP_FMAC4 soap_in_PointerTo_ns6__setPower(struct soap *soap, const char *tag, _ns6__setPower **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__setPower **)soap_malloc(soap, sizeof(_ns6__setPower *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__setPower *)soap_instantiate__ns6__setPower(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__setPower ** p = (_ns6__setPower **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__setPower, sizeof(_ns6__setPower), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__MotionAndRobotsPos(struct soap *soap, _ns6__MotionAndRobotsPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__MotionAndRobotsPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__MotionAndRobotsPos(struct soap *soap, _ns6__MotionAndRobotsPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__MotionAndRobotsPos);
	if (soap_out_PointerTo_ns6__MotionAndRobotsPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__MotionAndRobotsPos(struct soap *soap, const char *tag, int id, _ns6__MotionAndRobotsPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__MotionAndRobotsPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__MotionAndRobotsPos ** SOAP_FMAC4 soap_get_PointerTo_ns6__MotionAndRobotsPos(struct soap *soap, _ns6__MotionAndRobotsPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__MotionAndRobotsPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__MotionAndRobotsPos ** SOAP_FMAC4 soap_in_PointerTo_ns6__MotionAndRobotsPos(struct soap *soap, const char *tag, _ns6__MotionAndRobotsPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__MotionAndRobotsPos **)soap_malloc(soap, sizeof(_ns6__MotionAndRobotsPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__MotionAndRobotsPos *)soap_instantiate__ns6__MotionAndRobotsPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__MotionAndRobotsPos ** p = (_ns6__MotionAndRobotsPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__MotionAndRobotsPos, sizeof(_ns6__MotionAndRobotsPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__schedulerRefresh(struct soap *soap, _ns6__schedulerRefresh *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__schedulerRefresh))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__schedulerRefresh(struct soap *soap, _ns6__schedulerRefresh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__schedulerRefresh);
	if (soap_out_PointerTo_ns6__schedulerRefresh(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__schedulerRefresh(struct soap *soap, const char *tag, int id, _ns6__schedulerRefresh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__schedulerRefresh);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__schedulerRefresh ** SOAP_FMAC4 soap_get_PointerTo_ns6__schedulerRefresh(struct soap *soap, _ns6__schedulerRefresh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__schedulerRefresh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__schedulerRefresh ** SOAP_FMAC4 soap_in_PointerTo_ns6__schedulerRefresh(struct soap *soap, const char *tag, _ns6__schedulerRefresh **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__schedulerRefresh **)soap_malloc(soap, sizeof(_ns6__schedulerRefresh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__schedulerRefresh *)soap_instantiate__ns6__schedulerRefresh(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__schedulerRefresh ** p = (_ns6__schedulerRefresh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__schedulerRefresh, sizeof(_ns6__schedulerRefresh), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__setSchedulingModeResponse(struct soap *soap, _ns6__setSchedulingModeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__setSchedulingModeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__setSchedulingModeResponse(struct soap *soap, _ns6__setSchedulingModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__setSchedulingModeResponse);
	if (soap_out_PointerTo_ns6__setSchedulingModeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__setSchedulingModeResponse(struct soap *soap, const char *tag, int id, _ns6__setSchedulingModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__setSchedulingModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__setSchedulingModeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__setSchedulingModeResponse(struct soap *soap, _ns6__setSchedulingModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__setSchedulingModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__setSchedulingModeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__setSchedulingModeResponse(struct soap *soap, const char *tag, _ns6__setSchedulingModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__setSchedulingModeResponse **)soap_malloc(soap, sizeof(_ns6__setSchedulingModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__setSchedulingModeResponse *)soap_instantiate__ns6__setSchedulingModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__setSchedulingModeResponse ** p = (_ns6__setSchedulingModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__setSchedulingModeResponse, sizeof(_ns6__setSchedulingModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__setSchedulingMode(struct soap *soap, _ns6__setSchedulingMode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__setSchedulingMode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__setSchedulingMode(struct soap *soap, _ns6__setSchedulingMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__setSchedulingMode);
	if (soap_out_PointerTo_ns6__setSchedulingMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__setSchedulingMode(struct soap *soap, const char *tag, int id, _ns6__setSchedulingMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__setSchedulingMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__setSchedulingMode ** SOAP_FMAC4 soap_get_PointerTo_ns6__setSchedulingMode(struct soap *soap, _ns6__setSchedulingMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__setSchedulingMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__setSchedulingMode ** SOAP_FMAC4 soap_in_PointerTo_ns6__setSchedulingMode(struct soap *soap, const char *tag, _ns6__setSchedulingMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__setSchedulingMode **)soap_malloc(soap, sizeof(_ns6__setSchedulingMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__setSchedulingMode *)soap_instantiate__ns6__setSchedulingMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__setSchedulingMode ** p = (_ns6__setSchedulingMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__setSchedulingMode, sizeof(_ns6__setSchedulingMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__restartMotion(struct soap *soap, _ns6__restartMotion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__restartMotion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__restartMotion(struct soap *soap, _ns6__restartMotion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__restartMotion);
	if (soap_out_PointerTo_ns6__restartMotion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__restartMotion(struct soap *soap, const char *tag, int id, _ns6__restartMotion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__restartMotion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__restartMotion ** SOAP_FMAC4 soap_get_PointerTo_ns6__restartMotion(struct soap *soap, _ns6__restartMotion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__restartMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__restartMotion ** SOAP_FMAC4 soap_in_PointerTo_ns6__restartMotion(struct soap *soap, const char *tag, _ns6__restartMotion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__restartMotion **)soap_malloc(soap, sizeof(_ns6__restartMotion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__restartMotion *)soap_instantiate__ns6__restartMotion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__restartMotion ** p = (_ns6__restartMotion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__restartMotion, sizeof(_ns6__restartMotion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__stopMotion(struct soap *soap, _ns6__stopMotion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__stopMotion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__stopMotion(struct soap *soap, _ns6__stopMotion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__stopMotion);
	if (soap_out_PointerTo_ns6__stopMotion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__stopMotion(struct soap *soap, const char *tag, int id, _ns6__stopMotion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__stopMotion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__stopMotion ** SOAP_FMAC4 soap_get_PointerTo_ns6__stopMotion(struct soap *soap, _ns6__stopMotion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__stopMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__stopMotion ** SOAP_FMAC4 soap_in_PointerTo_ns6__stopMotion(struct soap *soap, const char *tag, _ns6__stopMotion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__stopMotion **)soap_malloc(soap, sizeof(_ns6__stopMotion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__stopMotion *)soap_instantiate__ns6__stopMotion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__stopMotion ** p = (_ns6__stopMotion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__stopMotion, sizeof(_ns6__stopMotion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__motionResponse(struct soap *soap, _ns6__motionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__motionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__motionResponse(struct soap *soap, _ns6__motionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__motionResponse);
	if (soap_out_PointerTo_ns6__motionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__motionResponse(struct soap *soap, const char *tag, int id, _ns6__motionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__motionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__motionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__motionResponse(struct soap *soap, _ns6__motionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__motionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__motionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__motionResponse(struct soap *soap, const char *tag, _ns6__motionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__motionResponse **)soap_malloc(soap, sizeof(_ns6__motionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__motionResponse *)soap_instantiate__ns6__motionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__motionResponse ** p = (_ns6__motionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__motionResponse, sizeof(_ns6__motionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__resetMotion(struct soap *soap, _ns6__resetMotion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__resetMotion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__resetMotion(struct soap *soap, _ns6__resetMotion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__resetMotion);
	if (soap_out_PointerTo_ns6__resetMotion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__resetMotion(struct soap *soap, const char *tag, int id, _ns6__resetMotion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__resetMotion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__resetMotion ** SOAP_FMAC4 soap_get_PointerTo_ns6__resetMotion(struct soap *soap, _ns6__resetMotion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__resetMotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__resetMotion ** SOAP_FMAC4 soap_in_PointerTo_ns6__resetMotion(struct soap *soap, const char *tag, _ns6__resetMotion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__resetMotion **)soap_malloc(soap, sizeof(_ns6__resetMotion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__resetMotion *)soap_instantiate__ns6__resetMotion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__resetMotion ** p = (_ns6__resetMotion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__resetMotion, sizeof(_ns6__resetMotion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__moveC(struct soap *soap, _ns6__moveC *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__moveC))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__moveC(struct soap *soap, _ns6__moveC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__moveC);
	if (soap_out_PointerTo_ns6__moveC(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__moveC(struct soap *soap, const char *tag, int id, _ns6__moveC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__moveC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__moveC ** SOAP_FMAC4 soap_get_PointerTo_ns6__moveC(struct soap *soap, _ns6__moveC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__moveC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__moveC ** SOAP_FMAC4 soap_in_PointerTo_ns6__moveC(struct soap *soap, const char *tag, _ns6__moveC **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__moveC **)soap_malloc(soap, sizeof(_ns6__moveC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__moveC *)soap_instantiate__ns6__moveC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__moveC ** p = (_ns6__moveC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__moveC, sizeof(_ns6__moveC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__moveL(struct soap *soap, _ns6__moveL *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__moveL))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__moveL(struct soap *soap, _ns6__moveL *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__moveL);
	if (soap_out_PointerTo_ns6__moveL(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__moveL(struct soap *soap, const char *tag, int id, _ns6__moveL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__moveL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__moveL ** SOAP_FMAC4 soap_get_PointerTo_ns6__moveL(struct soap *soap, _ns6__moveL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__moveL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__moveL ** SOAP_FMAC4 soap_in_PointerTo_ns6__moveL(struct soap *soap, const char *tag, _ns6__moveL **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__moveL **)soap_malloc(soap, sizeof(_ns6__moveL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__moveL *)soap_instantiate__ns6__moveL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__moveL ** p = (_ns6__moveL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__moveL, sizeof(_ns6__moveL), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__moveJC(struct soap *soap, _ns6__moveJC *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__moveJC))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__moveJC(struct soap *soap, _ns6__moveJC *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__moveJC);
	if (soap_out_PointerTo_ns6__moveJC(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__moveJC(struct soap *soap, const char *tag, int id, _ns6__moveJC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__moveJC);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__moveJC ** SOAP_FMAC4 soap_get_PointerTo_ns6__moveJC(struct soap *soap, _ns6__moveJC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__moveJC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__moveJC ** SOAP_FMAC4 soap_in_PointerTo_ns6__moveJC(struct soap *soap, const char *tag, _ns6__moveJC **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__moveJC **)soap_malloc(soap, sizeof(_ns6__moveJC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__moveJC *)soap_instantiate__ns6__moveJC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__moveJC ** p = (_ns6__moveJC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__moveJC, sizeof(_ns6__moveJC), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__moveResponse(struct soap *soap, _ns6__moveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__moveResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__moveResponse(struct soap *soap, _ns6__moveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__moveResponse);
	if (soap_out_PointerTo_ns6__moveResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__moveResponse(struct soap *soap, const char *tag, int id, _ns6__moveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__moveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__moveResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__moveResponse(struct soap *soap, _ns6__moveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__moveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__moveResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__moveResponse(struct soap *soap, const char *tag, _ns6__moveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__moveResponse **)soap_malloc(soap, sizeof(_ns6__moveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__moveResponse *)soap_instantiate__ns6__moveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__moveResponse ** p = (_ns6__moveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__moveResponse, sizeof(_ns6__moveResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__moveJJ(struct soap *soap, _ns6__moveJJ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__moveJJ))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__moveJJ(struct soap *soap, _ns6__moveJJ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__moveJJ);
	if (soap_out_PointerTo_ns6__moveJJ(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__moveJJ(struct soap *soap, const char *tag, int id, _ns6__moveJJ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__moveJJ);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__moveJJ ** SOAP_FMAC4 soap_get_PointerTo_ns6__moveJJ(struct soap *soap, _ns6__moveJJ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__moveJJ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__moveJJ ** SOAP_FMAC4 soap_in_PointerTo_ns6__moveJJ(struct soap *soap, const char *tag, _ns6__moveJJ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__moveJJ **)soap_malloc(soap, sizeof(_ns6__moveJJ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__moveJJ *)soap_instantiate__ns6__moveJJ(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__moveJJ ** p = (_ns6__moveJJ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__moveJJ, sizeof(_ns6__moveJJ), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__reverseKinResponse(struct soap *soap, _ns6__reverseKinResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__reverseKinResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__reverseKinResponse(struct soap *soap, _ns6__reverseKinResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__reverseKinResponse);
	if (soap_out_PointerTo_ns6__reverseKinResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__reverseKinResponse(struct soap *soap, const char *tag, int id, _ns6__reverseKinResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__reverseKinResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__reverseKinResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__reverseKinResponse(struct soap *soap, _ns6__reverseKinResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__reverseKinResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__reverseKinResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__reverseKinResponse(struct soap *soap, const char *tag, _ns6__reverseKinResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__reverseKinResponse **)soap_malloc(soap, sizeof(_ns6__reverseKinResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__reverseKinResponse *)soap_instantiate__ns6__reverseKinResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__reverseKinResponse ** p = (_ns6__reverseKinResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__reverseKinResponse, sizeof(_ns6__reverseKinResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__reverseKin(struct soap *soap, _ns6__reverseKin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__reverseKin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__reverseKin(struct soap *soap, _ns6__reverseKin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__reverseKin);
	if (soap_out_PointerTo_ns6__reverseKin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__reverseKin(struct soap *soap, const char *tag, int id, _ns6__reverseKin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__reverseKin);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__reverseKin ** SOAP_FMAC4 soap_get_PointerTo_ns6__reverseKin(struct soap *soap, _ns6__reverseKin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__reverseKin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__reverseKin ** SOAP_FMAC4 soap_in_PointerTo_ns6__reverseKin(struct soap *soap, const char *tag, _ns6__reverseKin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__reverseKin **)soap_malloc(soap, sizeof(_ns6__reverseKin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__reverseKin *)soap_instantiate__ns6__reverseKin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__reverseKin ** p = (_ns6__reverseKin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__reverseKin, sizeof(_ns6__reverseKin), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__forwardKinResponse(struct soap *soap, _ns6__forwardKinResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__forwardKinResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__forwardKinResponse(struct soap *soap, _ns6__forwardKinResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__forwardKinResponse);
	if (soap_out_PointerTo_ns6__forwardKinResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__forwardKinResponse(struct soap *soap, const char *tag, int id, _ns6__forwardKinResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__forwardKinResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__forwardKinResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__forwardKinResponse(struct soap *soap, _ns6__forwardKinResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__forwardKinResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__forwardKinResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__forwardKinResponse(struct soap *soap, const char *tag, _ns6__forwardKinResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__forwardKinResponse **)soap_malloc(soap, sizeof(_ns6__forwardKinResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__forwardKinResponse *)soap_instantiate__ns6__forwardKinResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__forwardKinResponse ** p = (_ns6__forwardKinResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__forwardKinResponse, sizeof(_ns6__forwardKinResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__forwardKin(struct soap *soap, _ns6__forwardKin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__forwardKin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__forwardKin(struct soap *soap, _ns6__forwardKin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns6__forwardKin);
	if (soap_out_PointerTo_ns6__forwardKin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__forwardKin(struct soap *soap, const char *tag, int id, _ns6__forwardKin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__forwardKin);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns6__forwardKin ** SOAP_FMAC4 soap_get_PointerTo_ns6__forwardKin(struct soap *soap, _ns6__forwardKin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__forwardKin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns6__forwardKin ** SOAP_FMAC4 soap_in_PointerTo_ns6__forwardKin(struct soap *soap, const char *tag, _ns6__forwardKin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns6__forwardKin **)soap_malloc(soap, sizeof(_ns6__forwardKin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns6__forwardKin *)soap_instantiate__ns6__forwardKin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns6__forwardKin ** p = (_ns6__forwardKin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__forwardKin, sizeof(_ns6__forwardKin), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getJointRangeResponse(struct soap *soap, _ns2__getJointRangeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getJointRangeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getJointRangeResponse(struct soap *soap, _ns2__getJointRangeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getJointRangeResponse);
	if (soap_out_PointerTo_ns2__getJointRangeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getJointRangeResponse(struct soap *soap, const char *tag, int id, _ns2__getJointRangeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getJointRangeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getJointRangeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__getJointRangeResponse(struct soap *soap, _ns2__getJointRangeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getJointRangeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getJointRangeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__getJointRangeResponse(struct soap *soap, const char *tag, _ns2__getJointRangeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getJointRangeResponse **)soap_malloc(soap, sizeof(_ns2__getJointRangeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getJointRangeResponse *)soap_instantiate__ns2__getJointRangeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getJointRangeResponse ** p = (_ns2__getJointRangeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getJointRangeResponse, sizeof(_ns2__getJointRangeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getJointRange(struct soap *soap, _ns2__getJointRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getJointRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getJointRange(struct soap *soap, _ns2__getJointRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getJointRange);
	if (soap_out_PointerTo_ns2__getJointRange(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getJointRange(struct soap *soap, const char *tag, int id, _ns2__getJointRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getJointRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getJointRange ** SOAP_FMAC4 soap_get_PointerTo_ns2__getJointRange(struct soap *soap, _ns2__getJointRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getJointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getJointRange ** SOAP_FMAC4 soap_in_PointerTo_ns2__getJointRange(struct soap *soap, const char *tag, _ns2__getJointRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getJointRange **)soap_malloc(soap, sizeof(_ns2__getJointRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getJointRange *)soap_instantiate__ns2__getJointRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getJointRange ** p = (_ns2__getJointRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getJointRange, sizeof(_ns2__getJointRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getRecordResponse(struct soap *soap, _ns2__getRecordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getRecordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getRecordResponse(struct soap *soap, _ns2__getRecordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getRecordResponse);
	if (soap_out_PointerTo_ns2__getRecordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getRecordResponse(struct soap *soap, const char *tag, int id, _ns2__getRecordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getRecordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getRecordResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__getRecordResponse(struct soap *soap, _ns2__getRecordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getRecordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getRecordResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__getRecordResponse(struct soap *soap, const char *tag, _ns2__getRecordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getRecordResponse **)soap_malloc(soap, sizeof(_ns2__getRecordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getRecordResponse *)soap_instantiate__ns2__getRecordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getRecordResponse ** p = (_ns2__getRecordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getRecordResponse, sizeof(_ns2__getRecordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getRecord(struct soap *soap, _ns2__getRecord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getRecord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getRecord(struct soap *soap, _ns2__getRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getRecord);
	if (soap_out_PointerTo_ns2__getRecord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getRecord(struct soap *soap, const char *tag, int id, _ns2__getRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getRecord ** SOAP_FMAC4 soap_get_PointerTo_ns2__getRecord(struct soap *soap, _ns2__getRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getRecord ** SOAP_FMAC4 soap_in_PointerTo_ns2__getRecord(struct soap *soap, const char *tag, _ns2__getRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getRecord **)soap_malloc(soap, sizeof(_ns2__getRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getRecord *)soap_instantiate__ns2__getRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getRecord ** p = (_ns2__getRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getRecord, sizeof(_ns2__getRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getRecordsResponse(struct soap *soap, _ns2__getRecordsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getRecordsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getRecordsResponse(struct soap *soap, _ns2__getRecordsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getRecordsResponse);
	if (soap_out_PointerTo_ns2__getRecordsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getRecordsResponse(struct soap *soap, const char *tag, int id, _ns2__getRecordsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getRecordsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getRecordsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__getRecordsResponse(struct soap *soap, _ns2__getRecordsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getRecordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getRecordsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__getRecordsResponse(struct soap *soap, const char *tag, _ns2__getRecordsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getRecordsResponse **)soap_malloc(soap, sizeof(_ns2__getRecordsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getRecordsResponse *)soap_instantiate__ns2__getRecordsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getRecordsResponse ** p = (_ns2__getRecordsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getRecordsResponse, sizeof(_ns2__getRecordsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getRecords(struct soap *soap, _ns2__getRecords *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getRecords))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getRecords(struct soap *soap, _ns2__getRecords *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getRecords);
	if (soap_out_PointerTo_ns2__getRecords(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getRecords(struct soap *soap, const char *tag, int id, _ns2__getRecords *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getRecords);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getRecords ** SOAP_FMAC4 soap_get_PointerTo_ns2__getRecords(struct soap *soap, _ns2__getRecords **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getRecords ** SOAP_FMAC4 soap_in_PointerTo_ns2__getRecords(struct soap *soap, const char *tag, _ns2__getRecords **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getRecords **)soap_malloc(soap, sizeof(_ns2__getRecords *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getRecords *)soap_instantiate__ns2__getRecords(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getRecords ** p = (_ns2__getRecords **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getRecords, sizeof(_ns2__getRecords), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getApplicationDatasResponse(struct soap *soap, _ns2__getApplicationDatasResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getApplicationDatasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getApplicationDatasResponse(struct soap *soap, _ns2__getApplicationDatasResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getApplicationDatasResponse);
	if (soap_out_PointerTo_ns2__getApplicationDatasResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getApplicationDatasResponse(struct soap *soap, const char *tag, int id, _ns2__getApplicationDatasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getApplicationDatasResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getApplicationDatasResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__getApplicationDatasResponse(struct soap *soap, _ns2__getApplicationDatasResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getApplicationDatasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getApplicationDatasResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__getApplicationDatasResponse(struct soap *soap, const char *tag, _ns2__getApplicationDatasResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getApplicationDatasResponse **)soap_malloc(soap, sizeof(_ns2__getApplicationDatasResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getApplicationDatasResponse *)soap_instantiate__ns2__getApplicationDatasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getApplicationDatasResponse ** p = (_ns2__getApplicationDatasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getApplicationDatasResponse, sizeof(_ns2__getApplicationDatasResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getApplicationDatas(struct soap *soap, _ns2__getApplicationDatas *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getApplicationDatas))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getApplicationDatas(struct soap *soap, _ns2__getApplicationDatas *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getApplicationDatas);
	if (soap_out_PointerTo_ns2__getApplicationDatas(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getApplicationDatas(struct soap *soap, const char *tag, int id, _ns2__getApplicationDatas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getApplicationDatas);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getApplicationDatas ** SOAP_FMAC4 soap_get_PointerTo_ns2__getApplicationDatas(struct soap *soap, _ns2__getApplicationDatas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getApplicationDatas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getApplicationDatas ** SOAP_FMAC4 soap_in_PointerTo_ns2__getApplicationDatas(struct soap *soap, const char *tag, _ns2__getApplicationDatas **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getApplicationDatas **)soap_malloc(soap, sizeof(_ns2__getApplicationDatas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getApplicationDatas *)soap_instantiate__ns2__getApplicationDatas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getApplicationDatas ** p = (_ns2__getApplicationDatas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getApplicationDatas, sizeof(_ns2__getApplicationDatas), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getApplicationsResponse(struct soap *soap, _ns2__getApplicationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getApplicationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getApplicationsResponse(struct soap *soap, _ns2__getApplicationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getApplicationsResponse);
	if (soap_out_PointerTo_ns2__getApplicationsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getApplicationsResponse(struct soap *soap, const char *tag, int id, _ns2__getApplicationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getApplicationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getApplicationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__getApplicationsResponse(struct soap *soap, _ns2__getApplicationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getApplicationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getApplicationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__getApplicationsResponse(struct soap *soap, const char *tag, _ns2__getApplicationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getApplicationsResponse **)soap_malloc(soap, sizeof(_ns2__getApplicationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getApplicationsResponse *)soap_instantiate__ns2__getApplicationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getApplicationsResponse ** p = (_ns2__getApplicationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getApplicationsResponse, sizeof(_ns2__getApplicationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__getApplications(struct soap *soap, _ns2__getApplications *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__getApplications))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__getApplications(struct soap *soap, _ns2__getApplications *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__getApplications);
	if (soap_out_PointerTo_ns2__getApplications(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__getApplications(struct soap *soap, const char *tag, int id, _ns2__getApplications *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__getApplications);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__getApplications ** SOAP_FMAC4 soap_get_PointerTo_ns2__getApplications(struct soap *soap, _ns2__getApplications **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__getApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns2__getApplications ** SOAP_FMAC4 soap_in_PointerTo_ns2__getApplications(struct soap *soap, const char *tag, _ns2__getApplications **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__getApplications **)soap_malloc(soap, sizeof(_ns2__getApplications *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__getApplications *)soap_instantiate__ns2__getApplications(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__getApplications ** p = (_ns2__getApplications **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__getApplications, sizeof(_ns2__getApplications), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRobotPosResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setRobotPosResponse);
	if (soap_out_PointerTo_ns1__setRobotPosResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRobotPosResponse(struct soap *soap, const char *tag, int id, _ns1__setRobotPosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRobotPosResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__setRobotPosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRobotPosResponse(struct soap *soap, _ns1__setRobotPosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRobotPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__setRobotPosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRobotPosResponse(struct soap *soap, const char *tag, _ns1__setRobotPosResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__setRobotPosResponse **)soap_malloc(soap, sizeof(_ns1__setRobotPosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__setRobotPosResponse *)soap_instantiate__ns1__setRobotPosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__setRobotPosResponse ** p = (_ns1__setRobotPosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRobotPosResponse, sizeof(_ns1__setRobotPosResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__setRobotJointPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__setRobotJointPos);
	if (soap_out_PointerTo_ns1__setRobotJointPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__setRobotJointPos(struct soap *soap, const char *tag, int id, _ns1__setRobotJointPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__setRobotJointPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__setRobotJointPos ** SOAP_FMAC4 soap_get_PointerTo_ns1__setRobotJointPos(struct soap *soap, _ns1__setRobotJointPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__setRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__setRobotJointPos ** SOAP_FMAC4 soap_in_PointerTo_ns1__setRobotJointPos(struct soap *soap, const char *tag, _ns1__setRobotJointPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__setRobotJointPos **)soap_malloc(soap, sizeof(_ns1__setRobotJointPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__setRobotJointPos *)soap_instantiate__ns1__setRobotJointPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__setRobotJointPos ** p = (_ns1__setRobotJointPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__setRobotJointPos, sizeof(_ns1__setRobotJointPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJntCartPosResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRobotJntCartPosResponse);
	if (soap_out_PointerTo_ns1__getRobotJntCartPosResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, int id, _ns1__getRobotJntCartPosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJntCartPosResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, _ns1__getRobotJntCartPosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJntCartPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getRobotJntCartPosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJntCartPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJntCartPosResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJntCartPosResponse **)soap_malloc(soap, sizeof(_ns1__getRobotJntCartPosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJntCartPosResponse *)soap_instantiate__ns1__getRobotJntCartPosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRobotJntCartPosResponse ** p = (_ns1__getRobotJntCartPosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJntCartPosResponse, sizeof(_ns1__getRobotJntCartPosResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJntCartPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRobotJntCartPos);
	if (soap_out_PointerTo_ns1__getRobotJntCartPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, const char *tag, int id, _ns1__getRobotJntCartPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJntCartPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRobotJntCartPos ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, _ns1__getRobotJntCartPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJntCartPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getRobotJntCartPos ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJntCartPos(struct soap *soap, const char *tag, _ns1__getRobotJntCartPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJntCartPos **)soap_malloc(soap, sizeof(_ns1__getRobotJntCartPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJntCartPos *)soap_instantiate__ns1__getRobotJntCartPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRobotJntCartPos ** p = (_ns1__getRobotJntCartPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJntCartPos, sizeof(_ns1__getRobotJntCartPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJointPosResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRobotJointPosResponse);
	if (soap_out_PointerTo_ns1__getRobotJointPosResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, int id, _ns1__getRobotJointPosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJointPosResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, _ns1__getRobotJointPosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJointPosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getRobotJointPosResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJointPosResponse(struct soap *soap, const char *tag, _ns1__getRobotJointPosResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJointPosResponse **)soap_malloc(soap, sizeof(_ns1__getRobotJointPosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJointPosResponse *)soap_instantiate__ns1__getRobotJointPosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRobotJointPosResponse ** p = (_ns1__getRobotJointPosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJointPosResponse, sizeof(_ns1__getRobotJointPosResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotJointPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRobotJointPos);
	if (soap_out_PointerTo_ns1__getRobotJointPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotJointPos(struct soap *soap, const char *tag, int id, _ns1__getRobotJointPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotJointPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRobotJointPos ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotJointPos(struct soap *soap, _ns1__getRobotJointPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotJointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getRobotJointPos ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotJointPos(struct soap *soap, const char *tag, _ns1__getRobotJointPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotJointPos **)soap_malloc(soap, sizeof(_ns1__getRobotJointPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotJointPos *)soap_instantiate__ns1__getRobotJointPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRobotJointPos ** p = (_ns1__getRobotJointPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotJointPos, sizeof(_ns1__getRobotJointPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobotsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRobotsResponse);
	if (soap_out_PointerTo_ns1__getRobotsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobotsResponse(struct soap *soap, const char *tag, int id, _ns1__getRobotsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobotsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRobotsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobotsResponse(struct soap *soap, _ns1__getRobotsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobotsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getRobotsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobotsResponse(struct soap *soap, const char *tag, _ns1__getRobotsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobotsResponse **)soap_malloc(soap, sizeof(_ns1__getRobotsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobotsResponse *)soap_instantiate__ns1__getRobotsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRobotsResponse ** p = (_ns1__getRobotsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobotsResponse, sizeof(_ns1__getRobotsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getRobots(struct soap *soap, _ns1__getRobots *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getRobots))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getRobots(struct soap *soap, _ns1__getRobots *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getRobots);
	if (soap_out_PointerTo_ns1__getRobots(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getRobots(struct soap *soap, const char *tag, int id, _ns1__getRobots *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getRobots);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getRobots ** SOAP_FMAC4 soap_get_PointerTo_ns1__getRobots(struct soap *soap, _ns1__getRobots **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getRobots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getRobots ** SOAP_FMAC4 soap_in_PointerTo_ns1__getRobots(struct soap *soap, const char *tag, _ns1__getRobots **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getRobots **)soap_malloc(soap, sizeof(_ns1__getRobots *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getRobots *)soap_instantiate__ns1__getRobots(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getRobots ** p = (_ns1__getRobots **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getRobots, sizeof(_ns1__getRobots), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__logoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__logoutResponse);
	if (soap_out_PointerTo_ns1__logoutResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__logoutResponse(struct soap *soap, const char *tag, int id, _ns1__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__logoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__logoutResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__logoutResponse(struct soap *soap, _ns1__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__logoutResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__logoutResponse(struct soap *soap, const char *tag, _ns1__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__logoutResponse **)soap_malloc(soap, sizeof(_ns1__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__logoutResponse *)soap_instantiate__ns1__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__logoutResponse ** p = (_ns1__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__logoutResponse, sizeof(_ns1__logoutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__logout(struct soap *soap, _ns1__logout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__logout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__logout(struct soap *soap, _ns1__logout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__logout);
	if (soap_out_PointerTo_ns1__logout(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__logout(struct soap *soap, const char *tag, int id, _ns1__logout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__logout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__logout ** SOAP_FMAC4 soap_get_PointerTo_ns1__logout(struct soap *soap, _ns1__logout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__logout ** SOAP_FMAC4 soap_in_PointerTo_ns1__logout(struct soap *soap, const char *tag, _ns1__logout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__logout **)soap_malloc(soap, sizeof(_ns1__logout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__logout *)soap_instantiate__ns1__logout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__logout ** p = (_ns1__logout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__logout, sizeof(_ns1__logout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__loginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__loginResponse);
	if (soap_out_PointerTo_ns1__loginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, int id, _ns1__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__loginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__loginResponse(struct soap *soap, _ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__loginResponse(struct soap *soap, const char *tag, _ns1__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__loginResponse **)soap_malloc(soap, sizeof(_ns1__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__loginResponse *)soap_instantiate__ns1__loginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__loginResponse ** p = (_ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__loginResponse, sizeof(_ns1__loginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__login(struct soap *soap, _ns1__login *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__login))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__login(struct soap *soap, _ns1__login *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__login);
	if (soap_out_PointerTo_ns1__login(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__login(struct soap *soap, const char *tag, int id, _ns1__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__login);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__login ** SOAP_FMAC4 soap_get_PointerTo_ns1__login(struct soap *soap, _ns1__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__login ** SOAP_FMAC4 soap_in_PointerTo_ns1__login(struct soap *soap, const char *tag, _ns1__login **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__login **)soap_malloc(soap, sizeof(_ns1__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__login *)soap_instantiate__ns1__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__login ** p = (_ns1__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__login, sizeof(_ns1__login), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCS8VersionsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCS8VersionsResponse);
	if (soap_out_PointerTo_ns1__getCS8VersionsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, int id, _ns1__getCS8VersionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCS8VersionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, _ns1__getCS8VersionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCS8VersionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getCS8VersionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCS8VersionsResponse(struct soap *soap, const char *tag, _ns1__getCS8VersionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getCS8VersionsResponse **)soap_malloc(soap, sizeof(_ns1__getCS8VersionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getCS8VersionsResponse *)soap_instantiate__ns1__getCS8VersionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getCS8VersionsResponse ** p = (_ns1__getCS8VersionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCS8VersionsResponse, sizeof(_ns1__getCS8VersionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getCS8Versions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getCS8Versions);
	if (soap_out_PointerTo_ns1__getCS8Versions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getCS8Versions(struct soap *soap, const char *tag, int id, _ns1__getCS8Versions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getCS8Versions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getCS8Versions ** SOAP_FMAC4 soap_get_PointerTo_ns1__getCS8Versions(struct soap *soap, _ns1__getCS8Versions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getCS8Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getCS8Versions ** SOAP_FMAC4 soap_in_PointerTo_ns1__getCS8Versions(struct soap *soap, const char *tag, _ns1__getCS8Versions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getCS8Versions **)soap_malloc(soap, sizeof(_ns1__getCS8Versions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getCS8Versions *)soap_instantiate__ns1__getCS8Versions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getCS8Versions ** p = (_ns1__getCS8Versions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getCS8Versions, sizeof(_ns1__getCS8Versions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__pingResponse(struct soap *soap, _ns1__pingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__pingResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__pingResponse(struct soap *soap, _ns1__pingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__pingResponse);
	if (soap_out_PointerTo_ns1__pingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__pingResponse(struct soap *soap, const char *tag, int id, _ns1__pingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__pingResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__pingResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__pingResponse(struct soap *soap, _ns1__pingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__pingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__pingResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__pingResponse(struct soap *soap, const char *tag, _ns1__pingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__pingResponse **)soap_malloc(soap, sizeof(_ns1__pingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__pingResponse *)soap_instantiate__ns1__pingResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__pingResponse ** p = (_ns1__pingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__pingResponse, sizeof(_ns1__pingResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ping(struct soap *soap, _ns1__ping *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ping))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ping(struct soap *soap, _ns1__ping *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ping);
	if (soap_out_PointerTo_ns1__ping(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ping(struct soap *soap, const char *tag, int id, _ns1__ping *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ping);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ping ** SOAP_FMAC4 soap_get_PointerTo_ns1__ping(struct soap *soap, _ns1__ping **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__ping ** SOAP_FMAC4 soap_in_PointerTo_ns1__ping(struct soap *soap, const char *tag, _ns1__ping **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ping **)soap_malloc(soap, sizeof(_ns1__ping *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ping *)soap_instantiate__ns1__ping(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ping ** p = (_ns1__ping **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ping, sizeof(_ns1__ping), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSoapServerVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSoapServerVersionResponse);
	if (soap_out_PointerTo_ns1__getSoapServerVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, int id, _ns1__getSoapServerVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSoapServerVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, _ns1__getSoapServerVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSoapServerVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getSoapServerVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSoapServerVersionResponse(struct soap *soap, const char *tag, _ns1__getSoapServerVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSoapServerVersionResponse **)soap_malloc(soap, sizeof(_ns1__getSoapServerVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSoapServerVersionResponse *)soap_instantiate__ns1__getSoapServerVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSoapServerVersionResponse ** p = (_ns1__getSoapServerVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSoapServerVersionResponse, sizeof(_ns1__getSoapServerVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getSoapServerVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__getSoapServerVersion);
	if (soap_out_PointerTo_ns1__getSoapServerVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getSoapServerVersion(struct soap *soap, const char *tag, int id, _ns1__getSoapServerVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getSoapServerVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getSoapServerVersion ** SOAP_FMAC4 soap_get_PointerTo_ns1__getSoapServerVersion(struct soap *soap, _ns1__getSoapServerVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getSoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__getSoapServerVersion ** SOAP_FMAC4 soap_in_PointerTo_ns1__getSoapServerVersion(struct soap *soap, const char *tag, _ns1__getSoapServerVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getSoapServerVersion **)soap_malloc(soap, sizeof(_ns1__getSoapServerVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getSoapServerVersion *)soap_instantiate__ns1__getSoapServerVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__getSoapServerVersion ** p = (_ns1__getSoapServerVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getSoapServerVersion, sizeof(_ns1__getSoapServerVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ServerException(struct soap *soap, ns1__ServerException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ServerException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ServerException(struct soap *soap, ns1__ServerException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ServerException);
	if (soap_out_PointerTons1__ServerException(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ServerException(struct soap *soap, const char *tag, int id, ns1__ServerException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ServerException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ServerException ** SOAP_FMAC4 soap_get_PointerTons1__ServerException(struct soap *soap, ns1__ServerException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ServerException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ServerException ** SOAP_FMAC4 soap_in_PointerTons1__ServerException(struct soap *soap, const char *tag, ns1__ServerException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ServerException **)soap_malloc(soap, sizeof(ns1__ServerException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ServerException *)soap_instantiate_ns1__ServerException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ServerException ** p = (ns1__ServerException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ServerException, sizeof(ns1__ServerException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SessionId(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__SessionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SessionId(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SessionId);
	if (soap_out_PointerTons1__SessionId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SessionId(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SessionId);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SessionId(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerTons1__SessionId(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SessionId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerTons1__SessionId(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SessionId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SessionId, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__AllRobotsPos(struct soap *soap, ns6__AllRobotsPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__AllRobotsPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__AllRobotsPos(struct soap *soap, ns6__AllRobotsPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__AllRobotsPos);
	if (soap_out_PointerTons6__AllRobotsPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__AllRobotsPos(struct soap *soap, const char *tag, int id, ns6__AllRobotsPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__AllRobotsPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__AllRobotsPos ** SOAP_FMAC4 soap_get_PointerTons6__AllRobotsPos(struct soap *soap, ns6__AllRobotsPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__AllRobotsPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__AllRobotsPos ** SOAP_FMAC4 soap_in_PointerTons6__AllRobotsPos(struct soap *soap, const char *tag, ns6__AllRobotsPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__AllRobotsPos **)soap_malloc(soap, sizeof(ns6__AllRobotsPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__AllRobotsPos *)soap_instantiate_ns6__AllRobotsPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__AllRobotsPos ** p = (ns6__AllRobotsPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AllRobotsPos, sizeof(ns6__AllRobotsPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__MotionDesc(struct soap *soap, ns6__MotionDesc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__MotionDesc))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__MotionDesc(struct soap *soap, ns6__MotionDesc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__MotionDesc);
	if (soap_out_PointerTons6__MotionDesc(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__MotionDesc(struct soap *soap, const char *tag, int id, ns6__MotionDesc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__MotionDesc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__MotionDesc ** SOAP_FMAC4 soap_get_PointerTons6__MotionDesc(struct soap *soap, ns6__MotionDesc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__MotionDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__MotionDesc ** SOAP_FMAC4 soap_in_PointerTons6__MotionDesc(struct soap *soap, const char *tag, ns6__MotionDesc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__MotionDesc **)soap_malloc(soap, sizeof(ns6__MotionDesc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__MotionDesc *)soap_instantiate_ns6__MotionDesc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__MotionDesc ** p = (ns6__MotionDesc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__MotionDesc, sizeof(ns6__MotionDesc), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Config(struct soap *soap, ns6__Config *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Config))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Config(struct soap *soap, ns6__Config *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Config);
	if (soap_out_PointerTons6__Config(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Config(struct soap *soap, const char *tag, int id, ns6__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Config);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Config ** SOAP_FMAC4 soap_get_PointerTons6__Config(struct soap *soap, ns6__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__Config ** SOAP_FMAC4 soap_in_PointerTons6__Config(struct soap *soap, const char *tag, ns6__Config **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Config **)soap_malloc(soap, sizeof(ns6__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__Config *)soap_instantiate_ns6__Config(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__Config ** p = (ns6__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Config, sizeof(ns6__Config), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__Frame(struct soap *soap, ns6__Frame *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__Frame))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__Frame(struct soap *soap, ns6__Frame *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__Frame);
	if (soap_out_PointerTons6__Frame(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__Frame(struct soap *soap, const char *tag, int id, ns6__Frame *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__Frame);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__Frame ** SOAP_FMAC4 soap_get_PointerTons6__Frame(struct soap *soap, ns6__Frame **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__Frame ** SOAP_FMAC4 soap_in_PointerTons6__Frame(struct soap *soap, const char *tag, ns6__Frame **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__Frame **)soap_malloc(soap, sizeof(ns6__Frame *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__Frame *)soap_instantiate_ns6__Frame(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__Frame ** p = (ns6__Frame **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__Frame, sizeof(ns6__Frame), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__VrbxConfig(struct soap *soap, ns6__VrbxConfig *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__VrbxConfig))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__VrbxConfig(struct soap *soap, ns6__VrbxConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__VrbxConfig);
	if (soap_out_PointerTons6__VrbxConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__VrbxConfig(struct soap *soap, const char *tag, int id, ns6__VrbxConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__VrbxConfig);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__VrbxConfig ** SOAP_FMAC4 soap_get_PointerTons6__VrbxConfig(struct soap *soap, ns6__VrbxConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__VrbxConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__VrbxConfig ** SOAP_FMAC4 soap_in_PointerTons6__VrbxConfig(struct soap *soap, const char *tag, ns6__VrbxConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__VrbxConfig **)soap_malloc(soap, sizeof(ns6__VrbxConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__VrbxConfig *)soap_instantiate_ns6__VrbxConfig(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__VrbxConfig ** p = (ns6__VrbxConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__VrbxConfig, sizeof(ns6__VrbxConfig), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ScaraConfig(struct soap *soap, ns6__ScaraConfig *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ScaraConfig))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ScaraConfig(struct soap *soap, ns6__ScaraConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ScaraConfig);
	if (soap_out_PointerTons6__ScaraConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ScaraConfig(struct soap *soap, const char *tag, int id, ns6__ScaraConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ScaraConfig);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ScaraConfig ** SOAP_FMAC4 soap_get_PointerTons6__ScaraConfig(struct soap *soap, ns6__ScaraConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ScaraConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__ScaraConfig ** SOAP_FMAC4 soap_in_PointerTons6__ScaraConfig(struct soap *soap, const char *tag, ns6__ScaraConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ScaraConfig **)soap_malloc(soap, sizeof(ns6__ScaraConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ScaraConfig *)soap_instantiate_ns6__ScaraConfig(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ScaraConfig ** p = (ns6__ScaraConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ScaraConfig, sizeof(ns6__ScaraConfig), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__AnthroConfig(struct soap *soap, ns6__AnthroConfig *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__AnthroConfig))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__AnthroConfig(struct soap *soap, ns6__AnthroConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__AnthroConfig);
	if (soap_out_PointerTons6__AnthroConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__AnthroConfig(struct soap *soap, const char *tag, int id, ns6__AnthroConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__AnthroConfig);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__AnthroConfig ** SOAP_FMAC4 soap_get_PointerTons6__AnthroConfig(struct soap *soap, ns6__AnthroConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__AnthroConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__AnthroConfig ** SOAP_FMAC4 soap_in_PointerTons6__AnthroConfig(struct soap *soap, const char *tag, ns6__AnthroConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__AnthroConfig **)soap_malloc(soap, sizeof(ns6__AnthroConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__AnthroConfig *)soap_instantiate_ns6__AnthroConfig(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__AnthroConfig ** p = (ns6__AnthroConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AnthroConfig, sizeof(ns6__AnthroConfig), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RobotPos(struct soap *soap, ns6__RobotPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__RobotPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RobotPos(struct soap *soap, ns6__RobotPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RobotPos);
	if (soap_out_PointerTons6__RobotPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__RobotPos(struct soap *soap, const char *tag, int id, ns6__RobotPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RobotPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RobotPos ** SOAP_FMAC4 soap_get_PointerTons6__RobotPos(struct soap *soap, ns6__RobotPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__RobotPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns6__RobotPos ** SOAP_FMAC4 soap_in_PointerTons6__RobotPos(struct soap *soap, const char *tag, ns6__RobotPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__RobotPos **)soap_malloc(soap, sizeof(ns6__RobotPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__RobotPos *)soap_instantiate_ns6__RobotPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__RobotPos ** p = (ns6__RobotPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RobotPos, sizeof(ns6__RobotPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__JointRange(struct soap *soap, ns2__JointRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__JointRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__JointRange(struct soap *soap, ns2__JointRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__JointRange);
	if (soap_out_PointerTons2__JointRange(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__JointRange(struct soap *soap, const char *tag, int id, ns2__JointRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__JointRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__JointRange ** SOAP_FMAC4 soap_get_PointerTons2__JointRange(struct soap *soap, ns2__JointRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__JointRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns2__JointRange ** SOAP_FMAC4 soap_in_PointerTons2__JointRange(struct soap *soap, const char *tag, ns2__JointRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__JointRange **)soap_malloc(soap, sizeof(ns2__JointRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__JointRange *)soap_instantiate_ns2__JointRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__JointRange ** p = (ns2__JointRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__JointRange, sizeof(ns2__JointRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Records(struct soap *soap, ns2__Records *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Records))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Records(struct soap *soap, ns2__Records *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Records);
	if (soap_out_PointerTons2__Records(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Records(struct soap *soap, const char *tag, int id, ns2__Records *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Records);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Records ** SOAP_FMAC4 soap_get_PointerTons2__Records(struct soap *soap, ns2__Records **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Records(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns2__Records ** SOAP_FMAC4 soap_in_PointerTons2__Records(struct soap *soap, const char *tag, ns2__Records **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Records **)soap_malloc(soap, sizeof(ns2__Records *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Records *)soap_instantiate_ns2__Records(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Records ** p = (ns2__Records **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Records, sizeof(ns2__Records), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VALApplications(struct soap *soap, ns2__VALApplications *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VALApplications))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VALApplications(struct soap *soap, ns2__VALApplications *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VALApplications);
	if (soap_out_PointerTons2__VALApplications(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VALApplications(struct soap *soap, const char *tag, int id, ns2__VALApplications *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VALApplications);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VALApplications ** SOAP_FMAC4 soap_get_PointerTons2__VALApplications(struct soap *soap, ns2__VALApplications **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VALApplications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns2__VALApplications ** SOAP_FMAC4 soap_in_PointerTons2__VALApplications(struct soap *soap, const char *tag, ns2__VALApplications **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VALApplications **)soap_malloc(soap, sizeof(ns2__VALApplications *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VALApplications *)soap_instantiate_ns2__VALApplications(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__VALApplications ** p = (ns2__VALApplications **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VALApplications, sizeof(ns2__VALApplications), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__Include(struct soap *soap, ns3__Include *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__Include))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__Include(struct soap *soap, ns3__Include *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__Include);
	if (soap_out_PointerTons3__Include(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__Include(struct soap *soap, const char *tag, int id, ns3__Include *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__Include);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__Include ** SOAP_FMAC4 soap_get_PointerTons3__Include(struct soap *soap, ns3__Include **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns3__Include ** SOAP_FMAC4 soap_in_PointerTons3__Include(struct soap *soap, const char *tag, ns3__Include **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__Include **)soap_malloc(soap, sizeof(ns3__Include *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__Include *)soap_instantiate_ns3__Include(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__Include ** p = (ns3__Include **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__Include, sizeof(ns3__Include), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VALApplication(struct soap *soap, ns2__VALApplication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VALApplication))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VALApplication(struct soap *soap, ns2__VALApplication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VALApplication);
	if (soap_out_PointerTons2__VALApplication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VALApplication(struct soap *soap, const char *tag, int id, ns2__VALApplication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VALApplication);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VALApplication ** SOAP_FMAC4 soap_get_PointerTons2__VALApplication(struct soap *soap, ns2__VALApplication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VALApplication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns2__VALApplication ** SOAP_FMAC4 soap_in_PointerTons2__VALApplication(struct soap *soap, const char *tag, ns2__VALApplication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VALApplication **)soap_malloc(soap, sizeof(ns2__VALApplication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VALApplication *)soap_instantiate_ns2__VALApplication(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__VALApplication ** p = (ns2__VALApplication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VALApplication, sizeof(ns2__VALApplication), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Parameters(struct soap *soap, ns1__Parameters *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Parameters))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Parameters(struct soap *soap, ns1__Parameters *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Parameters);
	if (soap_out_PointerTons1__Parameters(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Parameters(struct soap *soap, const char *tag, int id, ns1__Parameters *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Parameters);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Parameters ** SOAP_FMAC4 soap_get_PointerTons1__Parameters(struct soap *soap, ns1__Parameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Parameters ** SOAP_FMAC4 soap_in_PointerTons1__Parameters(struct soap *soap, const char *tag, ns1__Parameters **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Parameters **)soap_malloc(soap, sizeof(ns1__Parameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Parameters *)soap_instantiate_ns1__Parameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Parameters ** p = (ns1__Parameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Parameters, sizeof(ns1__Parameters), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CartesianPos(struct soap *soap, ns1__CartesianPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CartesianPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CartesianPos(struct soap *soap, ns1__CartesianPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CartesianPos);
	if (soap_out_PointerTons1__CartesianPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CartesianPos(struct soap *soap, const char *tag, int id, ns1__CartesianPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CartesianPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CartesianPos ** SOAP_FMAC4 soap_get_PointerTons1__CartesianPos(struct soap *soap, ns1__CartesianPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CartesianPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__CartesianPos ** SOAP_FMAC4 soap_in_PointerTons1__CartesianPos(struct soap *soap, const char *tag, ns1__CartesianPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CartesianPos **)soap_malloc(soap, sizeof(ns1__CartesianPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CartesianPos *)soap_instantiate_ns1__CartesianPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CartesianPos ** p = (ns1__CartesianPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CartesianPos, sizeof(ns1__CartesianPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__JointPos(struct soap *soap, ns1__JointPos *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__JointPos))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__JointPos(struct soap *soap, ns1__JointPos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__JointPos);
	if (soap_out_PointerTons1__JointPos(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__JointPos(struct soap *soap, const char *tag, int id, ns1__JointPos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__JointPos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__JointPos ** SOAP_FMAC4 soap_get_PointerTons1__JointPos(struct soap *soap, ns1__JointPos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__JointPos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__JointPos ** SOAP_FMAC4 soap_in_PointerTons1__JointPos(struct soap *soap, const char *tag, ns1__JointPos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__JointPos **)soap_malloc(soap, sizeof(ns1__JointPos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__JointPos *)soap_instantiate_ns1__JointPos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__JointPos ** p = (ns1__JointPos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__JointPos, sizeof(ns1__JointPos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Robots(struct soap *soap, ns1__Robots *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Robots))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Robots(struct soap *soap, ns1__Robots *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Robots);
	if (soap_out_PointerTons1__Robots(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Robots(struct soap *soap, const char *tag, int id, ns1__Robots *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Robots);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Robots ** SOAP_FMAC4 soap_get_PointerTons1__Robots(struct soap *soap, ns1__Robots **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Robots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Robots ** SOAP_FMAC4 soap_in_PointerTons1__Robots(struct soap *soap, const char *tag, ns1__Robots **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Robots **)soap_malloc(soap, sizeof(ns1__Robots *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Robots *)soap_instantiate_ns1__Robots(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Robots ** p = (ns1__Robots **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Robots, sizeof(ns1__Robots), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Versions(struct soap *soap, ns1__Versions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Versions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Versions(struct soap *soap, ns1__Versions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Versions);
	if (soap_out_PointerTons1__Versions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Versions(struct soap *soap, const char *tag, int id, ns1__Versions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Versions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Versions ** SOAP_FMAC4 soap_get_PointerTons1__Versions(struct soap *soap, ns1__Versions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Versions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Versions ** SOAP_FMAC4 soap_in_PointerTons1__Versions(struct soap *soap, const char *tag, ns1__Versions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Versions **)soap_malloc(soap, sizeof(ns1__Versions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Versions *)soap_instantiate_ns1__Versions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Versions ** p = (ns1__Versions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Versions, sizeof(ns1__Versions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoapServerVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoapServerVersion);
	if (soap_out_PointerTons1__SoapServerVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoapServerVersion(struct soap *soap, const char *tag, int id, ns1__SoapServerVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoapServerVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoapServerVersion ** SOAP_FMAC4 soap_get_PointerTons1__SoapServerVersion(struct soap *soap, ns1__SoapServerVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoapServerVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__SoapServerVersion ** SOAP_FMAC4 soap_in_PointerTons1__SoapServerVersion(struct soap *soap, const char *tag, ns1__SoapServerVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoapServerVersion **)soap_malloc(soap, sizeof(ns1__SoapServerVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoapServerVersion *)soap_instantiate_ns1__SoapServerVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SoapServerVersion ** p = (ns1__SoapServerVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoapServerVersion, sizeof(ns1__SoapServerVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Parameter(struct soap *soap, ns1__Parameter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Parameter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Parameter(struct soap *soap, ns1__Parameter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Parameter);
	if (soap_out_PointerTons1__Parameter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Parameter(struct soap *soap, const char *tag, int id, ns1__Parameter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Parameter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Parameter ** SOAP_FMAC4 soap_get_PointerTons1__Parameter(struct soap *soap, ns1__Parameter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Parameter ** SOAP_FMAC4 soap_in_PointerTons1__Parameter(struct soap *soap, const char *tag, ns1__Parameter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Parameter **)soap_malloc(soap, sizeof(ns1__Parameter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Parameter *)soap_instantiate_ns1__Parameter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Parameter ** p = (ns1__Parameter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Parameter, sizeof(ns1__Parameter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Robot(struct soap *soap, ns1__Robot *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Robot))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Robot(struct soap *soap, ns1__Robot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Robot);
	if (soap_out_PointerTons1__Robot(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Robot(struct soap *soap, const char *tag, int id, ns1__Robot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Robot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Robot ** SOAP_FMAC4 soap_get_PointerTons1__Robot(struct soap *soap, ns1__Robot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Robot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Robot ** SOAP_FMAC4 soap_in_PointerTons1__Robot(struct soap *soap, const char *tag, ns1__Robot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Robot **)soap_malloc(soap, sizeof(ns1__Robot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Robot *)soap_instantiate_ns1__Robot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Robot ** p = (ns1__Robot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Robot, sizeof(ns1__Robot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Version(struct soap *soap, ns1__Version *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Version))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Version(struct soap *soap, ns1__Version *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Version);
	if (soap_out_PointerTons1__Version(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Version(struct soap *soap, const char *tag, int id, ns1__Version *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Version);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Version ** SOAP_FMAC4 soap_get_PointerTons1__Version(struct soap *soap, ns1__Version **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Version(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Version ** SOAP_FMAC4 soap_in_PointerTons1__Version(struct soap *soap, const char *tag, ns1__Version **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Version **)soap_malloc(soap, sizeof(ns1__Version *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Version *)soap_instantiate_ns1__Version(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Version ** p = (ns1__Version **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Version, sizeof(ns1__Version), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__RobotPos(struct soap *soap, std::vector<ns6__RobotPos * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__RobotPos(struct soap *soap, const std::vector<ns6__RobotPos * >*a)
{
	for (std::vector<ns6__RobotPos * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__RobotPos(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__RobotPos(struct soap *soap, const char *tag, int id, const std::vector<ns6__RobotPos * >*a, const char *type)
{
	for (std::vector<ns6__RobotPos * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__RobotPos(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__RobotPos * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__RobotPos(struct soap *soap, const char *tag, std::vector<ns6__RobotPos * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__RobotPos(soap, -1)))
		return NULL;
	ns6__RobotPos *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns6__RobotPos, SOAP_TYPE_std__vectorTemplateOfPointerTons6__RobotPos, sizeof(ns6__RobotPos), 1))
				break;
			if (!soap_in_PointerTons6__RobotPos(soap, tag, NULL, "ns6:RobotPos"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons6__RobotPos(soap, tag, &n, "ns6:RobotPos"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns6__RobotPos * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons6__RobotPos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons6__RobotPos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons6__RobotPos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns6__RobotPos * >;
		if (size)
			*size = sizeof(std::vector<ns6__RobotPos * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns6__RobotPos * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns6__RobotPos * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns6__RobotPos * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons6__RobotPos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns6__RobotPos * > %p -> %p\n", q, p));
	*(std::vector<ns6__RobotPos * >*)p = *(std::vector<ns6__RobotPos * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<char * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, std::vector<ns2__VALApplication * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, const std::vector<ns2__VALApplication * >*a)
{
	for (std::vector<ns2__VALApplication * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__VALApplication(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, const char *tag, int id, const std::vector<ns2__VALApplication * >*a, const char *type)
{
	for (std::vector<ns2__VALApplication * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__VALApplication(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__VALApplication * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, const char *tag, std::vector<ns2__VALApplication * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__VALApplication(soap, -1)))
		return NULL;
	ns2__VALApplication *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__VALApplication, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication, sizeof(ns2__VALApplication), 1))
				break;
			if (!soap_in_PointerTons2__VALApplication(soap, tag, NULL, "ns2:VALApplication"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__VALApplication(soap, tag, &n, "ns2:VALApplication"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns2__VALApplication * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__VALApplication(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VALApplication, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns2__VALApplication * >;
		if (size)
			*size = sizeof(std::vector<ns2__VALApplication * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns2__VALApplication * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__VALApplication * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__VALApplication * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__VALApplication(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__VALApplication * > %p -> %p\n", q, p));
	*(std::vector<ns2__VALApplication * >*)p = *(std::vector<ns2__VALApplication * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, std::vector<ns1__Parameter * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, const std::vector<ns1__Parameter * >*a)
{
	for (std::vector<ns1__Parameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Parameter(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, const char *tag, int id, const std::vector<ns1__Parameter * >*a, const char *type)
{
	for (std::vector<ns1__Parameter * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Parameter(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Parameter * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, const char *tag, std::vector<ns1__Parameter * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Parameter(soap, -1)))
		return NULL;
	ns1__Parameter *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Parameter, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter, sizeof(ns1__Parameter), 1))
				break;
			if (!soap_in_PointerTons1__Parameter(soap, tag, NULL, "ns1:Parameter"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Parameter(soap, tag, &n, "ns1:Parameter"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns1__Parameter * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Parameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Parameter * >;
		if (size)
			*size = sizeof(std::vector<ns1__Parameter * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Parameter * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Parameter * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Parameter * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Parameter * > %p -> %p\n", q, p));
	*(std::vector<ns1__Parameter * >*)p = *(std::vector<ns1__Parameter * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, std::vector<ns1__Robot * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, const std::vector<ns1__Robot * >*a)
{
	for (std::vector<ns1__Robot * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Robot(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, const char *tag, int id, const std::vector<ns1__Robot * >*a, const char *type)
{
	for (std::vector<ns1__Robot * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Robot(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Robot * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, const char *tag, std::vector<ns1__Robot * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Robot(soap, -1)))
		return NULL;
	ns1__Robot *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Robot, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot, sizeof(ns1__Robot), 1))
				break;
			if (!soap_in_PointerTons1__Robot(soap, tag, NULL, "ns1:Robot"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Robot(soap, tag, &n, "ns1:Robot"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns1__Robot * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Robot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Robot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Robot * >;
		if (size)
			*size = sizeof(std::vector<ns1__Robot * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Robot * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Robot * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Robot * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Robot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Robot * > %p -> %p\n", q, p));
	*(std::vector<ns1__Robot * >*)p = *(std::vector<ns1__Robot * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, std::vector<ns1__Version * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, const std::vector<ns1__Version * >*a)
{
	for (std::vector<ns1__Version * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Version(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, const char *tag, int id, const std::vector<ns1__Version * >*a, const char *type)
{
	for (std::vector<ns1__Version * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Version(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Version * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, const char *tag, std::vector<ns1__Version * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Version(soap, -1)))
		return NULL;
	ns1__Version *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Version, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version, sizeof(ns1__Version), 1))
				break;
			if (!soap_in_PointerTons1__Version(soap, tag, NULL, "ns1:Version"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Version(soap, tag, &n, "ns1:Version"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns1__Version * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Version(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Version, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__Version * >;
		if (size)
			*size = sizeof(std::vector<ns1__Version * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__Version * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Version * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Version * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Version(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Version * > %p -> %p\n", q, p));
	*(std::vector<ns1__Version * >*)p = *(std::vector<ns1__Version * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdouble(struct soap *soap, std::vector<double >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdouble(struct soap *soap, const std::vector<double >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, int id, const std::vector<double >*a, const char *type)
{
	for (std::vector<double >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_double(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<double >* SOAP_FMAC4 soap_in_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, std::vector<double >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfdouble(soap, -1)))
		return NULL;
	double n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_double(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_double, SOAP_TYPE_std__vectorTemplateOfdouble, sizeof(double), 0))
				break;
			if (!soap_in_double(soap, tag, NULL, "xsd:double"))
				break;
		}
		else
		{
			if (!soap_in_double(soap, tag, &n, "xsd:double"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<double > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfdouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfdouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<double >;
		if (size)
			*size = sizeof(std::vector<double >);
	}
	else
	{	cp->ptr = (void*)new std::vector<double >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<double >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<double >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfdouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<double > %p -> %p\n", q, p));
	*(std::vector<double >*)p = *(std::vector<double >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
