/* soapStub.h
   Generated by gSOAP 2.7.13 from cs8server.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__ServerExceptionCode
#define SOAP_TYPE_ns1__ServerExceptionCode (107)
/* ns1:ServerExceptionCode */
enum ns1__ServerExceptionCode {ns1__ServerExceptionCode__UNKNOWN_CODE = 0, ns1__ServerExceptionCode__INVALID_SESSION_ID_CODE = 1, ns1__ServerExceptionCode__INVALID_ROBOT_ID_CODE = 2, ns1__ServerExceptionCode__READ_ACCESS_ERROR_CODE = 3, ns1__ServerExceptionCode__WRITE_ACCESS_ERROR_CODE = 4, ns1__ServerExceptionCode__SET_POS_NOT_SIMUL_CODE = 5, ns1__ServerExceptionCode__SET_POS_POWER_ON_CODE = 6, ns1__ServerExceptionCode__FILE_NOT_FOUND_CODE = 7, ns1__ServerExceptionCode__INVALID_CONFIG_CODE = 8, ns1__ServerExceptionCode__INVALID_NUMBER_OF_AXIS_CODE = 9, ns1__ServerExceptionCode__INVALID_MOT_DESC_CODE = 10, ns1__ServerExceptionCode__CLIENT_ALREADY_CONNECTED = 11, ns1__ServerExceptionCode__CLIENT_COMMUNICATION_ERROR = 12, ns1__ServerExceptionCode__APPLICATION_NOT_FOUND = 13, ns1__ServerExceptionCode__PROGRAM_NOT_FOUND = 14, ns1__ServerExceptionCode__TASK_NOT_FOUND = 15, ns1__ServerExceptionCode__STACK_FRAME_NOT_FOUND = 16, ns1__ServerExceptionCode__TASK_ALREADY_LOCKED = 17, ns1__ServerExceptionCode__INVALID_SOAP_HANDLER = 18, ns1__ServerExceptionCode__INVALID_SOAP_HEADER = 19, ns1__ServerExceptionCode__PROGRAM_LINE_NOT_FOUND = 20};
#endif

#ifndef SOAP_TYPE_ns1__Kinematic
#define SOAP_TYPE_ns1__Kinematic (108)
/* ns1:Kinematic */
enum ns1__Kinematic {ns1__Kinematic__KINEMATIC_INVALID = 0, ns1__Kinematic__KINEMATIC_ANTHROPOMORPH6 = 1, ns1__Kinematic__KINEMATIC_ANTHROPOMORPH5 = 2, ns1__Kinematic__KINEMATIC_SCARA = 3, ns1__Kinematic__KINEMATIC_EISENMANN = 4};
#endif

#ifndef SOAP_TYPE_ns1__MountType
#define SOAP_TYPE_ns1__MountType (109)
/* ns1:MountType */
enum ns1__MountType {ns1__MountType__MOUNTTYPE_INVALID = 0, ns1__MountType__MOUNTTYPE_FLOOR = 1, ns1__MountType__MOUNTTYPE_CEILING = 2, ns1__MountType__MOUNTTYPE_WALL = 3};
#endif

#ifndef SOAP_TYPE_ns1__LengthAxis3
#define SOAP_TYPE_ns1__LengthAxis3 (110)
/* ns1:LengthAxis3 */
enum ns1__LengthAxis3 {ns1__LengthAxis3__LENGTHAXIS3_INVALID = 0, ns1__LengthAxis3__LENGTHAXIS3_L100 = 1, ns1__LengthAxis3__LENGTHAXIS3_L200 = 2, ns1__LengthAxis3__LENGTHAXIS3_L400 = 3, ns1__LengthAxis3__LENGTHAXIS3_L600 = 4};
#endif

#ifndef SOAP_TYPE_ns1__DiameterAxis3
#define SOAP_TYPE_ns1__DiameterAxis3 (111)
/* ns1:DiameterAxis3 */
enum ns1__DiameterAxis3 {ns1__DiameterAxis3__DIAMETERAXIS3_INVALID = 0, ns1__DiameterAxis3__DIAMETERAXIS3_D20 = 1, ns1__DiameterAxis3__DIAMETERAXIS3_D25 = 2};
#endif

#ifndef SOAP_TYPE_ns6__MoveType
#define SOAP_TYPE_ns6__MoveType (112)
/* ns6:MoveType */
enum ns6__MoveType {ns6__MoveType__ABSOLUTE_MOVE = 0, ns6__MoveType__RELATIVE_MOVE = 1};
#endif

#ifndef SOAP_TYPE_ns6__BlendType
#define SOAP_TYPE_ns6__BlendType (113)
/* ns6:BlendType */
enum ns6__BlendType {ns6__BlendType__BLEND_OFF = 0, ns6__BlendType__BLEND_JOINT = 1, ns6__BlendType__BLEND_CART = 2};
#endif

#ifndef SOAP_TYPE_ns6__ShoulderConfig
#define SOAP_TYPE_ns6__ShoulderConfig (114)
/* ns6:ShoulderConfig */
enum ns6__ShoulderConfig {ns6__ShoulderConfig__SSAME = 0, ns6__ShoulderConfig__LEFTY = 1, ns6__ShoulderConfig__RIGHTY = 2, ns6__ShoulderConfig__SFREE = 3};
#endif

#ifndef SOAP_TYPE_ns6__PositiveNegativeConfig
#define SOAP_TYPE_ns6__PositiveNegativeConfig (115)
/* ns6:PositiveNegativeConfig */
enum ns6__PositiveNegativeConfig {ns6__PositiveNegativeConfig__PNSAME = 0, ns6__PositiveNegativeConfig__POSITIVE = 1, ns6__PositiveNegativeConfig__NEGATIVE = 2, ns6__PositiveNegativeConfig__PNFREE = 3};
#endif

#ifndef SOAP_TYPE_ns6__AboveBelowConfig
#define SOAP_TYPE_ns6__AboveBelowConfig (116)
/* ns6:AboveBelowConfig */
enum ns6__AboveBelowConfig {ns6__AboveBelowConfig__ABSAME = 0, ns6__AboveBelowConfig__ABOVE = 1, ns6__AboveBelowConfig__BELOW = 2, ns6__AboveBelowConfig__ABFREE = 3};
#endif

#ifndef SOAP_TYPE_ns6__MotionReturnCode
#define SOAP_TYPE_ns6__MotionReturnCode (117)
/* ns6:MotionReturnCode */
enum ns6__MotionReturnCode {ns6__MotionReturnCode__SCSV3_MOT_NO_ERR = 0, ns6__MotionReturnCode__SCSV3_MOT_NOT_READY = 1, ns6__MotionReturnCode__SCSV3_MOT_ERR_PARAM = 2, ns6__MotionReturnCode__SCSV3_MOT_ERR_MISUSE = 3, ns6__MotionReturnCode__SCSV3_MOT_ERR_UNEXPECTED = 4};
#endif

#ifndef SOAP_TYPE_ns6__ReversingResult
#define SOAP_TYPE_ns6__ReversingResult (118)
/* ns6:ReversingResult */
enum ns6__ReversingResult {ns6__ReversingResult__REVERSE_OK = 0, ns6__ReversingResult__NO_CONVERGENCE = 1, ns6__ReversingResult__OUT_OF_JNT_RANGE = 2, ns6__ReversingResult__OUT_OF_WORKSPACE = 3, ns6__ReversingResult__INVALID_CONFIG = 4, ns6__ReversingResult__INVALID_ORIENTATION = 5, ns6__ReversingResult__UNSUPPORTED_KINEMATICS = 6, ns6__ReversingResult__UNCONSTRAINT_FRAME = 7, ns6__ReversingResult__INVALID_ERROR_CODE = 8};
#endif

#ifndef SOAP_TYPE_ns6__SchedulingMode
#define SOAP_TYPE_ns6__SchedulingMode (119)
/* ns6:SchedulingMode */
enum ns6__SchedulingMode {ns6__SchedulingMode__SCHEDULING_INTERNAL = 0, ns6__SchedulingMode__SCHEDULING_EXTERNAL = 1};
#endif

#ifndef SOAP_TYPE_ns6__PowerReturnCode
#define SOAP_TYPE_ns6__PowerReturnCode (120)
/* ns6:PowerReturnCode */
enum ns6__PowerReturnCode {ns6__PowerReturnCode__POWER_NO_ERR = 0, ns6__PowerReturnCode__POWER_CHANGE_WHILE_ROBOT_NOT_STOPPED = 1, ns6__PowerReturnCode__POWER_ENABLE_TIMEOUT = 2, ns6__PowerReturnCode__POWER_DISABLE_TIMEOUT = 3, ns6__PowerReturnCode__POWER_CHANGE_ONLY_IN_REMOTE_MODE = 4};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (10)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() : __ptr(NULL), __size(0), id(NULL), type(NULL), options(NULL), soap(NULL) { }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (15)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_xsd__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary() : __ptr(NULL), __size(0) { }
	virtual ~xsd__hexBinary() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ServerException
#define SOAP_TYPE_ns1__ServerException (16)
/* ns1:ServerException */
class SOAP_CMAC ns1__ServerException
{
public:
	enum ns1__ServerExceptionCode code;	/* required element of type ns1:ServerExceptionCode */
	std::string *description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__ServerException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ServerException() : code((enum ns1__ServerExceptionCode)0), description(NULL), soap(NULL) { }
	virtual ~ns1__ServerException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__JointPos
#define SOAP_TYPE_ns1__JointPos (17)
/* ns1:JointPos */
class SOAP_CMAC ns1__JointPos
{
public:
	std::vector<double >item;	/* sequence of 1 to 100 elements */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__JointPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__JointPos() : soap(NULL) { }
	virtual ~ns1__JointPos() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CartesianPos
#define SOAP_TYPE_ns1__CartesianPos (18)
/* ns1:CartesianPos */
class SOAP_CMAC ns1__CartesianPos
{
public:
	double x;	/* required element of type xsd:double */
	double y;	/* required element of type xsd:double */
	double z;	/* required element of type xsd:double */
	double rx;	/* required element of type xsd:double */
	double ry;	/* required element of type xsd:double */
	double rz;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__CartesianPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CartesianPos() : x(0), y(0), z(0), rx(0), ry(0), rz(0), soap(NULL) { }
	virtual ~ns1__CartesianPos() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Robot
#define SOAP_TYPE_ns1__Robot (19)
/* ns1:Robot */
class SOAP_CMAC ns1__Robot
{
public:
	enum ns1__Kinematic kinematic;	/* required element of type ns1:Kinematic */
	std::string *arm;	/* optional element of type xsd:string */
	std::string *tuning;	/* optional element of type xsd:string */
	enum ns1__MountType mountType;	/* required element of type ns1:MountType */
	enum ns1__LengthAxis3 lengthAxis3;	/* required element of type ns1:LengthAxis3 */
	enum ns1__DiameterAxis3 diameterAxis3;	/* required element of type ns1:DiameterAxis3 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__Robot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Robot() : kinematic((enum ns1__Kinematic)0), arm(NULL), tuning(NULL), mountType((enum ns1__MountType)0), lengthAxis3((enum ns1__LengthAxis3)0), diameterAxis3((enum ns1__DiameterAxis3)0), soap(NULL) { }
	virtual ~ns1__Robot() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Version
#define SOAP_TYPE_ns1__Version (20)
/* ns1:Version */
class SOAP_CMAC ns1__Version
{
public:
	std::string *name;	/* optional element of type xsd:string */
	std::string *version;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__Version */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Version() : name(NULL), version(NULL), soap(NULL) { }
	virtual ~ns1__Version() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Versions
#define SOAP_TYPE_ns1__Versions (21)
/* ns1:Versions */
class SOAP_CMAC ns1__Versions
{
public:
	std::vector<ns1__Version * >Versions;	/* optional element of type ns1:Version */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__Versions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Versions() : soap(NULL) { }
	virtual ~ns1__Versions() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SoapServerVersion
#define SOAP_TYPE_ns1__SoapServerVersion (22)
/* ns1:SoapServerVersion */
class SOAP_CMAC ns1__SoapServerVersion
{
public:
	std::string version;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__SoapServerVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SoapServerVersion() : version("1.2"), soap(NULL) { }
	virtual ~ns1__SoapServerVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Robots
#define SOAP_TYPE_ns1__Robots (23)
/* ns1:Robots */
class SOAP_CMAC ns1__Robots
{
public:
	std::vector<ns1__Robot * >Robots;	/* optional element of type ns1:Robot */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__Robots */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Robots() : soap(NULL) { }
	virtual ~ns1__Robots() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Parameter
#define SOAP_TYPE_ns1__Parameter (24)
/* ns1:Parameter */
class SOAP_CMAC ns1__Parameter
{
public:
	std::string *key;	/* optional element of type xsd:string */
	std::string *name;	/* optional element of type xsd:string */
	std::string *value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__Parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Parameter() : key(NULL), name(NULL), value(NULL), soap(NULL) { }
	virtual ~ns1__Parameter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Parameters
#define SOAP_TYPE_ns1__Parameters (25)
/* ns1:Parameters */
class SOAP_CMAC ns1__Parameters
{
public:
	std::vector<ns1__Parameter * >Parameters;	/* optional element of type ns1:Parameter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Parameters() : soap(NULL) { }
	virtual ~ns1__Parameters() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSoapServerVersion
#define SOAP_TYPE__ns1__getSoapServerVersion (26)
/* ns1:getSoapServerVersion */
class SOAP_CMAC _ns1__getSoapServerVersion
{
public:
	std::string *cltName;	/* optional element of type xsd:string */
	std::string *cltVersion;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__ns1__getSoapServerVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSoapServerVersion() : cltName(NULL), cltVersion(NULL), soap(NULL) { }
	virtual ~_ns1__getSoapServerVersion() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getSoapServerVersionResponse
#define SOAP_TYPE__ns1__getSoapServerVersionResponse (27)
/* ns1:getSoapServerVersionResponse */
class SOAP_CMAC _ns1__getSoapServerVersionResponse
{
public:
	ns1__SoapServerVersion *server;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SoapServerVersion */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__ns1__getSoapServerVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getSoapServerVersionResponse() : server(NULL), soap(NULL) { }
	virtual ~_ns1__getSoapServerVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ping
#define SOAP_TYPE__ns1__ping (28)
/* ns1:ping */
class SOAP_CMAC _ns1__ping
{
public:
	std::string *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__ns1__ping */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ping() : message(NULL), soap(NULL) { }
	virtual ~_ns1__ping() { }
};
#endif

#ifndef SOAP_TYPE__ns1__pingResponse
#define SOAP_TYPE__ns1__pingResponse (29)
/* ns1:pingResponse */
class SOAP_CMAC _ns1__pingResponse
{
public:
	std::string *message;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__ns1__pingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__pingResponse() : message(NULL), soap(NULL) { }
	virtual ~_ns1__pingResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getCS8Versions
#define SOAP_TYPE__ns1__getCS8Versions (30)
/* ns1:getCS8Versions */
class SOAP_CMAC _ns1__getCS8Versions
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__ns1__getCS8Versions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getCS8Versions() : soap(NULL) { }
	virtual ~_ns1__getCS8Versions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getCS8VersionsResponse
#define SOAP_TYPE__ns1__getCS8VersionsResponse (31)
/* ns1:getCS8VersionsResponse */
class SOAP_CMAC _ns1__getCS8VersionsResponse
{
public:
	ns1__Versions *out;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Versions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__ns1__getCS8VersionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getCS8VersionsResponse() : out(NULL), soap(NULL) { }
	virtual ~_ns1__getCS8VersionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__login
#define SOAP_TYPE__ns1__login (32)
/* ns1:login */
class SOAP_CMAC _ns1__login
{
public:
	std::string *user;	/* optional element of type xsd:string */
	std::string *pwd;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__ns1__login */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__login() : user(NULL), pwd(NULL), soap(NULL) { }
	virtual ~_ns1__login() { }
};
#endif

#ifndef SOAP_TYPE__ns1__loginResponse
#define SOAP_TYPE__ns1__loginResponse (33)
/* ns1:loginResponse */
class SOAP_CMAC _ns1__loginResponse
{
public:
	int sid;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:SessionId */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__ns1__loginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__loginResponse() : sid(0), soap(NULL) { }
	virtual ~_ns1__loginResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__logout
#define SOAP_TYPE__ns1__logout (34)
/* ns1:logout */
class SOAP_CMAC _ns1__logout
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__ns1__logout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__logout() : soap(NULL) { }
	virtual ~_ns1__logout() { }
};
#endif

#ifndef SOAP_TYPE__ns1__logoutResponse
#define SOAP_TYPE__ns1__logoutResponse (35)
/* ns1:logoutResponse */
class SOAP_CMAC _ns1__logoutResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__ns1__logoutResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__logoutResponse() : soap(NULL) { }
	virtual ~_ns1__logoutResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getRobots
#define SOAP_TYPE__ns1__getRobots (36)
/* ns1:getRobots */
class SOAP_CMAC _ns1__getRobots
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE__ns1__getRobots */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getRobots() : soap(NULL) { }
	virtual ~_ns1__getRobots() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getRobotsResponse
#define SOAP_TYPE__ns1__getRobotsResponse (37)
/* ns1:getRobotsResponse */
class SOAP_CMAC _ns1__getRobotsResponse
{
public:
	ns1__Robots *out;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Robots */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE__ns1__getRobotsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getRobotsResponse() : out(NULL), soap(NULL) { }
	virtual ~_ns1__getRobotsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getRobotJointPos
#define SOAP_TYPE__ns1__getRobotJointPos (38)
/* ns1:getRobotJointPos */
class SOAP_CMAC _ns1__getRobotJointPos
{
public:
	int robot;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE__ns1__getRobotJointPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getRobotJointPos() : robot(0), soap(NULL) { }
	virtual ~_ns1__getRobotJointPos() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getRobotJointPosResponse
#define SOAP_TYPE__ns1__getRobotJointPosResponse (39)
/* ns1:getRobotJointPosResponse */
class SOAP_CMAC _ns1__getRobotJointPosResponse
{
public:
	ns1__JointPos *pos;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:JointPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__ns1__getRobotJointPosResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getRobotJointPosResponse() : pos(NULL), soap(NULL) { }
	virtual ~_ns1__getRobotJointPosResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getRobotJntCartPos
#define SOAP_TYPE__ns1__getRobotJntCartPos (40)
/* ns1:getRobotJntCartPos */
class SOAP_CMAC _ns1__getRobotJntCartPos
{
public:
	int robot;	/* required element of type xsd:int */
	ns1__CartesianPos *tool;	/* required element of type ns1:CartesianPos */
	ns1__CartesianPos *frame;	/* required element of type ns1:CartesianPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__ns1__getRobotJntCartPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getRobotJntCartPos() : robot(0), tool(NULL), frame(NULL), soap(NULL) { }
	virtual ~_ns1__getRobotJntCartPos() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getRobotJntCartPosResponse
#define SOAP_TYPE__ns1__getRobotJntCartPosResponse (41)
/* ns1:getRobotJntCartPosResponse */
class SOAP_CMAC _ns1__getRobotJntCartPosResponse
{
public:
	ns1__JointPos *jntPos;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:JointPos */
	ns1__CartesianPos *cartPos;	/* required element of type ns1:CartesianPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__ns1__getRobotJntCartPosResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getRobotJntCartPosResponse() : jntPos(NULL), cartPos(NULL), soap(NULL) { }
	virtual ~_ns1__getRobotJntCartPosResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setRobotJointPos
#define SOAP_TYPE__ns1__setRobotJointPos (42)
/* ns1:setRobotJointPos */
class SOAP_CMAC _ns1__setRobotJointPos
{
public:
	int robot;	/* required element of type xsd:int */
	ns1__JointPos *pos;	/* required element of type ns1:JointPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__ns1__setRobotJointPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setRobotJointPos() : robot(0), pos(NULL), soap(NULL) { }
	virtual ~_ns1__setRobotJointPos() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setRobotPosResponse
#define SOAP_TYPE__ns1__setRobotPosResponse (43)
/* ns1:setRobotPosResponse */
class SOAP_CMAC _ns1__setRobotPosResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__ns1__setRobotPosResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setRobotPosResponse() : soap(NULL) { }
	virtual ~_ns1__setRobotPosResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__findServer
#define SOAP_TYPE__ns1__findServer (44)
/* ns1:findServer */
class SOAP_CMAC _ns1__findServer
{
public:
	std::string *serverName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__ns1__findServer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__findServer() : serverName(NULL), soap(NULL) { }
	virtual ~_ns1__findServer() { }
};
#endif

#ifndef SOAP_TYPE__ns1__findServerResponse
#define SOAP_TYPE__ns1__findServerResponse (45)
/* ns1:findServerResponse */
class SOAP_CMAC _ns1__findServerResponse
{
public:
	bool found;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__ns1__findServerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__findServerResponse() : found((bool)0), soap(NULL) { }
	virtual ~_ns1__findServerResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getControllerParameters
#define SOAP_TYPE__ns1__getControllerParameters (46)
/* ns1:getControllerParameters */
class SOAP_CMAC _ns1__getControllerParameters
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__ns1__getControllerParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getControllerParameters() : soap(NULL) { }
	virtual ~_ns1__getControllerParameters() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getControllerParametersResponse
#define SOAP_TYPE__ns1__getControllerParametersResponse (47)
/* ns1:getControllerParametersResponse */
class SOAP_CMAC _ns1__getControllerParametersResponse
{
public:
	ns1__Parameters *out;	/* required element of type ns1:Parameters */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__ns1__getControllerParametersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getControllerParametersResponse() : out(NULL), soap(NULL) { }
	virtual ~_ns1__getControllerParametersResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getCS8Compatibility
#define SOAP_TYPE__ns1__getCS8Compatibility (48)
/* ns1:getCS8Compatibility */
class SOAP_CMAC _ns1__getCS8Compatibility
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__ns1__getCS8Compatibility */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getCS8Compatibility() : soap(NULL) { }
	virtual ~_ns1__getCS8Compatibility() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getCS8CompatibilityResponse
#define SOAP_TYPE__ns1__getCS8CompatibilityResponse (49)
/* ns1:getCS8CompatibilityResponse */
class SOAP_CMAC _ns1__getCS8CompatibilityResponse
{
public:
	std::string *compatibility;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__ns1__getCS8CompatibilityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getCS8CompatibilityResponse() : compatibility(NULL), soap(NULL) { }
	virtual ~_ns1__getCS8CompatibilityResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VALApplication
#define SOAP_TYPE_ns2__VALApplication (50)
/* ns2:VALApplication */
class SOAP_CMAC ns2__VALApplication
{
public:
	std::string *name;	/* optional element of type xsd:string */
	bool loaded;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns2__VALApplication */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VALApplication() : name(NULL), loaded((bool)0), soap(NULL) { }
	virtual ~ns2__VALApplication() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VALApplications
#define SOAP_TYPE_ns2__VALApplications (51)
/* ns2:VALApplications */
class SOAP_CMAC ns2__VALApplications
{
public:
	std::vector<ns2__VALApplication * >application;	/* optional element of type ns2:VALApplication */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns2__VALApplications */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VALApplications() : soap(NULL) { }
	virtual ~ns2__VALApplications() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Data
#define SOAP_TYPE_ns2__Data (52)
/* ns2:Data */
class SOAP_CMAC ns2__Data
{
public:
	class ns3__Include *ns3__Include_;	/* required element of type ns3:Include */
	std::string *ns4__contentType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns2__Data */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Data() : ns3__Include_(NULL), ns4__contentType(NULL), soap(NULL) { }
	virtual ~ns2__Data() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Records
#define SOAP_TYPE_ns2__Records (53)
/* ns2:Records */
class SOAP_CMAC ns2__Records
{
public:
	std::vector<std::string >record;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns2__Records */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Records() : soap(NULL) { }
	virtual ~ns2__Records() { }
};
#endif

#ifndef SOAP_TYPE_ns2__JointRange
#define SOAP_TYPE_ns2__JointRange (54)
/* ns2:JointRange */
class SOAP_CMAC ns2__JointRange
{
public:
	std::vector<double >min_;	/* optional element of type xsd:double */
	std::vector<double >max_;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns2__JointRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__JointRange() : soap(NULL) { }
	virtual ~ns2__JointRange() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getApplications
#define SOAP_TYPE__ns2__getApplications (55)
/* ns2:getApplications */
class SOAP_CMAC _ns2__getApplications
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns2__getApplications */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getApplications() : soap(NULL) { }
	virtual ~_ns2__getApplications() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getApplicationsResponse
#define SOAP_TYPE__ns2__getApplicationsResponse (56)
/* ns2:getApplicationsResponse */
class SOAP_CMAC _ns2__getApplicationsResponse
{
public:
	ns2__VALApplications *applications;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:VALApplications */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns2__getApplicationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getApplicationsResponse() : applications(NULL), soap(NULL) { }
	virtual ~_ns2__getApplicationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getApplicationDatas
#define SOAP_TYPE__ns2__getApplicationDatas (57)
/* ns2:getApplicationDatas */
class SOAP_CMAC _ns2__getApplicationDatas
{
public:
	std::string *name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns2__getApplicationDatas */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getApplicationDatas() : name(NULL), soap(NULL) { }
	virtual ~_ns2__getApplicationDatas() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getApplicationDatasResponse
#define SOAP_TYPE__ns2__getApplicationDatasResponse (58)
/* ns2:getApplicationDatasResponse */
class SOAP_CMAC _ns2__getApplicationDatasResponse
{
public:
	xsd__base64Binary data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns2__getApplicationDatasResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getApplicationDatasResponse() : soap(NULL) { }
	virtual ~_ns2__getApplicationDatasResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getRecords
#define SOAP_TYPE__ns2__getRecords (59)
/* ns2:getRecords */
class SOAP_CMAC _ns2__getRecords
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__ns2__getRecords */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getRecords() : soap(NULL) { }
	virtual ~_ns2__getRecords() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getRecordsResponse
#define SOAP_TYPE__ns2__getRecordsResponse (60)
/* ns2:getRecordsResponse */
class SOAP_CMAC _ns2__getRecordsResponse
{
public:
	ns2__Records *records;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:Records */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__ns2__getRecordsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getRecordsResponse() : records(NULL), soap(NULL) { }
	virtual ~_ns2__getRecordsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getRecord
#define SOAP_TYPE__ns2__getRecord (61)
/* ns2:getRecord */
class SOAP_CMAC _ns2__getRecord
{
public:
	std::string *name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__ns2__getRecord */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getRecord() : name(NULL), soap(NULL) { }
	virtual ~_ns2__getRecord() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getRecordResponse
#define SOAP_TYPE__ns2__getRecordResponse (62)
/* ns2:getRecordResponse */
class SOAP_CMAC _ns2__getRecordResponse
{
public:
	xsd__base64Binary data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__ns2__getRecordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getRecordResponse() : soap(NULL) { }
	virtual ~_ns2__getRecordResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getJointRange
#define SOAP_TYPE__ns2__getJointRange (63)
/* ns2:getJointRange */
class SOAP_CMAC _ns2__getJointRange
{
public:
	int robot;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__ns2__getJointRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getJointRange() : robot(0), soap(NULL) { }
	virtual ~_ns2__getJointRange() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getJointRangeResponse
#define SOAP_TYPE__ns2__getJointRangeResponse (64)
/* ns2:getJointRangeResponse */
class SOAP_CMAC _ns2__getJointRangeResponse
{
public:
	ns2__JointRange *range;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:JointRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__ns2__getJointRangeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getJointRangeResponse() : range(NULL), soap(NULL) { }
	virtual ~_ns2__getJointRangeResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Include
#define SOAP_TYPE_ns3__Include (65)
/* ns3:Include */
class SOAP_CMAC ns3__Include
{
public:
	std::vector<char * >__any;
	std::string href;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns3__Include */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Include() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~ns3__Include() { }
};
#endif

#ifndef SOAP_TYPE_ns5__JointPos
#define SOAP_TYPE_ns5__JointPos (68)
/* ns5:JointPos */
class SOAP_CMAC ns5__JointPos
{
public:
	std::vector<double >item;	/* sequence of 1 to 100 elements */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns5__JointPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__JointPos() : soap(NULL) { }
	virtual ~ns5__JointPos() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Versions
#define SOAP_TYPE_ns5__Versions (69)
/* ns5:Versions */
class SOAP_CMAC ns5__Versions
{
public:
	std::vector<ns1__Version * >Versions;	/* optional element of type ns1:Version */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns5__Versions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Versions() : soap(NULL) { }
	virtual ~ns5__Versions() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Robots
#define SOAP_TYPE_ns5__Robots (70)
/* ns5:Robots */
class SOAP_CMAC ns5__Robots
{
public:
	std::vector<ns1__Robot * >Robots;	/* optional element of type ns1:Robot */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns5__Robots */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Robots() : soap(NULL) { }
	virtual ~ns5__Robots() { }
};
#endif

#ifndef SOAP_TYPE_ns5__VALApplications
#define SOAP_TYPE_ns5__VALApplications (71)
/* ns5:VALApplications */
class SOAP_CMAC ns5__VALApplications
{
public:
	std::vector<ns2__VALApplication * >application;	/* optional element of type ns2:VALApplication */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns5__VALApplications */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__VALApplications() : soap(NULL) { }
	virtual ~ns5__VALApplications() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Records
#define SOAP_TYPE_ns5__Records (72)
/* ns5:Records */
class SOAP_CMAC ns5__Records
{
public:
	std::vector<std::string >record;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns5__Records */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Records() : soap(NULL) { }
	virtual ~ns5__Records() { }
};
#endif

#ifndef SOAP_TYPE_ns5__AllRobotsPos
#define SOAP_TYPE_ns5__AllRobotsPos (73)
/* ns5:AllRobotsPos */
class SOAP_CMAC ns5__AllRobotsPos
{
public:
	std::vector<class ns6__RobotPos * >RobotsPos;	/* optional element of type ns6:RobotPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns5__AllRobotsPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__AllRobotsPos() : soap(NULL) { }
	virtual ~ns5__AllRobotsPos() { }
};
#endif

#ifndef SOAP_TYPE_ns6__JointPos
#define SOAP_TYPE_ns6__JointPos (74)
/* ns6:JointPos */
class SOAP_CMAC ns6__JointPos
{
public:
	std::vector<double >item;	/* sequence of 1 to 100 elements */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns6__JointPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__JointPos() : soap(NULL) { }
	virtual ~ns6__JointPos() { }
};
#endif

#ifndef SOAP_TYPE_ns6__Versions
#define SOAP_TYPE_ns6__Versions (75)
/* ns6:Versions */
class SOAP_CMAC ns6__Versions
{
public:
	std::vector<ns1__Version * >Versions;	/* optional element of type ns1:Version */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ns6__Versions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Versions() : soap(NULL) { }
	virtual ~ns6__Versions() { }
};
#endif

#ifndef SOAP_TYPE_ns6__Robots
#define SOAP_TYPE_ns6__Robots (76)
/* ns6:Robots */
class SOAP_CMAC ns6__Robots
{
public:
	std::vector<ns1__Robot * >Robots;	/* optional element of type ns1:Robot */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns6__Robots */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Robots() : soap(NULL) { }
	virtual ~ns6__Robots() { }
};
#endif

#ifndef SOAP_TYPE_ns6__VALApplications
#define SOAP_TYPE_ns6__VALApplications (77)
/* ns6:VALApplications */
class SOAP_CMAC ns6__VALApplications
{
public:
	std::vector<ns2__VALApplication * >application;	/* optional element of type ns2:VALApplication */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns6__VALApplications */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__VALApplications() : soap(NULL) { }
	virtual ~ns6__VALApplications() { }
};
#endif

#ifndef SOAP_TYPE_ns6__Records
#define SOAP_TYPE_ns6__Records (78)
/* ns6:Records */
class SOAP_CMAC ns6__Records
{
public:
	std::vector<std::string >record;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns6__Records */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Records() : soap(NULL) { }
	virtual ~ns6__Records() { }
};
#endif

#ifndef SOAP_TYPE_ns6__Frame
#define SOAP_TYPE_ns6__Frame (79)
/* ns6:Frame */
class SOAP_CMAC ns6__Frame
{
public:
	double nx;	/* required element of type xsd:double */
	double ny;	/* required element of type xsd:double */
	double nz;	/* required element of type xsd:double */
	double ox;	/* required element of type xsd:double */
	double oy;	/* required element of type xsd:double */
	double oz;	/* required element of type xsd:double */
	double ax;	/* required element of type xsd:double */
	double ay;	/* required element of type xsd:double */
	double az;	/* required element of type xsd:double */
	double px;	/* required element of type xsd:double */
	double py;	/* required element of type xsd:double */
	double pz;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns6__Frame */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Frame() : nx(1), ny(0), nz(0), ox(0), oy(1), oz(0), ax(0), ay(0), az(1), px(0), py(0), pz(0), soap(NULL) { }
	virtual ~ns6__Frame() { }
};
#endif

#ifndef SOAP_TYPE_ns6__AnthroConfig
#define SOAP_TYPE_ns6__AnthroConfig (80)
/* ns6:AnthroConfig */
class SOAP_CMAC ns6__AnthroConfig
{
public:
	enum ns6__ShoulderConfig shoulder;	/* required element of type ns6:ShoulderConfig */
	enum ns6__PositiveNegativeConfig elbow;	/* required element of type ns6:PositiveNegativeConfig */
	enum ns6__PositiveNegativeConfig wrist;	/* required element of type ns6:PositiveNegativeConfig */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns6__AnthroConfig */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__AnthroConfig() : shoulder((enum ns6__ShoulderConfig)3), elbow((enum ns6__PositiveNegativeConfig)3), wrist((enum ns6__PositiveNegativeConfig)3), soap(NULL) { }
	virtual ~ns6__AnthroConfig() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ScaraConfig
#define SOAP_TYPE_ns6__ScaraConfig (81)
/* ns6:ScaraConfig */
class SOAP_CMAC ns6__ScaraConfig
{
public:
	enum ns6__ShoulderConfig shoulder;	/* required element of type ns6:ShoulderConfig */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns6__ScaraConfig */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ScaraConfig() : shoulder((enum ns6__ShoulderConfig)0), soap(NULL) { }
	virtual ~ns6__ScaraConfig() { }
};
#endif

#ifndef SOAP_TYPE_ns6__VrbxConfig
#define SOAP_TYPE_ns6__VrbxConfig (82)
/* ns6:VrbxConfig */
class SOAP_CMAC ns6__VrbxConfig
{
public:
	enum ns6__AboveBelowConfig jnt1;	/* required element of type ns6:AboveBelowConfig */
	enum ns6__PositiveNegativeConfig jnt3;	/* required element of type ns6:PositiveNegativeConfig */
	enum ns6__PositiveNegativeConfig jnt5;	/* required element of type ns6:PositiveNegativeConfig */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ns6__VrbxConfig */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__VrbxConfig() : jnt1((enum ns6__AboveBelowConfig)0), jnt3((enum ns6__PositiveNegativeConfig)0), jnt5((enum ns6__PositiveNegativeConfig)0), soap(NULL) { }
	virtual ~ns6__VrbxConfig() { }
};
#endif

#ifndef SOAP_TYPE__ns6__union_Config
#define SOAP_TYPE__ns6__union_Config (150)
/* xsd:choice */
union _ns6__union_Config
{
#define SOAP_UNION__ns6__union_Config_anthroConfig	(1)
	ns6__AnthroConfig *anthroConfig;
#define SOAP_UNION__ns6__union_Config_scaraConfig	(2)
	ns6__ScaraConfig *scaraConfig;
#define SOAP_UNION__ns6__union_Config_vrbxConfig	(3)
	ns6__VrbxConfig *vrbxConfig;
};
#endif

#ifndef SOAP_TYPE_ns6__Config
#define SOAP_TYPE_ns6__Config (83)
/* ns6:Config */
class SOAP_CMAC ns6__Config
{
public:
	int __union_Config;	/* union discriminant (of union defined below) */
	union _ns6__union_Config union_Config;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns6__Config */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Config() : __union_Config(0), soap(NULL) { }
	virtual ~ns6__Config() { }
};
#endif

#ifndef SOAP_TYPE_ns6__MotionDesc
#define SOAP_TYPE_ns6__MotionDesc (84)
/* ns6:MotionDesc */
class SOAP_CMAC ns6__MotionDesc
{
public:
	ns6__Frame *tool;	/* required element of type ns6:Frame */
	ns6__Frame *frame;	/* required element of type ns6:Frame */
	enum ns6__MoveType absRel;	/* required element of type ns6:MoveType */
	ns6__Config *config;	/* required element of type ns6:Config */
	enum ns6__BlendType blendType;	/* required element of type ns6:BlendType */
	double distBlendPrev;	/* required element of type xsd:double */
	double distBlendNext;	/* required element of type xsd:double */
	double vel;	/* required element of type xsd:double */
	double acc;	/* required element of type xsd:double */
	double dec;	/* required element of type xsd:double */
	double transVel;	/* required element of type xsd:double */
	double rotVel;	/* required element of type xsd:double */
	double freq;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ns6__MotionDesc */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__MotionDesc() : tool(NULL), frame(NULL), absRel((enum ns6__MoveType)0),
				 config(NULL), blendType((enum ns6__BlendType)0), distBlendPrev(0.05),
				 distBlendNext(0.05), vel(1.0), acc(1.0), dec(1.0), transVel(99999), rotVel(99999), freq(1.0), soap(NULL) { }
	virtual ~ns6__MotionDesc() { }
};
#endif

#ifndef SOAP_TYPE_ns6__RobotPos
#define SOAP_TYPE_ns6__RobotPos (85)
/* ns6:RobotPos */
class SOAP_CMAC ns6__RobotPos
{
public:
	bool settled;	/* required element of type xsd:boolean */
	ns1__JointPos *joint;	/* required element of type ns1:JointPos */
	ns6__Frame *position;	/* required element of type ns6:Frame */
	ns6__Config *config;	/* required element of type ns6:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns6__RobotPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__RobotPos() : settled((bool)0), joint(NULL), position(NULL), config(NULL), soap(NULL) { }
	virtual ~ns6__RobotPos() { }
};
#endif

#ifndef SOAP_TYPE_ns6__AllRobotsPos
#define SOAP_TYPE_ns6__AllRobotsPos (86)
/* ns6:AllRobotsPos */
class SOAP_CMAC ns6__AllRobotsPos
{
public:
	std::vector<ns6__RobotPos * >RobotsPos;	/* optional element of type ns6:RobotPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ns6__AllRobotsPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__AllRobotsPos() : soap(NULL) { }
	virtual ~ns6__AllRobotsPos() { }
};
#endif

#ifndef SOAP_TYPE__ns6__forwardKin
#define SOAP_TYPE__ns6__forwardKin (87)
/* ns6:forwardKin */
class SOAP_CMAC _ns6__forwardKin
{
public:
	int robot;	/* required element of type xsd:int */
	ns1__JointPos *joint;	/* required element of type ns1:JointPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE__ns6__forwardKin */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__forwardKin() : robot(0), joint(NULL), soap(NULL) { }
	virtual ~_ns6__forwardKin() { }
};
#endif

#ifndef SOAP_TYPE__ns6__forwardKinResponse
#define SOAP_TYPE__ns6__forwardKinResponse (88)
/* ns6:forwardKinResponse */
class SOAP_CMAC _ns6__forwardKinResponse
{
public:
	ns6__Frame *position;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns6:Frame */
	ns6__Config *config;	/* required element of type ns6:Config */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE__ns6__forwardKinResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__forwardKinResponse() : position(NULL), config(NULL), soap(NULL) { }
	virtual ~_ns6__forwardKinResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__reverseKin
#define SOAP_TYPE__ns6__reverseKin (89)
/* ns6:reverseKin */
class SOAP_CMAC _ns6__reverseKin
{
public:
	int robot;	/* required element of type xsd:int */
	ns1__JointPos *jointIn;	/* required element of type ns1:JointPos */
	ns6__Frame *target;	/* required element of type ns6:Frame */
	ns6__Config *config;	/* required element of type ns6:Config */
	ns2__JointRange *jointRange;	/* required element of type ns2:JointRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE__ns6__reverseKin */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__reverseKin() : robot(0), jointIn(NULL), target(NULL), config(NULL), jointRange(NULL), soap(NULL) { }
	virtual ~_ns6__reverseKin() { }
};
#endif

#ifndef SOAP_TYPE__ns6__reverseKinResponse
#define SOAP_TYPE__ns6__reverseKinResponse (90)
/* ns6:reverseKinResponse */
class SOAP_CMAC _ns6__reverseKinResponse
{
public:
	ns1__JointPos *jointOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:JointPos */
	enum ns6__ReversingResult reversingResult;	/* required element of type ns6:ReversingResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE__ns6__reverseKinResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__reverseKinResponse() : jointOut(NULL), reversingResult((enum ns6__ReversingResult)0), soap(NULL) { }
	virtual ~_ns6__reverseKinResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__moveJJ
#define SOAP_TYPE__ns6__moveJJ (91)
/* ns6:moveJJ */
class SOAP_CMAC _ns6__moveJJ
{
public:
	int robot;	/* required element of type xsd:int */
	ns1__JointPos *joint;	/* required element of type ns1:JointPos */
	ns6__MotionDesc *mdesc;	/* required element of type ns6:MotionDesc */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE__ns6__moveJJ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__moveJJ() : robot(0), joint(NULL), mdesc(NULL), soap(NULL) { }
	virtual ~_ns6__moveJJ() { }
};
#endif

#ifndef SOAP_TYPE__ns6__moveResponse
#define SOAP_TYPE__ns6__moveResponse (92)
/* ns6:moveResponse */
class SOAP_CMAC _ns6__moveResponse
{
public:
	int id;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	enum ns6__MotionReturnCode motRet;	/* required element of type ns6:MotionReturnCode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE__ns6__moveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__moveResponse() : id(0), motRet((enum ns6__MotionReturnCode)0), soap(NULL) { }
	virtual ~_ns6__moveResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__moveJC
#define SOAP_TYPE__ns6__moveJC (93)
/* ns6:moveJC */
class SOAP_CMAC _ns6__moveJC
{
public:
	int robot;	/* required element of type xsd:int */
	ns6__Frame *frame;	/* required element of type ns6:Frame */
	ns6__MotionDesc *mdesc;	/* required element of type ns6:MotionDesc */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE__ns6__moveJC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__moveJC() : robot(0), frame(NULL), mdesc(NULL), soap(NULL) { }
	virtual ~_ns6__moveJC() { }
};
#endif

#ifndef SOAP_TYPE__ns6__moveL
#define SOAP_TYPE__ns6__moveL (94)
/* ns6:moveL */
class SOAP_CMAC _ns6__moveL
{
public:
	int robot;	/* required element of type xsd:int */
	ns6__Frame *frame;	/* required element of type ns6:Frame */
	ns6__MotionDesc *mdesc;	/* required element of type ns6:MotionDesc */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE__ns6__moveL */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__moveL() : robot(0), frame(NULL), mdesc(NULL), soap(NULL) { }
	virtual ~_ns6__moveL() { }
};
#endif

#ifndef SOAP_TYPE__ns6__moveC
#define SOAP_TYPE__ns6__moveC (95)
/* ns6:moveC */
class SOAP_CMAC _ns6__moveC
{
public:
	int robot;	/* required element of type xsd:int */
	ns6__Frame *frameB;	/* required element of type ns6:Frame */
	ns6__Frame *frameC;	/* required element of type ns6:Frame */
	ns6__MotionDesc *mdesc;	/* required element of type ns6:MotionDesc */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE__ns6__moveC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__moveC() : robot(0), frameB(NULL), frameC(NULL), mdesc(NULL), soap(NULL) { }
	virtual ~_ns6__moveC() { }
};
#endif

#ifndef SOAP_TYPE__ns6__resetMotion
#define SOAP_TYPE__ns6__resetMotion (96)
/* ns6:resetMotion */
class SOAP_CMAC _ns6__resetMotion
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE__ns6__resetMotion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__resetMotion() : soap(NULL) { }
	virtual ~_ns6__resetMotion() { }
};
#endif

#ifndef SOAP_TYPE__ns6__motionResponse
#define SOAP_TYPE__ns6__motionResponse (97)
/* ns6:motionResponse */
class SOAP_CMAC _ns6__motionResponse
{
public:
	enum ns6__MotionReturnCode motRet;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns6:MotionReturnCode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE__ns6__motionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__motionResponse() : motRet((enum ns6__MotionReturnCode)0), soap(NULL) { }
	virtual ~_ns6__motionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__stopMotion
#define SOAP_TYPE__ns6__stopMotion (98)
/* ns6:stopMotion */
class SOAP_CMAC _ns6__stopMotion
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE__ns6__stopMotion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__stopMotion() : soap(NULL) { }
	virtual ~_ns6__stopMotion() { }
};
#endif

#ifndef SOAP_TYPE__ns6__restartMotion
#define SOAP_TYPE__ns6__restartMotion (99)
/* ns6:restartMotion */
class SOAP_CMAC _ns6__restartMotion
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE__ns6__restartMotion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__restartMotion() : soap(NULL) { }
	virtual ~_ns6__restartMotion() { }
};
#endif

#ifndef SOAP_TYPE__ns6__setSchedulingMode
#define SOAP_TYPE__ns6__setSchedulingMode (100)
/* ns6:setSchedulingMode */
class SOAP_CMAC _ns6__setSchedulingMode
{
public:
	enum ns6__SchedulingMode schedulingMode;	/* required element of type ns6:SchedulingMode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE__ns6__setSchedulingMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__setSchedulingMode() : schedulingMode((enum ns6__SchedulingMode)0), soap(NULL) { }
	virtual ~_ns6__setSchedulingMode() { }
};
#endif

#ifndef SOAP_TYPE__ns6__setSchedulingModeResponse
#define SOAP_TYPE__ns6__setSchedulingModeResponse (101)
/* ns6:setSchedulingModeResponse */
class SOAP_CMAC _ns6__setSchedulingModeResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE__ns6__setSchedulingModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__setSchedulingModeResponse() : soap(NULL) { }
	virtual ~_ns6__setSchedulingModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns6__schedulerRefresh
#define SOAP_TYPE__ns6__schedulerRefresh (102)
/* ns6:schedulerRefresh */
class SOAP_CMAC _ns6__schedulerRefresh
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE__ns6__schedulerRefresh */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__schedulerRefresh() : soap(NULL) { }
	virtual ~_ns6__schedulerRefresh() { }
};
#endif

#ifndef SOAP_TYPE__ns6__MotionAndRobotsPos
#define SOAP_TYPE__ns6__MotionAndRobotsPos (103)
/* ns6:MotionAndRobotsPos */
class SOAP_CMAC _ns6__MotionAndRobotsPos
{
public:
	enum ns6__SchedulingMode schedulingMode;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns6:SchedulingMode */
	bool motionEmpty;	/* required element of type xsd:boolean */
	ns6__AllRobotsPos *allRobotsPos;	/* required element of type ns6:AllRobotsPos */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE__ns6__MotionAndRobotsPos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__MotionAndRobotsPos() : schedulingMode((enum ns6__SchedulingMode)0), motionEmpty((bool)0), allRobotsPos(NULL), soap(NULL) { }
	virtual ~_ns6__MotionAndRobotsPos() { }
};
#endif

#ifndef SOAP_TYPE__ns6__setPower
#define SOAP_TYPE__ns6__setPower (104)
/* ns6:setPower */
class SOAP_CMAC _ns6__setPower
{
public:
	bool power;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE__ns6__setPower */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__setPower() : power((bool)1), soap(NULL) { }
	virtual ~_ns6__setPower() { }
};
#endif

#ifndef SOAP_TYPE__ns6__setPowerResponse
#define SOAP_TYPE__ns6__setPowerResponse (105)
/* ns6:setPowerResponse */
class SOAP_CMAC _ns6__setPowerResponse
{
public:
	enum ns6__PowerReturnCode code;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns6:PowerReturnCode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE__ns6__setPowerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__setPowerResponse() : code((enum ns6__PowerReturnCode)0), soap(NULL) { }
	virtual ~_ns6__setPowerResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns4__base64Binary
#define SOAP_TYPE_ns4__base64Binary (66)
/* Primitive ns4:base64Binary schema type: */
class SOAP_CMAC ns4__base64Binary
{
public:
	xsd__base64Binary __item;
	std::string *ns4__contentType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns4__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__base64Binary() : ns4__contentType(NULL), soap(NULL) { }
	virtual ~ns4__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_ns4__hexBinary
#define SOAP_TYPE_ns4__hexBinary (67)
/* Primitive ns4:hexBinary schema type: */
class SOAP_CMAC ns4__hexBinary
{
public:
	xsd__hexBinary __item;
	std::string *ns4__contentType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns4__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__hexBinary() : ns4__contentType(NULL), soap(NULL) { }
	virtual ~ns4__hexBinary() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (155)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int *ns1__sessionId;	/* mustUnderstand */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (157)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns1__ServerException *ns1__ServerException_;	/* optional element of type ns1:ServerException */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns1__getSoapServerVersion
#define SOAP_TYPE___ns1__getSoapServerVersion (164)
/* Operation wrapper: */
struct __ns1__getSoapServerVersion
{
public:
	_ns1__getSoapServerVersion *ns1__getSoapServerVersion;	/* optional element of type ns1:getSoapServerVersion */
};
#endif

#ifndef SOAP_TYPE___ns1__ping
#define SOAP_TYPE___ns1__ping (168)
/* Operation wrapper: */
struct __ns1__ping
{
public:
	_ns1__ping *ns1__ping;	/* optional element of type ns1:ping */
};
#endif

#ifndef SOAP_TYPE___ns1__getCS8Versions
#define SOAP_TYPE___ns1__getCS8Versions (172)
/* Operation wrapper: */
struct __ns1__getCS8Versions
{
public:
	_ns1__getCS8Versions *ns1__getCS8Versions;	/* optional element of type ns1:getCS8Versions */
};
#endif

#ifndef SOAP_TYPE___ns1__login
#define SOAP_TYPE___ns1__login (176)
/* Operation wrapper: */
struct __ns1__login
{
public:
	_ns1__login *ns1__login;	/* optional element of type ns1:login */
};
#endif

#ifndef SOAP_TYPE___ns1__logout
#define SOAP_TYPE___ns1__logout (180)
/* Operation wrapper: */
struct __ns1__logout
{
public:
	_ns1__logout *ns1__logout;	/* optional element of type ns1:logout */
};
#endif

#ifndef SOAP_TYPE___ns1__getRobots
#define SOAP_TYPE___ns1__getRobots (184)
/* Operation wrapper: */
struct __ns1__getRobots
{
public:
	_ns1__getRobots *ns1__getRobots;	/* optional element of type ns1:getRobots */
};
#endif

#ifndef SOAP_TYPE___ns1__getRobotJointPos
#define SOAP_TYPE___ns1__getRobotJointPos (188)
/* Operation wrapper: */
struct __ns1__getRobotJointPos
{
public:
	_ns1__getRobotJointPos *ns1__getRobotJointPos;	/* optional element of type ns1:getRobotJointPos */
};
#endif

#ifndef SOAP_TYPE___ns1__getRobotJntCartPos
#define SOAP_TYPE___ns1__getRobotJntCartPos (192)
/* Operation wrapper: */
struct __ns1__getRobotJntCartPos
{
public:
	_ns1__getRobotJntCartPos *ns1__getRobotJntCartPos;	/* optional element of type ns1:getRobotJntCartPos */
};
#endif

#ifndef SOAP_TYPE___ns1__setRobotJointPos
#define SOAP_TYPE___ns1__setRobotJointPos (196)
/* Operation wrapper: */
struct __ns1__setRobotJointPos
{
public:
	_ns1__setRobotJointPos *ns1__setRobotJointPos;	/* optional element of type ns1:setRobotJointPos */
};
#endif

#ifndef SOAP_TYPE___ns2__getApplications
#define SOAP_TYPE___ns2__getApplications (200)
/* Operation wrapper: */
struct __ns2__getApplications
{
public:
	_ns2__getApplications *ns2__getApplications;	/* optional element of type ns2:getApplications */
};
#endif

#ifndef SOAP_TYPE___ns2__getApplicationDatas
#define SOAP_TYPE___ns2__getApplicationDatas (204)
/* Operation wrapper: */
struct __ns2__getApplicationDatas
{
public:
	_ns2__getApplicationDatas *ns2__getApplicationDatas;	/* optional element of type ns2:getApplicationDatas */
};
#endif

#ifndef SOAP_TYPE___ns2__getRecords
#define SOAP_TYPE___ns2__getRecords (208)
/* Operation wrapper: */
struct __ns2__getRecords
{
public:
	_ns2__getRecords *ns2__getRecords;	/* optional element of type ns2:getRecords */
};
#endif

#ifndef SOAP_TYPE___ns2__getRecord
#define SOAP_TYPE___ns2__getRecord (212)
/* Operation wrapper: */
struct __ns2__getRecord
{
public:
	_ns2__getRecord *ns2__getRecord;	/* optional element of type ns2:getRecord */
};
#endif

#ifndef SOAP_TYPE___ns2__getJointRange
#define SOAP_TYPE___ns2__getJointRange (216)
/* Operation wrapper: */
struct __ns2__getJointRange
{
public:
	_ns2__getJointRange *ns2__getJointRange;	/* optional element of type ns2:getJointRange */
};
#endif

#ifndef SOAP_TYPE___ns6__forwardKin
#define SOAP_TYPE___ns6__forwardKin (220)
/* Operation wrapper: */
struct __ns6__forwardKin
{
public:
	_ns6__forwardKin *ns6__forwardKin;	/* optional element of type ns6:forwardKin */
};
#endif

#ifndef SOAP_TYPE___ns6__reverseKin
#define SOAP_TYPE___ns6__reverseKin (224)
/* Operation wrapper: */
struct __ns6__reverseKin
{
public:
	_ns6__reverseKin *ns6__reverseKin;	/* optional element of type ns6:reverseKin */
};
#endif

#ifndef SOAP_TYPE___ns6__moveJJ
#define SOAP_TYPE___ns6__moveJJ (228)
/* Operation wrapper: */
struct __ns6__moveJJ
{
public:
	_ns6__moveJJ *ns6__moveJJ;	/* optional element of type ns6:moveJJ */
};
#endif

#ifndef SOAP_TYPE___ns6__moveJC
#define SOAP_TYPE___ns6__moveJC (231)
/* Operation wrapper: */
struct __ns6__moveJC
{
public:
	_ns6__moveJC *ns6__moveJC;	/* optional element of type ns6:moveJC */
};
#endif

#ifndef SOAP_TYPE___ns6__moveL
#define SOAP_TYPE___ns6__moveL (234)
/* Operation wrapper: */
struct __ns6__moveL
{
public:
	_ns6__moveL *ns6__moveL;	/* optional element of type ns6:moveL */
};
#endif

#ifndef SOAP_TYPE___ns6__moveC
#define SOAP_TYPE___ns6__moveC (237)
/* Operation wrapper: */
struct __ns6__moveC
{
public:
	_ns6__moveC *ns6__moveC;	/* optional element of type ns6:moveC */
};
#endif

#ifndef SOAP_TYPE___ns6__resetMotion
#define SOAP_TYPE___ns6__resetMotion (241)
/* Operation wrapper: */
struct __ns6__resetMotion
{
public:
	_ns6__resetMotion *ns6__resetMotion;	/* optional element of type ns6:resetMotion */
};
#endif

#ifndef SOAP_TYPE___ns6__stopMotion
#define SOAP_TYPE___ns6__stopMotion (244)
/* Operation wrapper: */
struct __ns6__stopMotion
{
public:
	_ns6__stopMotion *ns6__stopMotion;	/* optional element of type ns6:stopMotion */
};
#endif

#ifndef SOAP_TYPE___ns6__restartMotion
#define SOAP_TYPE___ns6__restartMotion (247)
/* Operation wrapper: */
struct __ns6__restartMotion
{
public:
	_ns6__restartMotion *ns6__restartMotion;	/* optional element of type ns6:restartMotion */
};
#endif

#ifndef SOAP_TYPE___ns6__setSchedulingMode
#define SOAP_TYPE___ns6__setSchedulingMode (251)
/* Operation wrapper: */
struct __ns6__setSchedulingMode
{
public:
	_ns6__setSchedulingMode *ns6__setSchedulingMode;	/* optional element of type ns6:setSchedulingMode */
};
#endif

#ifndef SOAP_TYPE___ns6__schedulerRefresh
#define SOAP_TYPE___ns6__schedulerRefresh (255)
/* Operation wrapper: */
struct __ns6__schedulerRefresh
{
public:
	_ns6__schedulerRefresh *ns6__schedulerRefresh;	/* optional element of type ns6:schedulerRefresh */
};
#endif

#ifndef SOAP_TYPE___ns6__setPower
#define SOAP_TYPE___ns6__setPower (259)
/* Operation wrapper: */
struct __ns6__setPower
{
public:
	_ns6__setPower *ns6__setPower;	/* optional element of type ns6:setPower */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (260)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (262)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (263)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (9)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_ns1__SessionId
#define SOAP_TYPE_ns1__SessionId (106)
typedef int ns1__SessionId;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
